<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archiew的个人博客</title>
  <icon>https://www.gravatar.com/avatar/51d9bfd6e3a8e42ee493acb38f2ec057</icon>
  <subtitle>Simple is all ！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog365.top/"/>
  <updated>2018-05-21T14:12:30.994Z</updated>
  <id>http://blog365.top/</id>
  
  <author>
    <name>archiew</name>
    <email>archiew.top@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中缀表达式Vs后缀表达式</title>
    <link href="http://blog365.top/2018/05/21/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8FVs%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog365.top/2018/05/21/中缀表达式Vs后缀表达式/</id>
    <published>2018-05-21T13:32:03.000Z</published>
    <updated>2018-05-21T14:12:30.994Z</updated>
    
    <content type="html"><![CDATA[<p>中缀表达式，运算符放两个操作数中间的，考虑运算顺序，通用记法。<br>后缀表达式(逆波兰)，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。<br>后缀表达式存在的目的在于<strong>便于计算机通过栈操作计算</strong><br><a id="more"></a></p><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式:"></a>中缀表达式转后缀表达式:</h2><p>以表达式<code>1+(2-3)*4-5/67</code>为例<br>顺序读入表达式，遵循以下规则：</p><ul><li>遇到数字直接输出</li><li>符号栈空或遇到左括号时，直接将符号入栈</li><li>遇到右括号，符号出栈并输出直到遇到左括号（左括号不输出）</li><li>遇到其他运算符（加减乘除），不断与栈顶符号对比，若优先级不高于栈顶符号，则输出栈顶符号，否则入栈</li><li>最后，将栈中操作符依次输出</li></ul><p>代码实现：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 中缀转后缀</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">res</span> = <span class="string">''</span></span><br><span class="line">operator = &#123;</span><br><span class="line">    <span class="string">'+'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'-'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'*'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'/'</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">last_isnum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in <span class="variable">s:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i not in [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>,<span class="string">'('</span>,<span class="string">')'</span>]: #数字直接输出</span><br><span class="line">        <span class="keyword">if</span> last_isnum:</span><br><span class="line">            <span class="keyword">res</span> += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">res</span> += <span class="string">' '</span>+i</span><br><span class="line">        last_isnum = <span class="number">1</span></span><br><span class="line">    elif i == <span class="string">'('</span>:   #处理左括号</span><br><span class="line">        last_isnum = <span class="number">0</span></span><br><span class="line">        t.<span class="keyword">append</span>(i)</span><br><span class="line">    elif i == <span class="string">')'</span>:   #处理右括号</span><br><span class="line">        temp = t.<span class="keyword">pop</span>()</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> not <span class="string">'('</span>:</span><br><span class="line">            <span class="keyword">if</span> last_isnum == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">res</span> += <span class="string">' '</span></span><br><span class="line">            <span class="keyword">res</span> += temp</span><br><span class="line">            temp = t.<span class="keyword">pop</span>()</span><br><span class="line">        last_isnum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:   #其他操作符处理</span><br><span class="line">        <span class="keyword">while</span> <span class="variable">t:</span></span><br><span class="line">            top = t.<span class="keyword">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> top <span class="keyword">is</span> not <span class="string">'('</span> <span class="built_in">and</span> operator[i] &lt;= operator[top]:</span><br><span class="line">                <span class="keyword">if</span> last_isnum == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">res</span> += <span class="string">' '</span></span><br><span class="line">                <span class="keyword">res</span> += top</span><br><span class="line">                pass</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t.<span class="keyword">append</span>(top)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        t.<span class="keyword">append</span>(i)</span><br><span class="line">        last_isnum = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> <span class="variable">t:</span></span><br><span class="line">    <span class="keyword">res</span> += <span class="string">' '</span>+t.<span class="keyword">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">res</span>.strip())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="number">1</span>+(<span class="number">2</span>-<span class="number">3</span>)/<span class="number">4</span>-<span class="number">5</span>/<span class="number">67</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> - <span class="number">4</span> / + <span class="number">5</span> <span class="number">67</span> / -</span><br></pre></td></tr></table></figure></p><h2 id="后缀表达式转中缀表达式"><a href="#后缀表达式转中缀表达式" class="headerlink" title="后缀表达式转中缀表达式"></a>后缀表达式转中缀表达式</h2><p>以表达式<code>1 2 3 - 4 / + 5 67 / -</code>为例<br>顺序读入表达式，遵循以下规则：</p><ul><li>遇到非运算符，直接入栈</li><li>遇到运算符，从栈中弹出最上层两个元素，并与运算符组合，将结果入栈<br>代码实现：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 后缀转中缀</span><br><span class="line"><span class="keyword">res</span> = <span class="number">0</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">s = s.<span class="keyword">split</span>(<span class="string">' '</span>)</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i in <span class="variable">s:</span></span><br><span class="line">    <span class="keyword">if</span> i not in [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>]:</span><br><span class="line">        t.<span class="keyword">append</span>(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp1 = t.<span class="keyword">pop</span>()</span><br><span class="line">        temp2 = t.<span class="keyword">pop</span>()</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">'+'</span>:</span><br><span class="line">            temp = <span class="string">'('</span>+temp2+<span class="string">'+'</span>+temp1+<span class="string">')'</span></span><br><span class="line">        elif i == <span class="string">'-'</span>:</span><br><span class="line">            temp = <span class="string">'('</span>+temp2+<span class="string">'-'</span>+temp1+<span class="string">')'</span></span><br><span class="line">        elif i == <span class="string">'*'</span>:</span><br><span class="line">            temp = temp2+<span class="string">'*'</span>+temp1</span><br><span class="line">        elif i == <span class="string">'/'</span>:</span><br><span class="line">            temp = temp2+<span class="string">'/'</span>+temp1</span><br><span class="line">        t.<span class="keyword">append</span>(temp)</span><br><span class="line">    <span class="keyword">print</span>(t)</span><br><span class="line"><span class="keyword">print</span>(t.<span class="keyword">pop</span>())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> - <span class="number">4</span> / + <span class="number">5</span> <span class="number">67</span> / -</span><br><span class="line">((<span class="number">1</span>+(<span class="number">2</span>-<span class="number">3</span>)/<span class="number">4</span>)-<span class="number">5</span>/<span class="number">67</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中缀表达式，运算符放两个操作数中间的，考虑运算顺序，通用记法。&lt;br&gt;后缀表达式(逆波兰)，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。&lt;br&gt;后缀表达式存在的目的在于&lt;strong&gt;便于计算机通过栈操作计算&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Generator</title>
    <link href="http://blog365.top/2018/05/16/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Generator/"/>
    <id>http://blog365.top/2018/05/16/深入剖析Generator/</id>
    <published>2018-05-16T13:57:31.000Z</published>
    <updated>2018-05-17T03:12:30.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generator是如何工作的？"><a href="#Generator是如何工作的？" class="headerlink" title="Generator是如何工作的？"></a>Generator是如何工作的？</h2><p>在剖析Generator之前，不妨先来回顾一下Python中普通函数是如何工作的。正常情况下，当Python主函数调用一个子函数时，子函数从主函数那里获得cpu控制权直到子函数结束或触发异常，然后主函数重新获得cpu控制权，继续执行后续任务。<br>以上我们可以通过查看Python字节码来说明。首先我们创建如下两个函数<br><a id="more"></a><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><p>通过’反汇编’获得字节码:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(foo)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_GLOBAL              <span class="number">0</span> (bar)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>foo函数首先加载bar到它的栈帧并调用(CALL_FUNCTION)它，然后把bar的返回值从栈中弹出，加载None到堆栈并返回。<br>有一点很重要：<strong>Python的栈帧实际上时分配在堆中的!</strong>Python解释器是用标准C语言实现的，它的栈帧是正常的栈帧(分配在栈空间)，而Python的栈帧是在堆中处理的，这就意味着Python中的栈帧在函数调用结束后依然可以存在，下面我们来看看这种现象：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import inspect</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; frame = None</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">global frame</span><br><span class="line">frame = inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; foo()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># The frame was executing the code for 'bar'.</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; frame.f_code.co_name</span><br><span class="line"><span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Its back pointer refers to the frame for 'foo'.</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; caller_frame = frame.f_back</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; caller_frame.f_code.co_name</span><br><span class="line"><span class="string">'foo'</span></span><br></pre></td></tr></table></figure></p><p><img src="http://aosabook.org/en/500L/crawler-images/function-calls.png" alt="函数调用"></p><p>接下来看看Generator。下面是一个Generator函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_fn</span><span class="params">()</span>:</span></span><br><span class="line">result = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">print(<span class="string">'result of yield: &#123;&#125;'</span>.format(result))</span><br><span class="line">result2 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">print(<span class="string">'result of 2nd yield: &#123;&#125;'</span>.format(result2))</span><br><span class="line"><span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></table></figure></p><p>Python规定：当一个函数中含有yield语句时，该函数会被当成是Generator函数，那么Python解释器是怎么实现这一点的呢？<br>实际上，当gen_fn函数编译为字节码时，遇到yield语句，解释器知道这是一个Generator函数，于是把对应的标志位(是的！Python是根据Generator标志位来表明该函数是一个Generator函数)。<br>可以看一下gen_fn函数对应的Generator标志位如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># The generator flag is bit position 5.</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; generator_bit = 1 &lt;&lt; 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bool(gen_fn.__code__.co_flags &amp; generator_bit)</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>所有对gen_fn的调用都指向同一个代码空间，但是每一个调用都有自己的栈帧，这些栈帧并非真正意义上的栈，而是上述所讲Python中的栈，它们时分配在堆空间的。<br><img src="http://aosabook.org/en/500L/crawler-images/generator.png" alt="Generator"><br>上图可以看到在Generator的栈帧中包含一个’f_lasti’的指针，改指针用于指向最后执行指令的位置(字节码中)，初始化为-1<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen = gen_fn()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.gi_frame.f_lasti</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>第一次调用<code>send</code>，Generator到达第一个<code>yield</code>并且暂停，<code>send</code>返回值为1。此时’f_lasti’指向第一个<code>yield</code>在字节码中的位置2。<br>第二次调用<code>send</code>，Generator到达第二个<code>yield</code>并且暂停，<code>send</code>返回值为2。此时’f_lasti’指向第二个<code>yield</code>在字节码中的位置22。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.send(None)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.gi_frame.f_lasti</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.send(None)</span><br><span class="line">result of <span class="symbol">yield:</span> None</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.gi_frame.f_lasti</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><p>可以看到，Generator函数可以随时随地被任何函数暂停，这是因为其栈帧并非真正意义上的栈空间：它是分配在堆空间的。</p><p>译自：<em><a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="noopener">a-web-crawler-with-asyncio-coroutines</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Generator是如何工作的？&quot;&gt;&lt;a href=&quot;#Generator是如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;Generator是如何工作的？&quot;&gt;&lt;/a&gt;Generator是如何工作的？&lt;/h2&gt;&lt;p&gt;在剖析Generator之前，不妨先来回顾一下Python中普通函数是如何工作的。正常情况下，当Python主函数调用一个子函数时，子函数从主函数那里获得cpu控制权直到子函数结束或触发异常，然后主函数重新获得cpu控制权，继续执行后续任务。&lt;br&gt;以上我们可以通过查看Python字节码来说明。首先我们创建如下两个函数&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
      <category term="Generator" scheme="http://blog365.top/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别</title>
    <link href="http://blog365.top/2018/05/15/%E5%90%8C%E6%AD%A5IO%E3%80%81%E5%BC%82%E6%AD%A5IO%E3%80%81%E9%98%BB%E5%A1%9EIO%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog365.top/2018/05/15/同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别/</id>
    <published>2018-05-15T03:22:48.000Z</published>
    <updated>2018-05-16T14:32:14.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>同步IO、异步IO、阻塞IO、非阻塞IO，这几个词常见于各种各样的与网络相关的文章之中，往往不同上下文中它们的意思是不一样的，以致于我在很长一段时间对此感到困惑，所以想写一篇文章整理一下。</p><blockquote><p>POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO<br>按POSIX的描述似乎把同步和阻塞划等号，异步和非阻塞划等号，但是为什么有的人说同步IO不等于阻塞IO呢？先来说说几种常见的IO模型吧。</p></blockquote><a id="more"></a><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>这里统一使用Linux下的系统调用recv作为例子，它用于从套接字上接收一个消息，因为是一个系统调用，所以调用时会从用户进程空间切换到内核空间运行一段时间再切换回来。默认情况下recv会等到网络数据到达并且复制到用户进程空间或者发生错误时返回，而第4个参数flags可以让它马上返回。</p><h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种IO模型是同步的。<br><img src="http://image.euphie.net/2017-09-24-23-18-01.png" alt="阻塞式I/O模型"></p><h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p>改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。B同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场(回到用户进程空间)，可以做他自己的事情。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)，因此它还是同步IO。<br><img src="http://image.euphie.net/2017-09-24-23-19-53.png" alt="非阻塞式I/O模型"></p><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是阻塞于select或poll，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有阻塞于系统调用的IO操作(不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络IO来说确实很短暂)，如果按这样理解，这种IO模型也能称之为非阻塞IO模型，但是按POSIX来看，它也是同步IO，那么也和楼上一样称之为同步非阻塞IO吧。<br>这种IO模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候C同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是C同学一个个打开，往杯子里装水(recv)。这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，主要区别在于舍管阿姨会告诉C同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。<br><img src="http://image.euphie.net/2017-09-24-23-21-54.png" alt="I/O复用模型"></p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv)。D同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(省不了装水的时间啊)。<br><img src="http://image.euphie.net/2017-09-24-23-22-38.png" alt="信号驱动I/O模型"></p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情(没有recv)，这才是真正的异步IO。<br><img src="http://image.euphie.net/2017-09-24-23-23-36.png" alt="异步I/O模型"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IO分两阶段：</p><blockquote><p>1.数据准备阶段<br>  2.内核空间复制回用户进程缓冲区阶段</p></blockquote><p>一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。只有异步IO模型是符合POSIX异步IO操作含义的，不管在阶段1还是阶段2都可以干别的事。</p><h4 id="ps：以上图片均截自UNIX网络编程卷1。"><a href="#ps：以上图片均截自UNIX网络编程卷1。" class="headerlink" title="ps：以上图片均截自UNIX网络编程卷1。"></a>ps：以上图片均截自UNIX网络编程卷1。</h4><p>—转载自：<a href="http://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POSIX&quot;&gt;&lt;a href=&quot;#POSIX&quot; class=&quot;headerlink&quot; title=&quot;POSIX&quot;&gt;&lt;/a&gt;POSIX&lt;/h2&gt;&lt;p&gt;同步IO、异步IO、阻塞IO、非阻塞IO，这几个词常见于各种各样的与网络相关的文章之中，往往不同上下文中它们的意思是不一样的，以致于我在很长一段时间对此感到困惑，所以想写一篇文章整理一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO&lt;br&gt;按POSIX的描述似乎把同步和阻塞划等号，异步和非阻塞划等号，但是为什么有的人说同步IO不等于阻塞IO呢？先来说说几种常见的IO模型吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="IO操作" scheme="http://blog365.top/tags/IO%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python反射机制</title>
    <link href="http://blog365.top/2018/05/02/Python%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog365.top/2018/05/02/Python反射机制/</id>
    <published>2018-05-02T12:55:32.000Z</published>
    <updated>2018-05-16T14:07:16.494Z</updated>
    
    <content type="html"><![CDATA[<p>对编程语言比较熟悉的朋友，应该知道“反射”这个机制。Python作为一门动态语言，当然不会缺少这一重要功能。然而，在网络上却很少见到有详细或者深刻的剖析论文。下面结合一个web路由的实例来阐述Python的反射机制的使用场景和核心本质。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"f1是这个函数的名字！"</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="string">"f1"</span></span><br><span class="line">print(<span class="string">"%s是个字符串"</span> % s)</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们必须区分两个概念，f1和“f1”。前者是函数f1的函数名，后者只是一个叫”f1“的字符串，两者是不同的事物。我们可以用f1()的方式调用函数f1，但我们不能用”f1”()的方式调用函数。说白了就是，<strong>不能通过字符串来调用名字看起来相同的函数！</strong><br><a id="more"></a></p><h2 id="二、web实例"><a href="#二、web实例" class="headerlink" title="二、web实例"></a>二、web实例</h2><p>考虑有这么一个场景，根据用户输入的url的不同，调用不同的函数，实现不同的操作，也就是一个url路由器的功能，这在web框架里是核心部件之一。下面有一个精简版的示例：<br>首先，有一个commons模块，它里面有几个函数，分别用于展示不同的页面，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是一个登陆页面！"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是一个退出页面！"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是网站主页面！"</span>)</span><br></pre></td></tr></table></figure></p><p>其次，有一个visit模块，作为程序入口，接受用户输入，展示相应的页面，代码如下：（这段代码是比较初级的写法）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">"login"</span>:</span><br><span class="line">        commons.login()</span><br><span class="line">    <span class="keyword">elif</span> inp == <span class="string">"logout"</span>:</span><br><span class="line">        commons.logout()</span><br><span class="line">    <span class="keyword">elif</span> inp == <span class="string">"home"</span>:</span><br><span class="line">        commons.home()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure></p><p>我们运行visit.py，输入：home，页面结果如下：</p><blockquote><p>请输入您想访问页面的url：  home<br>这是网站主页面！</p></blockquote><p>这就实现了一个简单的WEB路由功能，根据不同的url，执行不同的函数，获得不同的页面。<br>然而，让我们考虑一个问题，如果commons模块里有成百上千个函数呢(这非常正常)?。难道你在visit模块里写上成百上千个elif?显然这是不可能的！那么怎么破？</p><h2 id="三、反射机制"><a href="#三、反射机制" class="headerlink" title="三、反射机制"></a>三、反射机制</h2><p>仔细观察visit中的代码，我们会发现用户输入的url字符串和相应调用的函数名好像！如果能用这个字符串直接调用函数就好了！但是，前面我们已经说了字符串是不能用来调用函数的。为了解决这个问题，Python为我们提供一个强大的内置函数：getattr!我们将前面的visit修改一下，代码如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import commons</span><br><span class="line"> </span><br><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(commons,inp)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>首先说明一下getattr函数的使用方法：它接收2个参数，前面的是一个对象或者模块，后面的是一个字符串，注意了！是个字符串！<br>例子中，用户输入储存在inp中，这个inp就是个字符串，getattr函数让程序去commons这个模块里，寻找一个叫inp的成员（是叫，不是等于），这个过程就相当于我们把一个字符串变成一个函数名的过程。然后，把获得的结果赋值给func这个变量，实际上func就指向了commons里的某个函数。最后通过调用func函数，实现对commons里函数的调用。这完全就是一个动态访问的过程，一切都不写死，全部根据用户输入来变化。<br>执行上面的代码，结果和最开始的是一样的。<br>这就是Python的反射，它的核心本质其实就是<strong>利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动！</strong><br>这段话，不一定准确，但大概就是这么个意思。</p><h2 id="四、进一步完善"><a href="#四、进一步完善" class="headerlink" title="四、进一步完善"></a>四、进一步完善</h2><p>上面的代码还有个小瑕疵，那就是如果用户输入一个非法的url，比如jpg，由于在commons里没有同名的函数，肯定会产生运行错误，具体如下：</p><blockquote><p>请输入您想访问页面的url：  jpg<br>Traceback (most recent call last):<br>  File “F:/Python/pycharm/s13/reflect/visit.py”, line 16, in <module><br>    run()<br>  File “F:/Python/pycharm/s13/reflect/visit.py”, line 11, in run<br>    func = getattr(commons,inp)<br>AttributeError: module ‘commons’ has no attribute ‘jpg’</module></p></blockquote><p>那怎么办呢？其实，Python考虑的很全面了，它同样提供了一个叫hasattr的内置函数，用于判断commons中是否具有某个成员。我们将代码修改一下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import commons</span><br><span class="line"> </span><br><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> hasattr(commons,inp):</span><br><span class="line">        <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(commons,inp)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>通过hasattr的判断，可以防止非法输入错误，并将其统一定位到错误页面。<br>其实，研究过python内置函数的朋友，应该注意到还有delattr和setattr两个内置函数。从字面上已经很好理解他们的作用了。<br>Python的四个重要内置函数：getattr、hasattr、delattr和setattr较为全面的实现了基于字符串的反射机制。他们都是对内存内的模块进行操作，并不会对源文件进行修改。    </p><h2 id="五、动态导入模块"><a href="#五、动态导入模块" class="headerlink" title="五、动态导入模块"></a>五、动态导入模块</h2><p>上面的例子是在某个特定的目录结构下才能正常实现的，也就是commons和visit模块在同一目录下，并且所有的页面处理函数都在commons模块内。如下图：<br><img src="https://images2015.cnblogs.com/blog/948404/201606/948404-20160611234648715-2037989511.png" alt=""><br>但在现实使用环境中，页面处理函数往往被分类放置在不同目录的不同模块中，也就是如下图：<br><img src="https://images2015.cnblogs.com/blog/948404/201606/948404-20160611235720511-1977401480.png" alt=""><br>难道我们要在visit模块里写上一大堆的import 语句逐个导入account、manage、commons模块吗？要是有1000个这种模块呢？<br>刚才我们分析完了基于字符串的反射，实现了动态的函数调用功能，我们不禁会想那么能不能动态导入模块呢？这完全是可以的！<br><strong> python提供了一个特殊的方法：<strong>import</strong>(字符串参数)。通过它，我们就可以实现类似的反射功能。<strong>import</strong>()方法会根据参数，动态的导入同名的模块。</strong><br>我们再修改一下上面的visit模块的代码。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    modules, <span class="function"><span class="keyword">func</span> = <span class="title">inp</span>.<span class="title">split</span><span class="params">(<span class="string">"/"</span>)</span></span></span><br><span class="line">    obj = __import__(modules)</span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, <span class="function"><span class="keyword">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(obj, func)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>运行一下：</p><blockquote><p>请输入您想访问页面的url：  commons/home<br>这是网站主页面！<br>请输入您想访问页面的url：  account/find<br>这是一个查找功能页面！</p></blockquote><p>我们来分析一下上面的代码：<br>首先，我们并没有定义任何一行import语句；<br>其次，用户的输入inp被要求为类似“commons/home”这种格式，其实也就是模拟web框架里的url地址，斜杠左边指向模块名，右边指向模块中的成员名。<br>然后，modules,func = inp.split(“/“)处理了用户输入，使我们获得的2个字符串，并分别保存在modules和func变量里。<br>接下来，最关键的是obj = <strong>import</strong>(modules)这一行，它让程序去导入了modules这个变量保存的字符串同名的模块，并将它赋值给obj变量。<br>最后的调用中，getattr去modules模块中调用func成员的含义和以前是一样的。<br>总结：通过<strong>import</strong>函数，我们实现了基于字符串的动态的模块导入。<br>同样的，这里也有个小瑕疵！<br>如果我们的目录结构是这样的：<br><img src="https://images2015.cnblogs.com/blog/948404/201606/948404-20160612002138605-2025008087.png" alt=""><br>那么在visit的模块调用语句中，必须进行修改，我们想当然地会这么做：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    modules, <span class="function"><span class="keyword">func</span> = <span class="title">inp</span>.<span class="title">split</span><span class="params">(<span class="string">"/"</span>)</span></span></span><br><span class="line">    obj = __import__(<span class="string">"lib."</span> + modules)      <span class="meta">#注意字符串的拼接</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, <span class="function"><span class="keyword">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(obj, func)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>改了这么一个地方:obj = <strong>import</strong>(“lib.” + modules)，看起来似乎没什么问题，和import lib.commons的传统方法类似，但实际上运行的时候会有错误。</p><blockquote><p>请输入您想访问页面的url：  commons/home<br>404<br>请输入您想访问页面的url：  account/find<br>404</p></blockquote><p>为什么呢？因为<strong> 对于lib.xxx.xxx.xxx这一类的模块导入路径，<strong>import</strong>默认只会导入最开头的圆点左边的目录 </strong>，也就是“lib”。我们可以做个测试，在visit同级目录内新建一个文件，代码如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = __import__(<span class="string">"lib.commons"</span>)</span><br><span class="line">print(<span class="name">obj</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">module</span> <span class="string">'lib'</span> (<span class="keyword">namespace</span>)&gt;</span><br></pre></td></tr></table></figure></p><p>这个问题怎么解决呢？加上fromlist = True参数即可！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    modules, func = inp.split(<span class="string">"/"</span>)</span><br><span class="line">    obj = __import__(<span class="string">"lib."</span> + modules, fromlist=<span class="keyword">True</span>)  <span class="comment"># 注意fromlist参数</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, func):</span><br><span class="line">        func = getattr(obj, func)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure></p><p>至此，动态导入模块的问题基本都解决了，只剩下最后一个，那就是万一用户输入错误的模块名呢？比如用户输入了somemodules/find，由于实际上不存在somemodules这个模块，必然会报错！那有没有类似上面hasattr内置函数这么个功能呢？答案是没有！碰到这种，你只能通过异常处理来解决。</p><h2 id="六、最后的思考"><a href="#六、最后的思考" class="headerlink" title="六、最后的思考"></a>六、最后的思考</h2><p>可能有人会问Python不是有两个内置函数exec和eval吗？他们同样能够执行字符串。比如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="string">"print('haha')"</span>)</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p>结果：<br>haha</p></blockquote><p>那么直接使用它们不行吗？非要那么费劲地使用getattr，<strong>import</strong>干嘛？<br>其实，在上面的例子中，围绕的核心主题是如何利用字符串驱动不同的事件，比如导入模块、调用函数等等，这些都是Python的反射机制，是一种编程方法、设计模式的体现，凝聚了高内聚、松耦合的编程思想，不能简单的用执行字符串来代替。当然，exec和eval也有它的舞台，在web框架里也经常被使用。</p><p><strong> 转载自: <a href="https://www.cnblogs.com/Guido-admirers/p/6206212.html" target="_blank" rel="noopener">https://www.cnblogs.com/Guido-admirers/p/6206212.html</a> </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对编程语言比较熟悉的朋友，应该知道“反射”这个机制。Python作为一门动态语言，当然不会缺少这一重要功能。然而，在网络上却很少见到有详细或者深刻的剖析论文。下面结合一个web路由的实例来阐述Python的反射机制的使用场景和核心本质。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;f1是这个函数的名字！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;f1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;%s是个字符串&quot;&lt;/span&gt; % s)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的代码中，我们必须区分两个概念，f1和“f1”。前者是函数f1的函数名，后者只是一个叫”f1“的字符串，两者是不同的事物。我们可以用f1()的方式调用函数f1，但我们不能用”f1”()的方式调用函数。说白了就是，&lt;strong&gt;不能通过字符串来调用名字看起来相同的函数！&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
      <category term="反射机制" scheme="http://blog365.top/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>制作RSS电子书并推送给kindle</title>
    <link href="http://blog365.top/2018/04/22/%E5%88%B6%E4%BD%9Crss%E7%94%B5%E5%AD%90%E4%B9%A6%E5%B9%B6%E6%8E%A8%E9%80%81%E7%BB%99kindle/"/>
    <id>http://blog365.top/2018/04/22/制作rss电子书并推送给kindle/</id>
    <published>2018-04-22T03:33:09.000Z</published>
    <updated>2018-05-16T14:31:56.445Z</updated>
    
    <content type="html"><![CDATA[<p>简易信息聚合(Really Simple Syndication, RSS)是一种基于XML标准在互联网上被广泛采用的内容包装和投递协议。RSS允许用户以计算机可读的标准格式来获取（订阅）网站内容更新。相对于直接访问网站，使用Rss订阅能更快地<br>获取网站内容更新。RSS具有以下几个特点：</p><ul><li>来源多样的个性化“聚合”特性。</li><li>信息发布的时效、低成本特性。</li><li>无“垃圾”信息、便利的本地内容管理特性。</li></ul><a id="more"></a><hr><p>本文给出用python实现将RSS转换为电子书并推送给kindle的方法，可以自主方便地订阅自己感兴趣的RSS(类似<a href="http://www.dogear.cn/" target="_blank" rel="noopener">狗耳朵</a>、<a href="http://kindle4RSS.com/" target="_blank" rel="noopener">Kindle4RSS</a>之类)。</p><h2 id="一、获取并解析RSS内容"><a href="#一、获取并解析RSS内容" class="headerlink" title="一、获取并解析RSS内容"></a>一、获取并解析RSS内容</h2><p>对于RSS内容的获取解析，python有专门的第三方库可以实现：<a href="https://pypi.org/project/feedparser/" target="_blank" rel="noopener">feedparser</a>。所以我们首先安装feedparser:<br><code>pip install feedparser</code><br>然后来测试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">   Version:          Python3.6</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"></span><br><span class="line">contents = feedparser.parse(<span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>)</span><br><span class="line">print(contents)</span><br><span class="line"><span class="comment"># 打印如下：</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">'feed'</span>: &#123;</span><br><span class="line"><span class="string">'title'</span>: <span class="string">'新闻国内'</span>,</span><br><span class="line"><span class="string">'title_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'新闻国内'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'image'</span>: &#123;</span><br><span class="line"><span class="string">'title'</span>: <span class="string">'新闻国内'</span>,</span><br><span class="line"><span class="string">'title_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'新闻国内'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'links'</span>: [&#123;</span><br><span class="line"><span class="string">'rel'</span>: <span class="string">'alternate'</span>,</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://news.qq.com'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'link'</span>: <span class="string">'http://news.qq.com'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://mat1.qq.com/news/RSS/logo_news.gif'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'subtitle'</span>: <span class="string">'新闻国内'</span>,</span><br><span class="line"><span class="string">'subtitle_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'新闻国内'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'links'</span>: [&#123;</span><br><span class="line"><span class="string">'rel'</span>: <span class="string">'alternate'</span>,</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://news.qq.com/china_index.shtml'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'link'</span>: <span class="string">'http://news.qq.com/china_index.shtml'</span>,</span><br><span class="line"><span class="string">'rights'</span>: <span class="string">'Copyright 1998 - 2005 TENCENT Inc. All Rights Reserved'</span>,</span><br><span class="line"><span class="string">'rights_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'Copyright 1998 - 2005 TENCENT Inc. All Rights Reserved'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'language'</span>: <span class="string">'zh-cn'</span>,</span><br><span class="line"><span class="string">'generator_detail'</span>: &#123;</span><br><span class="line"><span class="string">'name'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'generator'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'entries'</span>: [&#123;</span><br><span class="line"><span class="string">'title'</span>: <span class="string">'钳工张学海：从0.05毫米的合格走向0.01毫米的卓越'</span>,</span><br><span class="line"><span class="string">'title_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'钳工张学海：从0.05毫米的合格走向0.01毫米的卓越'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'links'</span>: [&#123;</span><br><span class="line"><span class="string">'rel'</span>: <span class="string">'alternate'</span>,</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://news.qq.com/a/20180422/006743.htm'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'link'</span>: <span class="string">'http://news.qq.com/a/20180422/006743.htm'</span>,</span><br><span class="line"><span class="string">'authors'</span>: [&#123;</span><br><span class="line"><span class="string">'name'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'author'</span>: <span class="string">'www.qq.com'</span>,</span><br><span class="line"><span class="string">'author_detail'</span>: &#123;</span><br><span class="line"><span class="string">'name'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'tags'</span>: [],</span><br><span class="line"><span class="string">'published'</span>: <span class="string">'2018-04-22 11:32:50'</span>,</span><br><span class="line"><span class="string">'published_parsed'</span>: time.struct_time(tm_year = <span class="number">2018</span>, tm_mon = <span class="number">4</span>, tm_mday = <span class="number">22</span>, tm_hour = <span class="number">11</span>, tm_min = <span class="number">32</span>, tm_sec = <span class="number">50</span>, tm_wday = <span class="number">6</span>, tm_yday = <span class="number">112</span>, tm_isdst = <span class="number">0</span>),</span><br><span class="line"><span class="string">'comments'</span>: <span class="string">''</span>,</span><br><span class="line"><span class="string">'summary'</span>: <span class="string">'......'</span>,</span><br><span class="line"><span class="string">'summary_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'......'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>可以看出解析结果是json类型，我们可以从中提取所需信息（contents[‘feed’][‘title’],contents[‘entries’]）,其中contents[‘entries’]是个list类型，里面包含多条内容，我们逐条提取即可。</p><h2 id="二、将提取信息制作成电子书"><a href="#二、将提取信息制作成电子书" class="headerlink" title="二、将提取信息制作成电子书"></a>二、将提取信息制作成电子书</h2><p>这里用到的是Amazon提供的kindle电子书制作工具：<a href="https://www.amazon.com/gp/feature.html?docId=1000765211" target="_blank" rel="noopener">kindlegen</a><br>KindleGen 是一个免费的命令行工具，也是亚马逊唯一官方支持的文件转换工具，可通过它把 HTML、XHTML 或 IDPF 2.0 格式（带有 XML.opf 描述文件的 HTML 内容文件）的源文件创建为 Kindle 电子图书。高级用户可以使用命令行工具将 EPUB/HTML 转换为 Kindle 电子书。 您可以在 Windows、Mac 和 Linux 平台上使用此界面。此工具可用于自动批量转换。<br>1.<a href="http://kindlegen.s3.amazonaws.com/kindlegen_win32_v2_9.zip" target="_blank" rel="noopener">kindlegen下载地址</a><br>2.<a href="https://bookfere.com/post/92.html" target="_blank" rel="noopener">kindlegen用法</a><br>3.<a href="http://www.cnblogs.com/buptzym/p/5249662.html" target="_blank" rel="noopener">制作电子书相关</a><br>4.<a href="https://pan.baidu.com/s/1FY-Uvp-G-0grGDr3IAyANg" target="_blank" rel="noopener">kindlegen官方指南</a><br>这里讲几个关键，要想使用kindlegen生成电子书，需要提供几个必要文件：.html,.opf,.ncx,.jpg等，这些文件作用如下(参考3)：<br><img src="https://images2015.cnblogs.com/blog/287060/201603/287060-20160307103010788-489336141.png" alt="kindlegen所用文件"><br><strong>.html中用到的媒体文件（图片、音频等）必须保存在本地，kindlegen不负责对他们进行渲染下载。</strong><br>下面简单介绍一下这几个文件：<br><strong>.opf</strong><br>.opf是我们用kindlegen生成电子书时需要直接提供的文件，是电子书的资源索引文件，提供元数据，相当于对电子书用到的资源的一个声明:电子书用到的.html,.jpg等都需要在.opf中事先定义好才能用。.opf格式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">xmlns</span>=<span class="string">"http://www.idpf.org/2007/opf"</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">unique-identifier</span>=<span class="string">"BookId"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span> <span class="attr">xmlns:dc</span>=<span class="string">"http://purl.org/dc/elements/1.1/"</span> <span class="attr">xmlns:opf</span>=<span class="string">"http://www.idpf.org/2007/opf"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dc:title</span>&gt;</span>电子书标题<span class="tag">&lt;/<span class="name">dc:title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dc:language</span>&gt;</span>zh-cn<span class="tag">&lt;/<span class="name">dc:language</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- table of contents [mandatory] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">href</span>=<span class="string">"toc.ncx"</span> <span class="attr">media-type</span>=<span class="string">"application/x-dtbncx+xml"</span> <span class="attr">id</span>=<span class="string">"ncx"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">"tochtml"</span> <span class="attr">media-type</span>=<span class="string">"application/xhtml+xml"</span> <span class="attr">href</span>=<span class="string">"toc.html"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">"item0"</span> <span class="attr">media-type</span>=<span class="string">"application/xhtml+xml"</span> <span class="attr">href</span>=<span class="string">"Artical-1277621753.html"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!--下面是图片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">"0.368541311142"</span> <span class="attr">media-type</span>=<span class="string">"image/jpg"</span> <span class="attr">href</span>=<span class="string">"Images/-1720404282.jpg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spine</span> <span class="attr">toc</span>=<span class="string">"desertfire"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 下面描述了KG生成电子书后文本的顺序(idref必须与上述资源id对应) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemref</span> <span class="attr">idref</span>=<span class="string">"ncx"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">itemref</span> <span class="attr">idref</span>=<span class="string">"tochtml"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">itemref</span> <span class="attr">idref</span>=<span class="string">"item0"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">spine</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">guide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reference</span> <span class="attr">type</span>=<span class="string">"toc"</span> <span class="attr">title</span>=<span class="string">"Table of Contents"</span> <span class="attr">href</span>=<span class="string">"toc.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">reference</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reference</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">title</span>=<span class="string">"Welcome"</span> <span class="attr">href</span>=<span class="string">"toc.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">guide</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>熟悉.html的不难理解这个格式，关于更多详细信息，可以参考<a href="http://blog.sina.com.cn/s/blog_5c0175790100bdfv.html" target="_blank" rel="noopener">这里</a>，我们需要修改的有：<code>&lt;dc:title&gt;xxx&lt;/dc:title&gt;、&lt;item id=&quot;xxx&quot; .../&gt;、&lt;item idref=&quot;xxx&quot;/&gt;</code>，三者作用分别是：<br><img src="https://images2015.cnblogs.com/blog/287060/201603/287060-20160307103012038-1762823801.png" alt=".opf需要修改内容"><br><strong>.ncx</strong><br>.ncx是制作电子书目录的文件，这是一个xml文件，该标准由DAISY Consortium发布（参见<a href="http://www.daisy.org）。.ncx文件格式如下：" target="_blank" rel="noopener">http://www.daisy.org）。.ncx文件格式如下：</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ncx</span> <span class="attr">version</span>=<span class="string">"2005-1"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.daisy.org/z3986/2005/ncx/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- The following four metadata items are required for all NCX documents, including those conforming to the relaxed constraints of OPS 2.0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:uid"</span> <span class="attr">content</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:depth"</span> <span class="attr">content</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"RSS2kindle (by Archiew)"</span> <span class="attr">name</span>=<span class="string">"dtb:generator"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:totalPageCount"</span> <span class="attr">content</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:maxPageNumber"</span> <span class="attr">content</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"right"</span> <span class="attr">content</span>=<span class="string">"该文档由www.kindle.archiew.top生成。www.kindle.archiew.top为在线免费电子书分享平台，内容完全来自网络，仅供个人交流与学习使用，不得用于任何商业用途。"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">docTitle</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">docTitle</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">docAuthor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>Archiew<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">docAuthor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">navMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">navPoint</span> <span class="attr">id</span>=<span class="string">"navpoint-1"</span> <span class="attr">playOrder</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">navLabel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span>&gt;</span>目录<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">navLabel</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">content</span> <span class="attr">src</span>=<span class="string">"tableOfContents.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">navPoint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">navPoint</span> <span class="attr">id</span>=<span class="string">"navpoint-2"</span> <span class="attr">playOrder</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">navLabel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">navLabel</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">content</span> <span class="attr">src</span>=<span class="string">"xxx"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">navPoint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">navMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ncx</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>关于更多详细信息，可以参考<a href="http://blog.sina.com.cn/s/blog_5c0175790100bdg5.html" target="_blank" rel="noopener">这里</a>，我们需要修改的有：<code>&lt;meta name=&quot;dtb:uid&quot; content=&quot;xxx&quot;/&gt;、&lt;docTitle /&gt;、&lt;navMap /&gt;</code>，三者作用分别是：电子书uid(每本书uid不能一样)、书籍标题、目录<br><strong>.html</strong><br>分为目录html(toc.html)和正文html(chapter.html)<br>目录html用于生成电子书目录，格式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span> <span class="attr">xml:lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>电子书标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>目录标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>Made by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.kindle.archiew.top"</span>&gt;</span>书舟网<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"category"</span>&gt;</span>目录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"chapter"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"章节html链接"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>章节标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>该书籍由网页内容生成，版权归原网站所有，仅供学习交流之用，请在下载后24小时内自行删除！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>书舟网-免费电子书分享平台(www.kindle.archiew.top)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>正文html用于生成电子书正文内容，格式可以随意发挥</p><p>用kindlegen生成电子书过程为，首先根据.opf文件确定电子书需要的所有资源文件(主要是.ncx、目录html、正文html、媒体资源等)以及电子书内容的排列顺序(取决于.opf中<spine>标签下资源排列顺序)，然后将上述内容做整合生成.mobi格式的电子书<br>以上就是用kindlegen生成电子书的详细介绍，但是我们不可能手动地一个个生成所需文件，这时就需要用到<strong>模板引擎</strong>，python下推荐<a href="http://jinja.pocoo.org/" target="_blank" rel="noopener">Jinja2</a> ，有了模板引擎，我们只需提供几个模板文件，然后通过Jinja2将解析出来的RSS内容填充到模板生成所需要的文件。最后用kindlegen命令<code>kindlegen xxx.opf</code>就能生成所需的电子书了。</spine></p><h2 id="三、将电子书推送到kindle"><a href="#三、将电子书推送到kindle" class="headerlink" title="三、将电子书推送到kindle"></a>三、将电子书推送到kindle</h2><p>上面我们生成的电子书，通过邮件发送到kindle邮箱即可完成推送</p><h3 id="注意："><a href="#注意：" class="headerlink" title="*注意："></a>*注意：</h3><p>1、由于各网站生成RSS工具不一样，所以用feedparser解析出来的内容可能不太一样(不会有很大差别)；<br>2、有的RSS只提供内容摘要，如果需要获得全文输出，需要自行爬取全文或者用一些全文RSS输出工具如<a href="https://www.freefullRSS.com/" target="_blank" rel="noopener">Full RSS</a>、<a href="https://feedex.net/" target="_blank" rel="noopener">FeedEx</a><br>3、对于含图片的RSS，由于kindlegen不负责远程渲染媒体文件，所以需要自行爬取图片到本地</p><hr><p>RSS相关：<br><a href="http://ctrlq.org/RSS/" target="_blank" rel="noopener">RSS search Engine</a><br><a href="http://www.feed43.com/" target="_blank" rel="noopener">feed43</a><br><a href="http://www.feeddiy.com/" target="_blank" rel="noopener">Free online RSS generator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简易信息聚合(Really Simple Syndication, RSS)是一种基于XML标准在互联网上被广泛采用的内容包装和投递协议。RSS允许用户以计算机可读的标准格式来获取（订阅）网站内容更新。相对于直接访问网站，使用Rss订阅能更快地&lt;br&gt;获取网站内容更新。RSS具有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来源多样的个性化“聚合”特性。&lt;/li&gt;
&lt;li&gt;信息发布的时效、低成本特性。&lt;/li&gt;
&lt;li&gt;无“垃圾”信息、便利的本地内容管理特性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
      <category term="RSS" scheme="http://blog365.top/tags/RSS/"/>
    
      <category term="kindle" scheme="http://blog365.top/tags/kindle/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Python3(与Python2共存)</title>
    <link href="http://blog365.top/2018/04/15/linux%E5%AE%89%E8%A3%85python3-%E4%B8%8Epython2%E5%85%B1%E5%AD%98/"/>
    <id>http://blog365.top/2018/04/15/linux安装python3-与python2共存/</id>
    <published>2018-04-15T14:30:05.000Z</published>
    <updated>2018-05-16T14:04:42.551Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS默认安装的是Python2.7.x，对于需要Python3的场合，需要自行安装，这里给出在CentOS7.6上安装Python3的步骤。由于系统对默认的Python2.7.x有依赖，所以我们尽量不改变原有版本。</p><p>环境：CentOS7.6，默认Python2.7.5</p><a id="more"></a><hr><h2 id="1、安装依赖环境"><a href="#1、安装依赖环境" class="headerlink" title="1、安装依赖环境"></a>1、安装依赖环境</h2><blockquote><p>sudo yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</p></blockquote><h2 id="2、下载python3"><a href="#2、下载python3" class="headerlink" title="2、下载python3"></a>2、下载python3</h2><blockquote><p>sudo wget <a href="https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz</a></p></blockquote><h2 id="3、为python3创建安装目录"><a href="#3、为python3创建安装目录" class="headerlink" title="3、为python3创建安装目录"></a>3、为python3创建安装目录</h2><blockquote><p>sudo mkdir /usr/local/python3 </p></blockquote><h2 id="4、解压并切换到安装文件中"><a href="#4、解压并切换到安装文件中" class="headerlink" title="4、解压并切换到安装文件中"></a>4、解压并切换到安装文件中</h2><blockquote><p>sudo tar -zxvf Python-3.6.2.tgz<br>sudo cd Python-3.6.2</p></blockquote><h2 id="5、配置并安装"><a href="#5、配置并安装" class="headerlink" title="5、配置并安装"></a>5、配置并安装</h2><blockquote><p>sudo ./configure –prefix=/usr/local/python3<br>sudo make &amp;&amp; make install</p></blockquote><h2 id="6、创建python3、pip3软连接"><a href="#6、创建python3、pip3软连接" class="headerlink" title="6、创建python3、pip3软连接"></a>6、创建python3、pip3软连接</h2><blockquote><p>sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3<br>sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip3</p></blockquote><h2 id="7、将python默认设置为python3"><a href="#7、将python默认设置为python3" class="headerlink" title="7、将python默认设置为python3"></a>7、将python默认设置为python3</h2><blockquote><p>sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python<br>sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip<br>sudo vi /usr/bin/yum 将第一行的”#!/usr/bin/python” 改为 “#!/usr/bin/python2”<br>sudo vi /usr/libexec/urlgrabber-ext-down 将第一行的”#!/usr/bin/python” 改为 “#!/usr/bin/python2”<br>运行yum，不报错即配置完成。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS默认安装的是Python2.7.x，对于需要Python3的场合，需要自行安装，这里给出在CentOS7.6上安装Python3的步骤。由于系统对默认的Python2.7.x有依赖，所以我们尽量不改变原有版本。&lt;/p&gt;
&lt;p&gt;环境：CentOS7.6，默认Python2.7.5&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog365.top/tags/Linux/"/>
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>分享一个kindle电子书免费下载网站</title>
    <link href="http://blog365.top/2018/04/01/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AAkindle%E7%94%B5%E5%AD%90%E4%B9%A6%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99/"/>
    <id>http://blog365.top/2018/04/01/分享一个kindle电子书免费下载网站/</id>
    <published>2018-04-01T14:57:34.000Z</published>
    <updated>2018-04-08T06:26:12.572Z</updated>
    
    <content type="html"><![CDATA[<p>自从买了kindle之后，看的书的确多了起来，现在基本养成了每天睡前看半小时书的习惯，古人云：腹有诗书气自华。多读书毕竟是有好处的！Amazon电子书商店有好多书籍可供下载，包括一些免费的电子书还有定期推出的特价电子书。但是里面的书籍毕竟有限，特别是中文书。<br>为了解决找书不便的问题，本人建了一个图书搜索网站：<a href="http://kindle.archiew.top" target="_blank" rel="noopener">书舟网</a>，这是一个很简洁高效的电子书检索下载网站，界面如下：</p><a id="more"></a><hr><p><img src="http://upload-images.jianshu.io/upload_images/2321566-678d87ddf39a7747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网站首页"><br>里面现有书籍四万余册，而且每天都有更新！<br>如果觉得好用，请点击页面分享按钮，分享给朋友们吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从买了kindle之后，看的书的确多了起来，现在基本养成了每天睡前看半小时书的习惯，古人云：腹有诗书气自华。多读书毕竟是有好处的！Amazon电子书商店有好多书籍可供下载，包括一些免费的电子书还有定期推出的特价电子书。但是里面的书籍毕竟有限，特别是中文书。&lt;br&gt;为了解决找书不便的问题，本人建了一个图书搜索网站：&lt;a href=&quot;http://kindle.archiew.top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书舟网&lt;/a&gt;，这是一个很简洁高效的电子书检索下载网站，界面如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="分享" scheme="http://blog365.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="http://blog365.top/2018/04/01/Test/"/>
    <id>http://blog365.top/2018/04/01/Test/</id>
    <published>2018-04-01T13:13:22.000Z</published>
    <updated>2018-04-18T14:43:12.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Test123"><a href="#Test123" class="headerlink" title="Test123"></a>Test123</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Test123&quot;&gt;&lt;a href=&quot;#Test123&quot; class=&quot;headerlink&quot; title=&quot;Test123&quot;&gt;&lt;/a&gt;Test123&lt;/h2&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; m
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://blog365.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>

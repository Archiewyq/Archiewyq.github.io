<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archiew&#39;s blog&#39;</title>
  <icon>https://www.gravatar.com/avatar/51d9bfd6e3a8e42ee493acb38f2ec057</icon>
  <subtitle>机械 &amp; 软件.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.archiew.top/"/>
  <updated>2018-11-29T14:21:41.879Z</updated>
  <id>http://blog.archiew.top/</id>
  
  <author>
    <name>archiew</name>
    <email>archiew.top@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AES加密算法详解</title>
    <link href="http://blog.archiew.top/2018/11/29/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.archiew.top/2018/11/29/AES加密算法详解/</id>
    <published>2018-11-29T12:34:57.000Z</published>
    <updated>2018-11-29T14:21:41.879Z</updated>
    
    <content type="html"><![CDATA[<p>关于AES加密的讲解这里不再叙述，详细内容可参见《密码编码学与网络安全——原理与实践(第六版)》第5章节。这里从代码实现的角度给出AES加密算法的讲解。<br><a id="more"></a><br>首先，给出AES加密算法的总体结构<br><img src="http://pic.blog.archiew.top/image/AES加密过程.PNG" alt="AES加密过程"><br>AES加密分为两部分：迭代变换和密钥扩展。迭代变换具体来讲是下面这样一个过程：<br><img src="http://pic.blog.archiew.top/image/AES加密-迭代变换.PNG" alt="AES加密-迭代变换"></p><blockquote><p>轮密钥加(AddRoundKey)：明文状态字节与对应轮密钥的异或(Xor)操作；<br>  字节代换(Subsitute Bytes)：明文状态字节的非线性变换，实际上就是所谓的S盒映射；<br>  行移位(ShiftRows)：明文状态字节的简单置换；<br>  列混淆(MixColumns)：一个矩阵乘积(定义在有限域GF(2^8)上的矩阵运算)。</p></blockquote><p>上述步骤中要实现构造S盒，S盒的构造过程如下图：<br><img src="http://pic.blog.archiew.top/image/S盒构造过程.PNG" alt="S盒构造过程"><br>注意到上图中需要在GF(2^8)内求逆以及矩阵运算，包括迭代变换过程中的运算操作，并非简单的实数集上的算术运算，实际上涉及到数论和有限域的一些概念，关于这部分知识还是推荐参考《密码编码学与网络安全——原理与实践(第六版)一书。这里仅从运用的角度进行一些简单讲解，下文所提到的运算操作，在不指明的情况下都默认为在有限域GF(2^8)上的运算。<br>有限域可以理解为有限个元素的集合，包含加减乘除运算，并且运算必须满足以下条件：</p><blockquote><p>1、封闭性：若任意两元素a·b∈GF(q)，则有a+b∈GF(q) a·b∈GF(q);<br>  2、结合性：若任意a、b、c∈GF(q)，则有(a+b)+c=a+(b+c)，(a·b)c=a(b·c);<br>  3、交换律：若任意a、b∈GF(q)，则有a+b=b+a，a·b=b·a;<br>  4、加法单位元：GF(q)中存在一个元素0，使得对于GF(q)中的任意元素a+0=0+a=a;<br>  5、加法逆元：对于GF(q)中的任意元素a，GF(q)中一定存在元素-a，使得a+(-a)=(-a)+a=0。</p></blockquote><p>AES算法中涉及到的有限域GF(2^8)是一种特殊的有限域，在该有限域内加减运算等效于模2加法运算(或者说等效于异或运算)，乘法运算等效于多项式(将元素对应的二进制作为多项式对应项的系数)乘法运算，具体原因及讲解参见推荐书籍，这里只说结论。<br>GF(2^8)上的两个元素a,b的乘法运算定义如下：<br>假设，元素a、b对应的多项式分别为$f(x)=\sum_{i=0}^7{a_ix^i}$和$g(x)=\sum_{i=0}^7{b_ix^i}$，则有限域GF(2^8)上定义的乘法运算为$h(x)=f(x)<em>g(x)$(注意在合并同类项时的加减法是有限域GF(2^8)内的运算，即模2加)，结果对应的二进制位是多项式h(x)的各项系数。注意到多项式f(x)和g(x)相乘有可能结果次数会超过7次，对于这种情况，需要将结果模除一个8次既约多项式(既约多项式：不可进行因式分解的多项式，这样的8次既约多项式总共有30多个，AES算法只取其中一个$m(x)=x^8+x^4+x^3+x+1$)以使得结果次数不超过7<!-- ，模除的概念后面会讲到 -->。这样的定义对于计算机实现显然无从下手，所以有另外的计算机实现的方式。<br>只考虑乘法x</em>f(x)，则有$x<em>f(x)=\sum_{i=0}^7{a_ix^{i+1}}$，由上述定义规则，$$x</em>f(x)=(a_7x^8+a_6x^7+a_5x^6+a_4x^5+a_3x^4+a_2x^3+a_1x^2+a_0x) mod m(x)$$，那么就有：<br>$$x<em>f(x) = \begin{cases} (a_6a_5a_4a_3a_2a_1a_00), &amp; \text{$a_7=0$} \ (a_6a_5a_4a_3a_2a_1a_00)\oplus(00011011), &amp; \text{$a_7=0$} \end{cases}$$<br>这样对于其他乘法运算，我们可以组合的来处理，比如：$f(x)=x^6+x^4+x^2+x+1,g(x)=x^7+x+1,m(x)=x^8+x^4+x^3+x+1$，计算如下：<br>$$f(x)</em>g(x)=f(x)<em>x^7\oplus f(x)</em>x\oplus f(x)$$，对于像$x^7*f(x)$，可以通过迭代地乘x来实现。GF(2^8)上的乘法运算规则如上，具体不再多述，下面给出GF(s^8)上乘法运算的代码实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: gf_math.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;<span class="comment">//GF(2^8)内的元素都是8位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算f(x)*x^n</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> byte <span class="title">multi_x_n</span><span class="params">(<span class="keyword">const</span> byte a, <span class="keyword">const</span> byte n)</span></span>&#123;</span><br><span class="line">byte temp=x,nn=n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(--nn)&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;<span class="number">0x80</span>)</span><br><span class="line">temp = (temp&lt;&lt;<span class="number">1</span>)^<span class="number">0x1B</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp = temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算f(x)*g(x)</span></span><br><span class="line"><span class="function">byte <span class="title">multi</span><span class="params">(<span class="keyword">const</span> byte a, <span class="keyword">const</span> byte b)</span></span>&#123;</span><br><span class="line">byte s=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">byte temp=b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(temp)&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;<span class="number">0x01</span>)</span><br><span class="line">s ^= multi_x_n(a, i);</span><br><span class="line">temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><!-- GF(2^8)上的两个元素a,b的模除运算定义如下：![有限域模除运算](http://pic.blog.archiew.top/image/有限域模除运算.PNG)上述计算过程和实数集上的多项式除法相差不大，注意这里的加减运算还是模2加(异或运算)，下面的代码给出了GF(2^8)上的模除实现：```c//file: gf_math.c#include<stdio.h>typedef unsigned char byte;    //GF(2^8)内的元素都是8位的//计算x对应的二进制最高位1的位置static byte indexof_top1(const int x){    byte i=0;    int temp=x;    if(0==x)        return 0;    while(temp>>=1)        i++;    return i;}//a mod b = byte div(const int a, const byte b, int *r){    byte len=indexof_top1(a)-indexof_top1(b);    int temp_a=a;    byte temp_b=b;    if(a<b){        *r = temp_a;        return 0;    }    temp_a = temp_a^(temp_b<<len);    return (1<<len) | div(temp_a, temp_b, r);}``` -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于AES加密的讲解这里不再叙述，详细内容可参见《密码编码学与网络安全——原理与实践(第六版)》第5章节。这里从代码实现的角度给出AES加密算法的讲解。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="AES加密" scheme="http://blog.archiew.top/tags/AES%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Django实现简单模糊搜索</title>
    <link href="http://blog.archiew.top/2018/11/05/Django%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2/"/>
    <id>http://blog.archiew.top/2018/11/05/Django实现简单模糊搜索/</id>
    <published>2018-11-05T08:09:33.000Z</published>
    <updated>2018-11-05T08:23:34.252Z</updated>
    
    <content type="html"><![CDATA[<p>Django本身提供了丰富的查询过滤操作，除了常规简单操作之外，还提供了复杂条件查询功能——Q对象。通过Q对象我们可以实现组合查找，为了实现模糊查询，利用Python的map/reduce:<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line"><span class="comment">#key是一个关键词组</span></span><br><span class="line">ModelName.objects.filter(reduce(operator.or_, map(<span class="keyword">lambda</span> x:Q(name__icontains=x), key)))</span><br></pre></td></tr></table></figure></p><p>为了实现更精确的模糊搜索，需要对输入的关键词进行分词，中文分词可以利用<em>Jieba分词</em>实现，这部分以后添加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django本身提供了丰富的查询过滤操作，除了常规简单操作之外，还提供了复杂条件查询功能——Q对象。通过Q对象我们可以实现组合查找，为了实现模糊查询，利用Python的map/reduce:&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.archiew.top/tags/Python/"/>
    
      <category term="Django" scheme="http://blog.archiew.top/tags/Django/"/>
    
      <category term="模糊搜索" scheme="http://blog.archiew.top/tags/%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点汇总</title>
    <link href="http://blog.archiew.top/2018/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.archiew.top/2018/10/19/操作系统知识点汇总/</id>
    <published>2018-10-19T02:21:44.000Z</published>
    <updated>2018-11-29T11:53:24.075Z</updated>
    
    <content type="html"><![CDATA[<p>1、系统调用和过程(函数)调用的区别<br>调用形式：过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中；但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用。<br>被调用代码位置不同：过程调用是一种静态调用，调用者和调用代码在同一程序内，经过连接编辑后作为目标代码一部分。系统调用是一种动态调用，系统调用的处理代码在调用程序之外(操作系统中)。<br>提供方式：过程调用往往由编译系统提供，不同编译系统提供的过程可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、数量种类便固定不变。<br>调用实现：程序使用一般机器指令(跳转指令)来调用过程(函数)，是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行，因此，安全性好。<br><a id="more"></a></p><p>2、系统调用控制程序的过程<br>取系统调用号，校验合法性；根据系统调用号定位核心函数地址；根据通用寄存器内容，从用户栈取入口参数；核心函数执行，结果返回。</p><p>3、用户态向内核态转换的情况<br>一个是程序请求操作系统服务程序；二是程序运行时产生的中断调用。</p><p>4、Linux的中断处理</p><blockquote><p>快中断 &amp; 慢中断<br>1)处理慢中断前需保存所有寄存器的内容，而快中断处理最初保存现场时，仅要保存那些被常规C 函数修改的寄存器；<br>2)在慢中断处理时，通常不屏蔽其他中断信号，而快中断处理时会屏蔽所有其他中断；<br>3)慢中断处理完毕后，通常不立即返回被中断的进程，而是进入调度程序重新进行调度，调度结果未必是被中断的进程运行(是抢先式调度)。而快中断处理完毕后，通常恢复现场返回被中断的进程继续执行(是非抢先式调度)。<br>底半处理<br>这种一部分工作由核心代码在关中断状态下处理，另外一部分工作由中断服务程序在开中断状态下来处理的方式称为底半处理(bottom half handling)，Linux 用底半处理机制来实现中断事件的快速处理。</p></blockquote><p>5、进程上下文<br>操作系统中把进程物理实体和支持进程运行的环境合称为进程上下文（process context）。在操作系统中，进程上下文包括三个组成部分：</p><blockquote><p>用户级上下文（user -level context）：由用户进程的程序块、用户数据块（含共享数据块）和用户堆栈组成的进程地址空间。<br>系统级上下文（system -level context）：包括进程的标识信息、现场信息和控制信息，进程环境块，以及系统堆栈等组成的进程地址空间。<br>寄存器上下文（register context）：由程序状态字寄存器、各类控制寄存器、地址寄存器、通用寄存器、用户栈指针等组成。<br><img src="http://pic.blog.archiew.top/image/用户进程在虚拟内存中的组.png" alt="用户进程在虚拟内存中的组"></p></blockquote><p>6、进程队列及其管理<br><img src="http://pic.blog.archiew.top/image/操作系统的队列管理和状态.png" alt="操作系统的队列管理和状态"></p><p>7、进程切换与模式切换<br><em>中断是激活操作系统的唯一方法。</em><br>内核在四种情况下允许发生上下文切换：<br>(1) 当进程进入等待态时；<br>(2) 当进程完成其系统调用返回用户态但不是最有资格获得CPU 时；<br>(3) 当内核完成中断处理，进程返回用户态但不是最有资格获得CPU 时；<br>(4) 当进程执行结束时。<br>用户态到核心态或者核心态到用户态的转变是CPU 模式的改变，而不是进程上下文切换。<br>当中断发生的时候，暂时中断正在执行的用户进程，把进程从用户状态切换到内核状态，去执行操作系统例行程序以获得服务，这就是一次模式切换，注意，此时仍在该进程的上下文中执行，仅仅模式变了。内核在被中断了的进程的上下文中对这个中断事件作处理，即使该中断事件可能不是此进程引起的。<br>模式切换的步骤如下：</p><blockquote><p>保存被中断进程的处理器现场信息。<br>根据中断号置程序计数器。<br>把用户状态切换到内核状态，以便执行中断处理程序。</p></blockquote><p>8、进程阻塞步骤</p><blockquote><p>停止进程执行，保存现场信息到PCB<br>修改进程控制块的相关内容，如进程状态由运行改为等待<br>把修改状态后的进程控制块加入相应的等待进程队列<br>转入进程调度程序调度其他进程</p></blockquote><p>9、进程唤醒步骤</p><blockquote><p>从相应的等待进程队列取出进程控制块<br>修改进程控制块相关信息，如进程状态由等待修改为运行<br>把修改后的进程控制块加入到就绪进程队列</p></blockquote><p>10、进程创建和停止</p><blockquote><p>创建进程的系统调用sys_fork( )和sys_clone 都通过调用do_fork( )函数来完成进程的创建。在do_fork( )函数中，首先分配进程控制块task_struct 的内存和进程所需的堆栈，并检测系统是否可以增加新的进程；然后，拷贝当前进程的内容，并对一些数据成员进行初始化；再为进程的运行做准备；最后，返回生成的新进程的进程标识号（pid）。如果进程是根据sys_clone( )产生的，那么，它的进程标识号就是当前进程的进程标识号，并且对于进程控制块中的一些成员指针并不进行复制，而仅仅把这些成员指针的计数count 增加1。这样，父子进程可以有效地共享资源。</p></blockquote><blockquote><p>进程终止的系统调用sys_exit( )通过调用do_exit( )函数实现。函数do_exit( )首先释放进程占用的大部分资源，然后进入TASK_ZOMBIE 状态，调用exit_notify( )通知父子进程，调用schedule( )重新调度。</p></blockquote><p>11、单线程进程存在的问题</p><blockquote><p>进程时空的开销大，频繁的进程调度将耗费大量处理器时间，要为每个进程分配存储空间限制了操作系统中进程的总数。<br>进程通信的代价大，每次通信均要涉及通信进程之间或通信进程与操作系统之间的信息传递。<br>进程之间的并发性粒度较粗，并发度不高，过多的进程切换和通信延迟使得细粒度的并发得不偿失。<br>不适合并行计算和分布并行计算的要求，对于多处理器和分布式的计算环境来说，进程之间大量频繁的通信和切换，会大大降低并行度。<br>不适合客户/服务器计算的要求。对于C/S 结构来说，那些需要频繁输入输出并同时大量计算的服务器进程（如数据库服务器、事务监督程序）很难体现效率。</p></blockquote><p>12、进程模型<br><img src="http://pic.blog.archiew.top/image/单线程进程模型.PNG" alt="单线程进程模型"><br><img src="http://pic.blog.archiew.top/image/多线程进程模型.PNG" alt="多线程进程模型"></p><p>13、多线程进程中术语概念</p><blockquote><p>进程的定义：进程是操作系统中进行保护和资源分配的基本单位。<br>线程是操作系统进程中能够独立执行的实体（控制流），是处理器调度和分派的基本单位。（并发性、共享性、动态性、结构性）<br><img src="http://pic.blog.archiew.top/image/线程的内存布局.PNG" alt="线程的内存布局"><br><img src="http://pic.blog.archiew.top/image/线程的实现方式.png" alt="线程的实现方式"><br><em>内核级线程KLT(Kernel Level Threads)</em><br>在多处理器上，内核能够同时调度同一进程中多个线程并行执行；<br>若进程中的一个线程被阻塞了，内核能调度同一进程的其他线程占有处理器运行，也可以运行其他进程中的线程。<br>由于内核线程仅有很小的数据结构和堆栈，KLT 的切换比较快，内核自身也可以用多线程技术实现，从而，<br>能提高系统的执行速度和效率</p></blockquote><blockquote><p>KLT 的主要缺点是：应用程序线程在用户态运行，而线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要用户态-内核态-用户态的模式切换，系统开销较大。<br><img src="http://pic.blog.archiew.top/image/CPU调度层次.png" alt="CPU调度层次"></p></blockquote><p>14、作业调度算法</p><blockquote><p>先来先服务FCFS（First Come，First Served）算法<br>最短作业优先SJF（Shortest Job First ）算法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、系统调用和过程(函数)调用的区别&lt;br&gt;调用形式：过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中；但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用。&lt;br&gt;被调用代码位置不同：过程调用是一种静态调用，调用者和调用代码在同一程序内，经过连接编辑后作为目标代码一部分。系统调用是一种动态调用，系统调用的处理代码在调用程序之外(操作系统中)。&lt;br&gt;提供方式：过程调用往往由编译系统提供，不同编译系统提供的过程可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、数量种类便固定不变。&lt;br&gt;调用实现：程序使用一般机器指令(跳转指令)来调用过程(函数)，是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行，因此，安全性好。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://blog.archiew.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>秋招汇总</title>
    <link href="http://blog.archiew.top/2018/09/29/%E7%A7%8B%E6%8B%9B%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.archiew.top/2018/09/29/秋招汇总/</id>
    <published>2018-09-29T01:07:58.000Z</published>
    <updated>2018-10-09T14:05:30.228Z</updated>
    
    <content type="html"><![CDATA[<p>各公司秋招汇总：<br><a id="more"></a></p><h3 id="招银网络科技-软件开发工程师"><a href="#招银网络科技-软件开发工程师" class="headerlink" title="招银网络科技(软件开发工程师)"></a>招银网络科技(软件开发工程师)</h3><p>20180929 面试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍，简单介绍项目内容；</span><br><span class="line">2、数据库索引的优缺点；</span><br><span class="line">    优：加快索引速度，加速表之间的连接，减少磁盘I/O;</span><br><span class="line">缺：创建维护索引费时间，索引要占物理空间，更新添加删除操作数据时需要同时维护索引降低了数据维护速度。</span><br><span class="line">3、循环队列实现(讲思路)；</span><br><span class="line">数组实现：</span><br><span class="line">#define MAX_SIZE10</span><br><span class="line">typedef struct Node&#123;</span><br><span class="line">int arr[MAX_SIZE];</span><br><span class="line">int front;</span><br><span class="line">int rear;</span><br><span class="line">&#125;node;</span><br><span class="line">node *init()&#123;</span><br><span class="line">node *p=(node *)malloc(sizeof(node));</span><br><span class="line">p-&gt;front=p-&gt;rear=0;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">int push(node *p, int x)&#123;</span><br><span class="line">if((p-&gt;rear+1)%MAX_SIZE==p-&gt;front)</span><br><span class="line">return 0;</span><br><span class="line">p-&gt;arr[p-&gt;rear]=x;</span><br><span class="line">p-&gt;rear=(p-&gt;rear+1)%MAX_SIZE;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int pop(node *p)&#123;</span><br><span class="line">int s;</span><br><span class="line">if(p-&gt;rear==p-&gt;front)</span><br><span class="line">return 0;</span><br><span class="line">s=p-&gt;arr[p-&gt;front];</span><br><span class="line">p-&gt;front=(p-&gt;front+1)%MAX_SIZE;</span><br><span class="line"></span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">int len(node *p)&#123;</span><br><span class="line">return (p-&gt;rear-p-&gt;front+MAX_SIZE)%MAX_SIZE+1;</span><br><span class="line">&#125;</span><br><span class="line">3、内存分配方式；[内存分配方式与分配算法](https://blog.csdn.net/jasonlee_lijiaqi/article/details/79559793)</span><br><span class="line">连续分配：固定分区分配、动态分区分配(首次适应法、循环首次适应法、最佳适应法、快速适应法)、可重定位分区分配</span><br><span class="line">离散分配：分页存储、虚拟存储器</span><br><span class="line">4、static关键字作用；[C语言中static详细分析](https://www.cnblogs.com/JMatrix/p/8194009.html)</span><br><span class="line">static修饰的变量存在于程序的整个生命周期</span><br><span class="line">static修饰的变量只能被其作用域内的变量或函数访问</span><br><span class="line">static修饰的变量如果没有被初始化，编译器会自动赋值为0，由于其存在于全局存储区，所以只会被初始化一次</span><br><span class="line">static修饰的函数作用域是本源文件，类似于C++的private函数，static函数解决了不同文件中函数同名问题，因为一个源文件中的static函数对外不可见。</span><br><span class="line">   const关键字的作用：</span><br><span class="line">    修饰的变量内容不能被改变</span><br><span class="line">5、sizeof作用。</span><br><span class="line">运算符，求变量/类型的所占空间大小</span><br></pre></td></tr></table></figure></p><h3 id="乐鑫-嵌入式软件开发-物联网"><a href="#乐鑫-嵌入式软件开发-物联网" class="headerlink" title="乐鑫(嵌入式软件开发-物联网)"></a>乐鑫(嵌入式软件开发-物联网)</h3><p>20180927 笔试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、串口和TCP进行通信，出现数据传输丢失的原因及应对方法。</span><br><span class="line">2、单链表的反转。</span><br><span class="line">3、设计安全传输方案。</span><br><span class="line">4、英文技术文档(节选)，翻译/概述大意，文档内容大致为一个设备的SPI接口定义。</span><br><span class="line">5、算法设计。</span><br></pre></td></tr></table></figure></p><h3 id="寒武纪-嵌入式软件开发工程师"><a href="#寒武纪-嵌入式软件开发工程师" class="headerlink" title="寒武纪(嵌入式软件开发工程师)"></a>寒武纪(嵌入式软件开发工程师)</h3><p>20181008 面试(1面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍，项目讲解；</span><br><span class="line">2、开漏、推挽输出模式的区别；</span><br><span class="line">3、STM32的中断分成两个优先级(主优先级、子优先级)的作用；</span><br><span class="line">4、模拟I2C时，输入输出模式的切换；</span><br><span class="line">5、双向IO；</span><br><span class="line">6、I2C读操作流程</span><br><span class="line">7、。。。后面忘了。</span><br></pre></td></tr></table></figure></p><h3 id="比特大陆-嵌入式开发工程师"><a href="#比特大陆-嵌入式开发工程师" class="headerlink" title="比特大陆(嵌入式开发工程师)"></a>比特大陆(嵌入式开发工程师)</h3><p>20181009 面试(1面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍、项目讲解；</span><br><span class="line">2、SPI、I2C的区别；</span><br><span class="line">3、嵌入式中多进程的设计实现；</span><br><span class="line">4、对Linux内核的了解；</span><br><span class="line">5、进程上下文和终端上下文的不同(没答上来)；</span><br><span class="line">6、。。。后面忘了。</span><br></pre></td></tr></table></figure></p><p>20181009 面试(2面 HR面)<br>20181009 面试(3面 远程技术面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍、项目讲解；</span><br><span class="line">2、Python来实现文本文件中每行特定字符串的匹配；答：读文件+正则表达式匹配；</span><br><span class="line">3、段错误时怎么调试；</span><br><span class="line">4、对map文件的了解；</span><br><span class="line">5、对信号量的理解；</span><br><span class="line">6、协同开发，Git的掌握；</span><br><span class="line">7、。。。后面忘了</span><br></pre></td></tr></table></figure></p><h3 id="努比亚-驱动-协议开发工程师"><a href="#努比亚-驱动-协议开发工程师" class="headerlink" title="努比亚(驱动/协议开发工程师)"></a>努比亚(驱动/协议开发工程师)</h3><p>20181009 面试(技术面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍、项目讲解；</span><br><span class="line">2、HTTP协议中GET和POST的区别；</span><br><span class="line">3、字符串中查找子串(手撕代码，还好不难);</span><br><span class="line">4、I2C、SPI、UART的了解，I3C了解过没(没)，猜一下(没猜对)；</span><br><span class="line">6、。。。忘了。</span><br><span class="line">7、对公司的了解；</span><br><span class="line">8、闲扯了一下行业相关。。。</span><br><span class="line">** 面试体验不错</span><br></pre></td></tr></table></figure></p><p>20181009 面试(HR面)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各公司秋招汇总：&lt;br&gt;
    
    </summary>
    
    
      <category term="秋招" scheme="http://blog.archiew.top/tags/%E7%A7%8B%E6%8B%9B/"/>
    
      <category term="工作" scheme="http://blog.archiew.top/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="总结" scheme="http://blog.archiew.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="学习" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>μC/OS-II中的任务</title>
    <link href="http://blog.archiew.top/2018/09/13/%CE%BCC-OS-II%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1/"/>
    <id>http://blog.archiew.top/2018/09/13/μC-OS-II中的任务/</id>
    <published>2018-09-13T06:55:04.000Z</published>
    <updated>2018-09-13T07:58:16.631Z</updated>
    
    <content type="html"><![CDATA[<p>μC/OS-II<br>操作系统内核一项主要的工作就是对任务进行管理和调度。与之相关的内容主要包括以下几点：</p><blockquote><p>任务的基本概念，用户任务和系统任务；<br>  任务代码、任务控制块和任务堆栈；<br>  任务优先权及表示任务优先权的参数——优先级别；<br>  任务就绪表结构及其操作；<br>  任务切换及调度；<br>  任务的创建、删除、挂起、恢复和查询；<br>  μC/OS-II的初始化和启动。</p></blockquote><a id="more"></a><h2 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h2><p>从代码角度看，μC/OS-II的任务就是一个个函数，从任务的存储结构来看，μC/OS-II的任务又下图所示的三部分组成：任务程序代码(函数)、任务堆栈和任务控制块。<br><img src="http://pic.blog.archiew.top/image/μCOS-II的任务组成.png" alt="μC/OS-II的任务组成"><br><strong> * μC/OS-II中所有的任务都属于线程。</strong><br>μC/OS-II用任务控制块链表对任务进行管理，如图所示：<br><img src="http://pic.blog.archiew.top/image/任务链表.png" alt="任务链表"><br>μC/OS-II的任务分两种：系统任务和用户任务。用户任务是为了解决应用问题而编写的而系统任务是为应用程序提供某种服务或为系统本身服务的。目前在μC/OS-II中，最多可以含有64个任务(汉系统任务和用户任务)。<br>μC/OS-II是为单核CPU设计的，某一时刻只能有一个任务占用CPU处在运行状态，其他任务只能处在其他状态，μC/OS-II系统中的任务状态如下图所示<br><img src="http://pic.blog.archiew.top/image/μCOS-II系统中任务的五种状态.png" alt="μCOS-II系统中任务的五种状态"><br>各任务状态之间的切换如下图所示<br><img src="http://pic.blog.archiew.top/image/任务状态切换.png" alt="任务状态切换"><br>一个典型的用户任务代码结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//可以被中断的用户代码</span></span><br><span class="line">...</span><br><span class="line">OS_ENTER_CRITICAL();<span class="comment">//进入临界段(关中断)</span></span><br><span class="line"><span class="comment">//不可被中断的用户代码</span></span><br><span class="line">...</span><br><span class="line">OS_EXIT_CRITICAL();<span class="comment">//退出临界段(开中断)</span></span><br><span class="line"><span class="comment">//可以被中断的用户代码</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户应用程序的一般结构可参见下述代码段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask1</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask2</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask3</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">OSInit();<span class="comment">//初始化μC/OS-II</span></span><br><span class="line">...</span><br><span class="line">OSTaskCreate(MyTask1, ...);<span class="comment">//创建用户任务1</span></span><br><span class="line">OSTaskCreate(MyTask2, ...);<span class="comment">//创建用户任务2</span></span><br><span class="line">OSTaskCreate(MyTask3, ...);<span class="comment">//创建用户任务3</span></span><br><span class="line">...</span><br><span class="line">OSStart();<span class="comment">//启动μC/OS-II</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>考虑到没有用户任务执行的时候CPU不能停下来，所以μC/OS-II中必须有系统任务。μC/OS-II预定义了两个系统任务：空闲任务和统计任务。其中空闲任务是每个应用程序必须使用的，而统计任务则可以根据情况选择是否需要。<br>空闲任务就是为了防止CPU某时刻没有用户任务可执行而处于空闲状态，μC/OS-II提供了一个名为<em>OSTaskIdle()</em>的系统任务，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTaskIdle</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">pdata=pdata;<span class="comment">//防止某些编译器报错</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">OS_ENTER_CRITICAL();<span class="comment">//关中断</span></span><br><span class="line">OSdleCtr++;</span><br><span class="line">OS_EXIT_CRITICAL();<span class="comment">//开中断</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;μC/OS-II&lt;br&gt;操作系统内核一项主要的工作就是对任务进行管理和调度。与之相关的内容主要包括以下几点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任务的基本概念，用户任务和系统任务；&lt;br&gt;  任务代码、任务控制块和任务堆栈；&lt;br&gt;  任务优先权及表示任务优先权的参数——优先级别；&lt;br&gt;  任务就绪表结构及其操作；&lt;br&gt;  任务切换及调度；&lt;br&gt;  任务的创建、删除、挂起、恢复和查询；&lt;br&gt;  μC/OS-II的初始化和启动。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="μC/OS-II" scheme="http://blog.archiew.top/tags/%CE%BCC-OS-II/"/>
    
  </entry>
  
  <entry>
    <title>μC/OS-II中的数据结构</title>
    <link href="http://blog.archiew.top/2018/09/13/%CE%BCC-OS-II%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.archiew.top/2018/09/13/μC-OS-II中的数据结构/</id>
    <published>2018-09-13T02:55:58.000Z</published>
    <updated>2018-09-13T07:50:17.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、程序控制块-代码控制块"><a href="#1、程序控制块-代码控制块" class="headerlink" title="1、程序控制块(代码控制块)"></a>1、程序控制块(代码控制块)</h2><p>从代码上来看，程序控制块就是一个结构体，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcb</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *code_name;<span class="comment">//代码名称</span></span><br><span class="line"><span class="keyword">int</span> p;<span class="comment">//重要性级别</span></span><br><span class="line"><span class="keyword">int</span> v_name;<span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">void</span> (*fun)(<span class="keyword">void</span>);<span class="comment">//指向管理代码的指针</span></span><br><span class="line">&#125;TCB;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>上述实例只是最简单的关于程序控制块的说明，实际上操作系统中的程序控制块要远比例子复杂：一方面是需要记录的信息更多；另一方面它们的结构也更复杂。下图是一个稍微复杂的具有量机结构的程序控制块。<br><img src="http://pic.blog.archiew.top/image/%E5%85%B7%E6%9C%89%E4%B8%A4%E7%BA%A7%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E5%8F%AF%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.png" alt="具有两级控制块的可管理代码的结构"></p><h2 id="2、控制块的组织——链表"><a href="#2、控制块的组织——链表" class="headerlink" title="2、控制块的组织——链表"></a>2、控制块的组织——链表</h2><p>如果被管理的代码数量不大且其控制块又比较小的时候，通常会采用数组来作为程序控制块注册表。在操作系统中，需要被管理的代码数量通常比较大且其控制块又较大，可以通过链表来管理程序控制块，如下图所示<br><img src="http://pic.blog.archiew.top/image/用链表来组织的程序控制块.png" alt="用链表来组织的程序控制块"><br>值得注意的是，链表的查询是比较耗时的，因为必须从链表表头沿指针逐个查询，所以为了提高查询效率，系统常常为链表配一个数组，而这个数组的各个元素则存储了指向各个链表成员的指针，这样可以通过数组来实现链表元素的快速随机查询。<br>链表和数组相配合的结构如下图所示<br><img src="http://pic.blog.archiew.top/image/链表和数组的配合.png" alt="链表和数组的配合"></p><h2 id="3、位图"><a href="#3、位图" class="headerlink" title="3、位图"></a>3、位图</h2><p>操作系统中常常涉及到资源的使用情况记录，最简单的需要记录一个资源的占用(使用)状态(占用中or空闲)，记录的方式有很多，最简单的就是使用一种叫做<strong>位图</strong>的表格，这种表格就是将二进制数拆开使用，每一位二进制数代表一个资源的占用状态(eg. 0代表空闲 1代表占用中)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、程序控制块-代码控制块&quot;&gt;&lt;a href=&quot;#1、程序控制块-代码控制块&quot; class=&quot;headerlink&quot; title=&quot;1、程序控制块(代码控制块)&quot;&gt;&lt;/a&gt;1、程序控制块(代码控制块)&lt;/h2&gt;&lt;p&gt;从代码上来看，程序控制块就是一个结构体，例如：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tcb&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *code_name;	&lt;span class=&quot;comment&quot;&gt;//代码名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p;			&lt;span class=&quot;comment&quot;&gt;//重要性级别&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; v_name;		&lt;span class=&quot;comment&quot;&gt;//版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*fun)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);	&lt;span class=&quot;comment&quot;&gt;//指向管理代码的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;TCB;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="μC/OS-II" scheme="http://blog.archiew.top/tags/%CE%BCC-OS-II/"/>
    
  </entry>
  
  <entry>
    <title>CAN总线详解</title>
    <link href="http://blog.archiew.top/2018/08/03/CAN%E6%80%BB%E7%BA%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.archiew.top/2018/08/03/CAN总线详解/</id>
    <published>2018-08-03T01:34:29.000Z</published>
    <updated>2018-08-03T02:44:52.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>控制器局域网总线(CAN，Controller Area Network)是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议由德国的 Robert Bosch公司开发，用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb/s、同时具有11位的寻址以及检错能力。</p><a id="more"></a><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p>1、具有实时性强、传输距离较远、抗电磁干扰能力强、成本低等优点;<br>2、采用双线串行通信方式，检错能力强，可在高噪声干扰环境中工作;<br>3、具有优先权和仲裁功能，多个控制模块通过CAN 控制器挂到CAN-bus 上，形成多主机局部网络;<br>4、可根据报文的ID决定接收或屏蔽该报文;<br>5、可靠的错误处理和检错机制;<br>6、发送的信息遭到破坏后，可自动重发;<br>7、节点在错误严重的情况下具有自动退出总线的功能;<br>8、报文不包含源地址或目标地址，仅用标志符来指示功能信息、优先级信息；<br>9、32个消息对象，每个消息对象有独立的标识符掩码；<br>10、可编程FIFO模式；<br>11、可屏蔽中断；<br>12、时间触发的CAN应用支持禁用自动重传模式；<br>13、可编程的回环自测模式；</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>CAN总线使用串行数据传输方式，可以1Mb/s的速率在40m的双绞线上运行，也可以使用光缆连接，而且在这种总线上总线协议支持多主控制器。CAN与I2C总线的许多细节很类似，但也有一些明显的区别。<br>当CAN总线上的一个节点(站)发送数据时，它以<strong>报文</strong>形式<strong>广播</strong>给网络中所有节点。对每个节点来说，无论数据是否是发给自己的，都对其进行接收。每组报文开头的11位字符为标识符，定义了报文的优先级，这种报文格式称为<strong>面向内容</strong>的编址方案。在同一系统中标识符是唯一的，不可能有两个站发送具有相同标识符的报文。当几个站同时竞争总线读取时，这种配置十分重要。<br>当一个站要向其它站发送数据时，该站的CPU将要发送的数据和自己的标识符传送给本站的CAN芯片，并处于准备状态;当它收到总线分配时，转为发送报文状态。CAN芯片将数据根据协议组织成一定的报文格式发出，这时网上的其它站处于接收状态。每个处于接收状态的站对接收到的报文进行检测，判断这些报文是否是发给自己的，以确定是否接收它。<br>由于CAN总线是一种面向内容的编址方案，因此很容易建立高水准的控制系统并灵活地进行配置。我们可以很容易地在CAN总线中加进一些新站而无需在硬件或软件上进行修改。当所提供的新站是纯数据接收设备时，数据传输协议不要求独立的部分有物理目的地址。它允许分布过程同步化，即总线上控制器需要测量数据时，可由网上获得，而无须每个控制器都有自己独立的传感器。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>CAN总线在组网和通信功能上的优点以及其高性价比据定了它在许多领域有广阔的应用前景和发展潜力。这些应用有些共同之处：CAN实际就是在现场起一个总线拓扑的计算机局域网的作用。不管在什么场合，它负担的是任一节点之间的实时通信，但是它具备结构简单、高速、抗干扰、可靠、价位低等优势。CAN总线最初是为汽车的电子控制系统而设计的，目前在欧洲生产的汽车中CAN的应用已非常普遍，不仅如此，这项技术已推广到火车、轮船等交通工具中。</p><blockquote><p>1、汽车制造中的应用<br>应用CAN总线，可以减少车身布线，进一步节省了成本，由于采用总线技术，模块之间的信号传递仅需要两条信号线。布线局部化，车上除掉总线外其他所有横贯车身的线都不再需要了，节省了布线成本。CAN总线系统数据稳定可靠，CAN总线具有线间干扰小、抗干扰能力强的特点。CAN总线专为汽车量身定做，充分考虑到了汽车上恶劣工作环境，比如点火线圈点火时产生的强大的反充电压，电涡流缓冲器切断时产生的浪涌电流及汽车发动机仓100℃左右的高温。<br>2、大型仪器设备中的应用<br>大型仪器设备是一种参照一定步骤对多种信息采集、处理、控制、输出等操作的复杂系统。过去这类仪器设备的电子系统往往是在结构和成本方面占据相当大的部分，而且可靠性不高。采用CAN总线技术后，在这方面有了明显改观。<br>Can总线是针对测控领域设计的，所以一次传输的报文量很小，一次报文量最大能够承载的数据上限为8字节，这种小数据量的传输一方面能够使得低优先级事务的传输，另一方面也非常符合测控需求。针对can总线技术的诸多优点，非常适合应用于大型仪器系统模块化之间的互相通信，采用<strong>模块化组网</strong>的方式构建大型仪器系统。<br>3、工业控制中的应用<br>随着计算机技术、通信技术和控制技术的发展,传统的工业控制领域正经历着一场前所未有的变革,而工业控制的网络化,更拓展了工业控制领域的发展空间,带来新的发展机遇。在广泛的工业领域，CAN总线可作为现场设备级的通信总线，而且与其他的总线相比，具有很高的可靠性和性能价格比。这将是CAN技术开发应用的一个主要的方向。<br>4、智能家庭和生活小区管理中的应用<br>小区智能化是一个综合性系统工程，要从其功能、性能、成本、扩充能力及现代相关技术的应用等多方面来考虑。基于这样的需求，采用CAN技术所设计的家庭智能管理系统比较适合用于多表远传、防盗、防火、防可燃气体泄漏、紧急救援、家电控制等方面。<br>5、机器人网络互联中的应用<br>制造车间底层设备自动化，近几年仍是我国开展新技术研究和新技术应用工程及产品开发的主要领域，其市场需求不断增大且越发活跃，竞争也日益激烈。伴随着工业机器人的产业化，目前机器人系统的应用大多要求采用机器人生产方式，这就要求多台机器人能通过网络进行互联。随之而来的是，在实际生产过程中，这种连网的多机器人系统的调度、维护工作也变得尤为重要。制造车间底层电气装置联网是近几年内技术发展的重点。其电器装置包括有：运动控制器、基于微处理器的传感器、专用设备控制器等底层设备;在这些装置所构成的网络上另有车间级管理机、监控机或生产单元控制器等非底层装置。结合实际情况和要求，将机器人控制器视为运动控制器。</p></blockquote><h3 id="CAN使用"><a href="#CAN使用" class="headerlink" title="CAN使用"></a>CAN使用</h3><p><strong>软件初始化</strong></p><blockquote><p>置位CAN Control Register的Init位。Init位置位后，CAN节点收发停止，CAN输出CAN_TX状态为<strong>隐性</strong>(高电平)。<br>初始化CAN Controller，CPU需要设置Bit Timing Register和消息对象，未用到的消息对象应该将对应MsgVa位设为不合法。<br><strong>只有当CAN Control Register的Init和CCE位置位后，Bit Timing Register和BRP Extension Register的配置功能才能被使能</strong><br>复位Init位结束软件初始化。之后位流处理器BSP通过等待11个连续隐性位(=总线空闲)来使其自身与数据传输同步，然后才能参与总线活动并开始消息传输。<br>消息对象的初始化独立于Init，可以在运行中完成，但消息对象应全部配置为特定标识符或在BSP启动消息传输之前设置为无效。<br>要在正常操作期间更改消息对象的配置，CPU必须通过将MsgVal设置为无效来启动。 配置完成后，MsgVal再次设置为有效。</p></blockquote><p><strong>CAN消息传输</strong></p><blockquote><p>一旦CAN初始化完成并且Init位复位，CAN Core就会同步自身到CAN总线并开始消息传输<br>接收到的消息被存放在适当的消息对象中(前提是接收到的消息通过了消息处理器的接收过滤)，保存下的消息包含仲裁位、DLC(数据长度)、数据字节。如果使用标识符掩码，则可以在消息对象中覆盖被屏蔽为“不关心”的仲裁位。<br>CPU可以通过接口寄存器随时读写每条消息，消息处理程序可以在并发访问时保证数据一致性。<br>要发送的消息由CPU更新。如果是永久消息对象(对于消息，存在配置期间设置的仲裁和控制位)，仅更新数据字节，然后设置具有NewDat位的TxRqst位以开始传输。 如果将多个传输消息分配给同一消息对象（当消息对象的数量不足时），则必须在请求传输此消息之前配置整个消息对象。<br>多个消息可以同时发起发送请求，然后根据内当部优先级传输。消息可以随时更新位无效状态甚至是当请求发送仍在挂起。 在其挂起的传输开始之前更新消息时，旧数据将会被丢弃。<br>根据消息对象的配置，可以通过接收具有匹配标识符的<strong>远程帧</strong>来自主地请求消息的传输。</p></blockquote><h4 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h4><p><a href="http://embed.21ic.com/hardware/can/201611/42974.html" target="_blank" rel="noopener">CAN总线原理全解析</a><br><a href="https://download.csdn.net/download/guanjishi/1860808" target="_blank" rel="noopener">Bosch_CAN_User’s_Guide.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;控制器局域网总线(CAN，Controller Area Network)是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议由德国的 Robert Bosch公司开发，用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb/s、同时具有11位的寻址以及检错能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CAN总线" scheme="http://blog.archiew.top/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记3-优化：随机梯度下降</title>
    <link href="http://blog.archiew.top/2018/07/31/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E4%BC%98%E5%8C%96%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>http://blog.archiew.top/2018/07/31/CS231n用于视觉识别的卷积神经网络-学习笔记3-优化：随机梯度下降/</id>
    <published>2018-07-31T02:24:28.000Z</published>
    <updated>2018-08-01T10:33:41.368Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/optimization-1/" target="_blank" rel="noopener">http://cs231n.github.io/optimization-1/</a><br>翻译：<a href="http://blog.archiew.top">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入</a><br><a href="#vis">可视化损失函数</a><br><a href="#optimization">优化</a><br><a href="#opt1">　策略 #1:随机搜索</a><br><a href="#opt2">　策略 #2:随机局部搜索</a><br><a href="#opt3">　策略 #3:跟随梯度</a><br><a href="#gradcompute">梯度计算</a><br><a href="#numerically">　有限差分数值计算梯度</a><br><a href="#analysis">　微积分分析</a><br><a href="#gd">梯度下降</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a><span id="intro">引入</span></h3><p>前两讲中我们介绍了图片分类问题的两个关键任务：</p><ol><li>从图片像素到分类得分的映射：(参数化)<strong>得分函数</strong>(e.g. 线性函数)</li><li>衡量训练数据诱导得分和分类真值一致性质量的<strong>损失函数</strong>，我们了解到有很多方法和版本9)<br>具体讲，回想线性函数公式\(f(x_i,W)=Wx_i\)和SVM公式$$L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + 1) \right] + \alpha R(W)$$我们看到参数\(W\)的设置对样例\(x_i\)的预测与它们真值标签\(y_i\)相一致，这将会产生低的损失值\(L\)。接下来我们将要介绍最后一个关键部分：<strong>优化</strong>。优化指的是找出一组参数\(W\)使损失函数最小化。<br><strong>伏笔</strong> 一旦我们理解了这三个核心部分如何相互作用，我们将回到第一部分(参数化函数映射)将其扩展为一个比线性映射更加复杂的函数：首先是全神经网络，其次是卷积神经网络。损失函数和优化过程将保持相对不变。</li></ol><h3 id="可视化损失函数"><a href="#可视化损失函数" class="headerlink" title="可视化损失函数"></a><span id="vis">可视化损失函数</span></h3><p>本节中我们将会看到损失函数通常被定义为高维空间(e.g. 在CIFAR-10中，线性分类器权重矩阵大小为[10X3073]，共30730个参数)，这使得它们难以可视化。但是，我们仍可以通过沿着光线(1维)或平面(2维)切割高维空间来获得某种程度的直观。比如，我们可以产生一个随机权重矩阵\(W\)(对应于空间中的单个点)，然后沿光线行进并记录损失函数值。也就是说，我们可以产生一个随机方向\(W_1\)并通过求不同\(a\)对应的\(L(W+aW_1)\)的值来计算该方向上的损失(值)。该过程产生一个简单的图，该图以\(a\)的值为x轴以损失函数值为y轴。我们也可以通过计算以\(a\)和\(b\)为变量的损失\(L(W+aW_1+bW_2)\)的值来获得二维图，在图中，\(a\)和\(b\)对应于x轴和y轴，损失函数值可被可视化为颜色。<br><img src="http://cs231n.github.io/assets/svm_one.jpg" alt="多类SVM(未正则化)的损失函数可视化图(左、中：单一样例；右：100个样例。样例来自CIFAR-10。左：只有变量\\(a\\)的一维损失；中、右：二维损失分割，蓝=低损失 红=高损失)。注意损失函数的分段性结构。多样例损失取平均值，因此右图的碗状是许多分段线性的平均值"></p><p>上述损失函数的分段线性结构可以通过数学公式来解释。对单一样例，我们有：$$L_i = \sum_{j\neq y_i} \left[ \max(0, w_j^Tx_i - w_{y_i}^Tx_i + 1) \right]$$表达式明显地表明每个样例的损失数据是线性函数\(W\)的求和。此外，有时候\(W\)的每行(i.e. \(w_j\))在它前面都有一个正号(对应于一个例子的错误类)，有时候是负号(对应于该样例的正确类)。为使其更明确，考虑一个简单的包含三个一维点和三个分类的数据集。全SVM损失(未正则化)变成：<br>$$<br>L_0 =  \max(0, w_1^Tx_0 - w_0^Tx_0 + 1) + \max(0, w_2^Tx_0 - w_0^Tx_0 + 1) \\<br>L_1 =  \max(0, w_0^Tx_1 - w_1^Tx_1 + 1) + \max(0, w_2^Tx_1 - w_1^Tx_1 + 1) \\<br>L_2 =  \max(0, w_0^Tx_2 - w_2^Tx_2 + 1) + \max(0, w_1^Tx_2 - w_2^Tx_2 + 1) \\<br>L   =  (L_0 + L_1 + L_2)/3<br>$$<br>因为样例是一维的，数据\(x_i\)和权重\(w_j\)是数值。上述术语是\(w_0\)的线性函数，并且都被钳制在0。我们可以可视化如下：<br><img src="http://cs231n.github.io/assets/svmbowl.png" alt="数据损失的一维展示。x轴是单权值y轴是损失值。数据损失是多个项的总和，每个想都独立于特定权重或阈值为0的线性函数。完整的SVM数据损失是此形状的30,730-维版本"></p><p>顺便说一句，你可能已经从它的碗状外观猜到了，SVM成本函数是<a href="http://en.wikipedia.org/wiki/Convex_function" target="_blank" rel="noopener">凸函数</a>的一个例子。有大量的文献致力于研究最小化这种类型的函数，您也可以参加斯坦福关于此话题的课程(<a href="http://stanford.edu/~boyd/cvxbook/" target="_blank" rel="noopener">凸优化</a>)。一旦我们扩展得分函数\(f\)到神经网络，我们目标函数将会变为非凸的，并且上面的可视化不会呈现碗状特征，而是蜿蜒复杂的形状。</p><p>不可微分的损失函数。作为技术说明，你还可以在损失函数中看到kinks(转折点，因为最大化操作)，因为kinks处梯度未定义，所以使得损失函数不可微分。然而，子梯度依旧存在并且通常用于取代它。本节将会交替使用术语<strong>子梯度</strong>和<strong>梯度</strong></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><span id="optimization">优化</span></h3><p>重申一下，损失函数可以让我们量化任何特定权重集\(W\)的质量。优化的目标是找到最小化损失函数的\(W\)。我们现在要开发一种方法优化损失函数。对之前有经验的同学，本节课可能看起来很奇怪因为我们将使用的样例(SVM损失)是一个凸问题，但是请记住我们的目的是最终优化不能轻易使用凸优化文献中开发的任何工具的神经网络。</p><h4 id="策略-1-一个很糟糕的解决方案-随机搜索"><a href="#策略-1-一个很糟糕的解决方案-随机搜索" class="headerlink" title="　策略 #1:一个很糟糕的解决方案:随机搜索"></a><span id="opt1">　策略 #1:一个很糟糕的解决方案:随机搜索</span></h4><p>由于检查给定参数集\(W\)的好坏是如此简单，因此可能想到的第一个(非常糟糕的)想法是简单地尝试许多不同的随机权重值并跟踪最佳效果，此过程看起来像下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume X_train is the data where each column is an example (e.g. 3073 x 50,000)</span></span><br><span class="line"><span class="comment"># assume Y_train are the labels (e.g. 1D array of 50,000)</span></span><br><span class="line"><span class="comment"># assume the function L evaluates the loss function</span></span><br><span class="line"></span><br><span class="line">bestloss = float(<span class="string">"inf"</span>) <span class="comment"># Python assigns the highest possible float value</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">  W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.0001</span> <span class="comment"># generate random parameters</span></span><br><span class="line">  loss = L(X_train, Y_train, W) <span class="comment"># get the loss over the entire training set</span></span><br><span class="line">  <span class="keyword">if</span> loss &lt; bestloss: <span class="comment"># keep track of the best solution</span></span><br><span class="line">    bestloss = loss</span><br><span class="line">    bestW = W</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'in attempt %d the loss was %f, best %f'</span> % (num, loss, bestloss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints:</span></span><br><span class="line"><span class="comment"># in attempt 0 the loss was 9.401632, best 9.401632</span></span><br><span class="line"><span class="comment"># in attempt 1 the loss was 8.959668, best 8.959668</span></span><br><span class="line"><span class="comment"># in attempt 2 the loss was 9.044034, best 8.959668</span></span><br><span class="line"><span class="comment"># in attempt 3 the loss was 9.278948, best 8.959668</span></span><br><span class="line"><span class="comment"># in attempt 4 the loss was 8.857370, best 8.857370</span></span><br><span class="line"><span class="comment"># in attempt 5 the loss was 8.943151, best 8.857370</span></span><br><span class="line"><span class="comment"># in attempt 6 the loss was 8.605604, best 8.605604</span></span><br><span class="line"><span class="comment"># ... (trunctated: continues for 1000 lines)</span></span><br></pre></td></tr></table></figure></p><p>上面的代码中，我们尝试了一些随机权重向量\(W\)，并且其中一些效果要优于其他的。我们可以通过这种搜索来找到最佳的权重\(W\)并且在测试集上尝试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assume X_test is [3073 x 10000], Y_test [10000 x 1]</span></span><br><span class="line">scores = Wbest.dot(Xte_cols) <span class="comment"># 10 x 10000, the class scores for all test examples</span></span><br><span class="line"><span class="comment"># find the index with max score in each column (the predicted class)</span></span><br><span class="line">Yte_predict = np.argmax(scores, axis = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># and calculate accuracy (fraction of predictions that are correct)</span></span><br><span class="line">np.mean(Yte_predict == Yte)</span><br><span class="line"><span class="comment"># returns 0.1555</span></span><br></pre></td></tr></table></figure></p><p>利用最佳\(W\)，给出了大约15.5%的准确度。考虑到完全随机猜测有10%的准确度，对一个“脑死亡”随机搜索方法来讲，这不是最糟糕的！</p><p><strong>核心理念：迭代求精</strong> 当然了，事实证明，我们可以做的更好核心理念是找到一组最佳的权重\(W\)是很困难的或者说是不可能的问题(特别是当\(W\)包含了整个复杂神经网络的权重)，但是将一组特定权重\(W\)精炼的更好的问题是不太困难的。换句话说，我们的方法是从一组随机\(W\)开始，然后迭代细化，使其每次都稍微好一点。</p><blockquote><p>我们的策略是从一组随机权重\(W\)开始，然后在整个过程中迭代细化来找到最小损失。</p></blockquote><p><strong>Blindfolded hiker analogy</strong> 一个形象的比喻就是，想象自己带着眼罩在小山上徒步并试图达到底部。在CIFAR-10的例子中，因为\(W\)是10x3073，所以“小山”是30730维的。“小山”上的每一点我们都实现了特定损失(地形高度)。</p><h4 id="策略-2-随机局部搜索"><a href="#策略-2-随机局部搜索" class="headerlink" title="　策略 #2:随机局部搜索"></a><span id="opt2">　策略 #2:随机局部搜索</span></h4><p>第一种策略是沿一个随机方向扩展，具体讲，我们以一个随机\(W\)开始，产生随机扰动\(δW\)，如果扰动处损失更低，我们就更新一次。此过程编码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># generate random starting W</span></span><br><span class="line">bestloss = float(<span class="string">"inf"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">  step_size = <span class="number">0.0001</span></span><br><span class="line">  Wtry = W + np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * step_size</span><br><span class="line">  loss = L(Xtr_cols, Ytr, Wtry)</span><br><span class="line">  <span class="keyword">if</span> loss &lt; bestloss:</span><br><span class="line">    W = Wtry</span><br><span class="line">    bestloss = loss</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'iter %d loss is %f'</span> % (i, bestloss)</span><br></pre></td></tr></table></figure></p><p>使用和之前相同数量(1000)的损失函数评估，该方法实现了测试集上21.4%的预测分类准确度。有所改善，单仍耗费大量资源。</p><h4 id="策略-3-跟随梯度"><a href="#策略-3-跟随梯度" class="headerlink" title="　策略 #3:跟随梯度"></a><span id="opt3">　策略 #3:跟随梯度</span></h4><p>在先前讲解中，我们尝试在权重空间寻找一个方向来改善我们的权重向量(得到低损失值)。事实表明，我们没有必要随机搜索一个好的方向：我们可以计算出我们应该改变我们的权重向量的最佳方向，这在数学上保证是最陡下降的方向（至少在极限时为步长变为零）。该方向将与损失函数的<strong>梯度</strong>相关。在我们的徒步比喻中，这种方法大致相当于感知脚下山坡倾斜并沿着感觉最陡的方向走下去。<br>在一维函数中，斜率是函数在您感兴趣点处的瞬时变化率。梯度不是数值而是采用数值向量的函数的斜率的推广。除此之外，梯度是输入空间中每一维斜率矢量(通常称为<strong>导数</strong>)。关于其输入的一维函数导数表达式如下：<br>$$\frac{df(x)}{dx} = \lim_{h\ \to 0} \frac{f(x + h) - f(x)}{h}$$<br>当感兴趣的函数采用数值矢量而不是数值表示时，我们将导数称为<strong>偏导数</strong>，梯度只是每一维的偏导数的矢量。</p><h3 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a><span id="gradcompute">梯度计算</span></h3><p>有两种方法来计算梯度：一种是缓慢近似但简单的<strong>数值梯度</strong>，另一种时快速精确但更容易出错的<strong>解析梯度</strong>。下面我们将分别介绍两者。</p><h4 id="有限差分数值计算梯度"><a href="#有限差分数值计算梯度" class="headerlink" title="　有限差分数值计算梯度"></a><span id="numerically">　有限差分数值计算梯度</span></h4><p>上面的公式允许我们计算数值梯度。这是一个泛型函数，输入函数f，矢量x来评估梯度，并返回函数f在x处的梯度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_numerical_gradient</span><span class="params">(f, x)</span>:</span></span><br><span class="line">  <span class="string">""" </span></span><br><span class="line"><span class="string">  a naive implementation of numerical gradient of f at x </span></span><br><span class="line"><span class="string">  - f should be a function that takes a single argument</span></span><br><span class="line"><span class="string">  - x is the point (numpy array) to evaluate the gradient at</span></span><br><span class="line"><span class="string">  """</span> </span><br><span class="line"></span><br><span class="line">  fx = f(x) <span class="comment"># evaluate function value at original point</span></span><br><span class="line">  grad = np.zeros(x.shape)</span><br><span class="line">  h = <span class="number">0.00001</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># iterate over all indexes in x</span></span><br><span class="line">  it = np.nditer(x, flags=[<span class="string">'multi_index'</span>], op_flags=[<span class="string">'readwrite'</span>])</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate function at x+h</span></span><br><span class="line">    ix = it.multi_index</span><br><span class="line">    old_value = x[ix]</span><br><span class="line">    x[ix] = old_value + h <span class="comment"># increment by h</span></span><br><span class="line">    fxh = f(x) <span class="comment"># evalute f(x + h)</span></span><br><span class="line">    x[ix] = old_value <span class="comment"># restore to previous value (very important!)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute the partial derivative</span></span><br><span class="line">    grad[ix] = (fxh - fx) / h <span class="comment"># the slope</span></span><br><span class="line">    it.iternext() <span class="comment"># step to next dimension</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> grad</span><br></pre></td></tr></table></figure></p><p>按照上面给出的梯度公式，上面代码逐个迭代所有维度，h沿着改为度进行微小改变并通过查看函数值改变多少来计算损失函数沿该维度的偏导数，最后变量grad记录了完整的梯度。</p><p><strong>实际考虑</strong> 注意，在数学上，梯度定义为当h趋近于于0时的极限，但是实际操作中使用非常小的值(示例中是0.00001)就够了。理想地，我们希望使用不会导致数值问题的最小步长。此外在实际中，使用<strong>居中差异公式</strong>\([f(x+h)-f(x-h)]/2h\)计算梯度通常会更好。详情请见<a href="http://en.wikipedia.org/wiki/Numerical_differentiation" target="_blank" rel="noopener">wiki</a></p><p>利用上述公式我们可以计算任何函数任意点处的梯度。接下来我们计算CIFAR-10中损失函数在权重空间随机点处的梯度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># to use the generic code above we want a function that takes a single argument</span></span><br><span class="line"><span class="comment"># (the weights in our case) so we close over X_train and Y_train</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CIFAR10_loss_fun</span><span class="params">(W)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> L(X_train, Y_train, W)</span><br><span class="line"></span><br><span class="line">W = np.random.rand(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># random weight vector</span></span><br><span class="line">df = eval_numerical_gradient(CIFAR10_loss_fun, W) <span class="comment"># get the gradient</span></span><br></pre></td></tr></table></figure></p><p>梯度表明了每一维损失函数的斜率，我们可以以此来更新:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">loss_original = CIFAR10_loss_fun(W) <span class="comment"># the original loss</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'original loss: %f'</span> % (loss_original, )</span><br><span class="line"></span><br><span class="line"><span class="comment"># lets see the effect of multiple step sizes</span></span><br><span class="line"><span class="keyword">for</span> step_size_log <span class="keyword">in</span> [<span class="number">-10</span>, <span class="number">-9</span>, <span class="number">-8</span>, <span class="number">-7</span>, <span class="number">-6</span>, <span class="number">-5</span>,<span class="number">-4</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>]:</span><br><span class="line">  step_size = <span class="number">10</span> ** step_size_log</span><br><span class="line">  W_new = W - step_size * df <span class="comment"># new position in the weight space</span></span><br><span class="line">  loss_new = CIFAR10_loss_fun(W_new)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'for step size %f new loss: %f'</span> % (step_size, loss_new)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints:</span></span><br><span class="line"><span class="comment"># original loss: 2.200718</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-10 new loss: 2.200652</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-09 new loss: 2.200057</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-08 new loss: 2.194116</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-07 new loss: 2.135493</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-06 new loss: 1.647802</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-05 new loss: 2.844355</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-04 new loss: 25.558142</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-03 new loss: 254.086573</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-02 new loss: 2539.370888</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-01 new loss: 25392.214036</span></span><br></pre></td></tr></table></figure></p><p><strong>以负梯度方向更新</strong> 上面的代码中注意到为了计算<code>W_new</code>，我们在梯度<code>df</code>的负方向上进行更新，因为我们希望损失函数减少而不是增加。</p><p><strong>步长影响</strong> 梯度告诉我们函数最陡增长率的方向，但并没有告诉我们应该沿该方向走多远。我们将在后续课程中看到，步长(也叫<em>学习率</em>)的选择将成为训练神经网络超参设置中最重要(最头疼)的一部分。在我们的“遮眼下山”比喻中，我们感知脚下山坡向某个方向倾斜，但步长是不确定的。如果我们小心地移动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/optimization-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/optimization-1/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分类&quot;&gt;&lt;a href=&quot;#线性分类&quot; class=&quot;headerlink&quot; title=&quot;线性分类&quot;&gt;&lt;/a&gt;线性分类&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#vis&quot;&gt;可视化损失函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#optimization&quot;&gt;优化&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#opt1&quot;&gt;　策略 #1:随机搜索&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#opt2&quot;&gt;　策略 #2:随机局部搜索&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#opt3&quot;&gt;　策略 #3:跟随梯度&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#gradcompute&quot;&gt;梯度计算&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#numerically&quot;&gt;　有限差分数值计算梯度&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#analysis&quot;&gt;　微积分分析&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#gd&quot;&gt;梯度下降&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="视觉识别" scheme="http://blog.archiew.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog.archiew.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="随机梯度下降" scheme="http://blog.archiew.top/tags/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>2019大疆嵌入式软件开发招聘</title>
    <link href="http://blog.archiew.top/2018/07/08/2019%E5%A4%A7%E7%96%86%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8B%9B%E8%81%98/"/>
    <id>http://blog.archiew.top/2018/07/08/2019大疆嵌入式软件开发招聘/</id>
    <published>2018-07-08T13:10:23.000Z</published>
    <updated>2018-08-30T12:53:38.940Z</updated>
    
    <content type="html"><![CDATA[<p>刚做完大疆的2019年嵌入式软开笔试题(B卷)，作以下纪录：<br>题型：单选（2’x10=20’）、多选（3’x5=15’）、填空（4’x4=16’）、简答（6’x3=18’）、编程（ 11’+20’ = 31’）<br>时间：20180708   19:30 — 21:00（90分钟）</p><a id="more"></a><hr><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><blockquote><p>DDR特性<br>sizeof struct 和 sizeof union<br>sizeof __attribute__(packed)编译优化<br>sizeof二维数组<br>函数指针数组 int (*int a[10])(int)<br>const char *p和char * const p<br>cache<br>assert()在debug模式及release模式<br>中断context保存位置</p></blockquote><h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><blockquote><p>sizeof offsetof<br>实时嵌入式操作系统<br>关键区域保护措施(关中断？关抢占？上锁？)</p></blockquote><h3 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h3><blockquote><p>sizeof<br>memset<br>进程间通讯方式</p></blockquote><h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><blockquote><p>for(;;)函数调用次数<br>mmap和fread读文件的比较<br>实时/非实时操作系统概念、选用、优劣</p></blockquote><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><blockquote><p>删除双向链表最后N个节点(考虑N&gt;节点总数)<br>单向链表倒置</p></blockquote><p>20180720 笔试通过</p><blockquote><p>20180728 下午3点    一面(电话面)<br>首先让做自我介绍，blabla~<br>就简历上所填项目自行选择一个做详细说明，根据项目内容问几个问题<br>对方选择另外感兴趣项目，就细节进行提问，问到了断电时内存写入处理，文件传输校验，CAN总线协议(如何保证传输不出错)…blabla~<br>就自己了解的一种嵌入式操作系统进行说明。</p></blockquote><blockquote><p>20180731 晚上9点    一面(电话面，突击)<br>上来还是自我介绍，blabla~<br>问做的项目，针对项目于内容发问，对我主要是CAN总线提问<br>就简历内容发问，我简历提到用过Python，对方直接问用来做什么，答的是爬虫和网站，然后就爬虫问是否只是调用三方库实现，答的是有用库的有自己实现的，blabla~</p></blockquote><p>20180801 一面通过</p><blockquote><p>20180805 下午2:36-3:00    二面(电话面)<br>简历上的项目一个个问，以及其中细节<br>说一下对大疆的了解<br>如果项目组对多个方案不能达成一致，作为决策者，你如何决策</p></blockquote><blockquote><p>20180807 晚上7:00-7:20    二面(加面)<br>项目讲述及相关问题提问<br>对大疆的认识<br>。。。</p></blockquote><p>20180807 二面通过 收到终面邀请</p><blockquote><p>20180817 上午11:50-12:20    终面(现场)<br>自我介绍<br>挑一个熟悉的项目讲一下，项目细节<br>对大疆的认识<br>未来的职业规划</p></blockquote><p>等待结果中~~~<br>20180830 收到Thanks Letter，通知被淘汰。。。</p><p>第一份求职之路失败告终！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚做完大疆的2019年嵌入式软开笔试题(B卷)，作以下纪录：&lt;br&gt;题型：单选（2’x10=20’）、多选（3’x5=15’）、填空（4’x4=16’）、简答（6’x3=18’）、编程（ 11’+20’ = 31’）&lt;br&gt;时间：20180708   19:30 — 21:00（90分钟）&lt;/p&gt;
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="大疆" scheme="http://blog.archiew.top/tags/%E5%A4%A7%E7%96%86/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记2</title>
    <link href="http://blog.archiew.top/2018/07/06/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://blog.archiew.top/2018/07/06/CS231n用于视觉识别的卷积神经网络-学习笔记2/</id>
    <published>2018-07-06T00:59:46.000Z</published>
    <updated>2018-07-31T03:19:19.133Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/linear-classify/" target="_blank" rel="noopener">http://cs231n.github.io/linear-classify/</a><br>翻译：<a href="http://blog.archiew.top">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入线性分类</a><br><a href="#score">线性得分函数</a><br><a href="#interpret">解释线性分类器</a><br><a href="#loss">损失函数</a><br><a href="#svm">　多类SVM</a><br><a href="#softmax">　Softmax分类器</a><br><a href="#svmvssoftmax">　SVM与Softmax</a><br><a href="#demo">线性分类器Web交互式演示</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="线性分类-1"><a href="#线性分类-1" class="headerlink" title="线性分类"></a><span id="intro">线性分类</span></h3><p>上一讲中，我们介绍了图像分类的问题，即从一组固定的类别中为图像分配单个标签的任务。更重要的是，我们描述了<strong>k-最近邻（kNN）</strong>分类器，它通过将图像与训练集中的（带注释的）图像进行比较来标记图像。正如我们所看到的，kNN有许多缺点：</p><blockquote><ul><li>分类器需要存储所有训练数据以供接下来与测试数据作比较。因为数据集大小很容易达到千兆字节，所以这会导致空间效率低下。</li><li>对测试图像的分类很耗费资源因为它需要与训练集中的所有图像进行比较。</li></ul></blockquote><p><strong>预览</strong> 接下来我们要开发出来一种更加高效的方法去进行图像分类，最终自然地扩展到整个神经网络和卷积神经网络。该方法涉及两个主要部分：将原始数据映射为分类得分的<strong>score function(得分函数)</strong>，量化预测分数和真值标签之间差异的<strong>lose function(损失函数)</strong>。我们将这个问题看作优化问题：最小化关于得分函数参数的损失函数。</p><h3 id="线性得分函数"><a href="#线性得分函数" class="headerlink" title="线性得分函数"></a><span id="score">线性得分函数</span></h3><p>首先定义得分函数，该函数将图像像素值映射为每个分类的置信度分数。接下来通过一个具体例子来说明。假定图像训练集\(x_i\in{R^D}\)，与之对应的标签集为\(y_i\)，其中\(i=1…N\),\(y_i\in{1…K}\)。也就是说，我们有\(N\)个样本(每个样本维度\(D\))和\(K\)个独立标签分类。例如，对于CIFAR-10，我们的训练集有\(N=50,000\)个图片，每个图片有\(D=32X32X3=3072\)个像素，独立分类数\(K=10\)。我们现在定义原始像素映射到分类得分的得分函数：$$f:R^D→R^K$$<br><strong>线性分类器(Linear classifier)</strong> 在这里，我们从最简单的线性映射开始：$$f(x_i,W,b)=Wx_i+b$$在上述等式中，假定图片\(x_i\)已经被平铺成一个单一列向量[Dx1]。矩阵\(W\)(大小：[KxD])和向量\(b\)(大小：[Kx1])是函数的<strong>参数</strong>。在CIFAR-10中，\(x_i\)是第i个被平铺成[3072x1]的图片，\(W\)是[10x3072],\(b\)是[10x1]，也就是我们输入3072个像素值，并获得代表分类得分的10个数据输出。参数\(W\)被称作<strong>权重</strong>，\(b\)被称作<strong>偏差向量</strong>因为它影响输出得分但并不与真实数据\(x_i\)交互。<br>注意：</p><blockquote><ul><li>单一矩阵相乘\(Wx_i\)有效地并行评估10个独立分类器，\(W\)中的每行都是一个分类器</li><li>输入数据\((x_i,y_i)\)是给定的，我们控制参数\(W,b\)的设置。目标是计算全部训练集中图片分类得分并与真值分类标签相匹配。直观上我们希望正确分类能够得到比错误分类更高的分数</li><li>这种方法的一个优势是训练集用来学习参数\(W,b\)，一旦学习完成，就可以完全抛弃训练集只保留学习到的参数。因为新的测试图片可以通过此函数进行简单的前向传递并且基于得分进行分类</li><li>最后，注意到对测试图片的分类仅涉及到一次矩阵乘法和加法，这将比之前的比较测试图片与训练图片差异快得多。</li></ul></blockquote><blockquote><p>卷积神经网络将图像像素映射为上述提到的得分，但是映射\(f\)将会更复杂并且包含更多的参数</p></blockquote><h3 id="解释线性分类器"><a href="#解释线性分类器" class="headerlink" title="解释线性分类器"></a><span id="interpret">解释线性分类器</span></h3><p>注意到线性分类器计算图像3个通道所有像素值的加权和作为分类得分。根据我们设置的权重值的精度，映射函数能够反映出对图片某些位置某种颜色的倾向。例如，设想图像中有许多蓝色像素点(可能被看作是‘水’)可能被分类为‘船’。我们可能希望‘船’分类器在图片蓝色通道上有许多正权重值(蓝色的存在会增加船分类的得分)，而在红/蓝通道上有负权重值(红/蓝的存在会降低船分类的得分)。<br><img src="http://cs231n.github.io/assets/imagemap.jpg" alt="图像映射为分类得分的例子。为方便可视化展示，我们假定图像仅含4个黑白像素，并且给定了3个分类标签：猫(red),狗(green),船(blue)。注意：这里的颜色并不代表图像颜色通道，仅作区分不同类用。将图像像素平铺成一列，执行矩阵乘法加法得到每个分类的得分。注意：上图中给出的权重值是随机的，因此得分结果并不准确，实际上我们希望得分结果中猫分类得分应该是最高的。"></p><p><strong>将图像类比为高维点</strong> 因为图片被平铺为高维列向量，因此我们可以将图片对应到高维空间内的一个点(eg.CIFAR-10中的每个图片都可对应为3072维空间中的一个点)。类似地，整个数据集就对应该空间中的一组(含标签)点集。<br>因为我们定义分类得分为图像像素加权和，所以每个分类得分是整个空间的线性函数。我们无法可视化3072维空间但是设想将其压缩为2维，然后尝试可视化分类器的操作过程。<br><img src="http://cs231n.github.io/assets/pixelspace.jpeg" alt="图像空间的可视化表示，每个图片都是对应空间的一个点。以汽车分类器(red)为例，红线上点表示对应于汽车分类器的得分为0的图像。红色箭头表示汽车分类器得分增加的方向，所以红线右侧的点有正值(呈线性增加)得分，左侧的点有负值(呈线性减小)得分。"></p><p>\(W\)中的每行对应一个分类的分类器。这些数的几何解释是，当我们改变\(W\)的每一行，像素空间对应线将会旋转不同方向。另一方面偏差\(b\)允许我们的分类器翻转这条线？？？尤其要注意的是没有偏差的话，对输入\(x_i=0\)将会输出0分，无论权重值为多少，因此所有线将会穿过原点。（这段没太懂）</p><p><strong>将线性分类器解释为模板匹配</strong> 权重\(W\)的另一种解释是每行对应一个分类模板(或者称作‘原型’)。对一个图片，每个分类的得分是通过比较每个模板和图片的内积(或点积)获得。用专业术语说，线性分类器在做模板匹配，而模板是在不断学习的。其实我们还是在做最近邻工作，只不过这里使用内积来代替L1或L2距离。<br><img src="http://cs231n.github.io/assets/templates.jpg" alt="学习CIFAR-10结束时的权重示例。注意：如我们所期望的那样，船模板包含了许多蓝色像素。因此对于一幅海洋中的船图片该模板做内积将会给出高分"></p><p>除此之外，注意到上图中马的模板似乎包含了一个‘双头’马，这是因为数据集中包含了面向左侧和面向右侧两种含马的训练图片，线性分类器将这两个模型合并到一个模板图中。类似地，汽车模板似乎合并了多个模型(不同角度不同颜色)到一个模板中。最终的模板呈现红色，表明数据集中含有大量红色汽车图片。那么实际上这个线性分类器在正确识别不同颜色汽车方面还有所欠缺，随后我们在神经网络中会做这部分工作。神经网能够通过隐藏层中的中间神经元来检测特殊的汽车类型(eg.向左的绿色汽车，向前的蓝色汽车)，后层神经元可以将这些结合起来得到更精确的汽车分类得分。<br><strong>偏差技巧</strong> 为简化，这里有个小技巧，我们可以将参数\(W,b\)合为一个。常用方法是将两个参数集结合成一个单一矩阵，具体要通过扩展向量\(x_i\)的维度(增加一列)，多余出来的量默认用1来填充。这样，之前的得分函数就会变成下面这样单一矩阵乘法：$$f(x_i,W)=Wx_i$$还以CIFAR-10为例，\(x_i\)将由[3072x1]变为[3073x1]，\(W\)由[10x072]变为[10x3073]。\(W\)中多出来的列对应于偏差\(b_i\)。下面的图可能会便于理解：<br><img src="http://cs231n.github.io/assets/wb.jpeg" alt="偏差简化技巧示意图"></p><p><strong>图片预处理</strong> 上面例子中我们使用图像原始像素([0…255])，在机器学习中，更为常见的是规范化我们的输入。尤其重要的是通过减去每个特征的均值来<strong>中心化数据</strong>。对于图像而言就是要计算训练图片的均值，然后用每个图像去减去它得到像素范围在[-127,127]的图像。更进一步的常用方法是将每个图像像素值缩放至[-1,1]。零均值中心可能更重要，但我们打算放到理解了梯度下降之后再来讲。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a><span id="loss">损失函数</span></h3><p>上面章节定义了从像素值到分类得分的映射函数，通过一系列权重\(W\)使其参数化。我们希望通过调整权重值来达到预测分类得分和训练数据分类标签结果一致。<br>上面对猫的图片分类中，由于我们提供了随意的权重值，导致猫的分类得分远小于其他两个分类得分。我们将用一个<strong>损失函数</strong>(或叫<strong>成本函数</strong>，<strong>目标</strong>)来衡量得分结果与图片分类真值的差异。直观来讲，好的分类结果对应低的损失值，与之对应，坏的分类结果对应高的损失值。</p><h3 id="多类SVM损失"><a href="#多类SVM损失" class="headerlink" title="　多类SVM损失"></a><span id="svm">　多类SVM损失</span></h3><p>定义损失函数细节的方法有多种，我们先以常用的损失函数<strong>多类支持向量机(SVM)</strong>损失为例。通过固定余量Δ设置SVM损失使得SVM对于正确分类有较高的得分(相对于错误分类得分)。值得注意的是，正如我们上面所做的那样，有时候对拟人损失函数有所帮助：SVM希望在某种程度上产生更低的损失。<br>更精确一点。回想一下，对于第i个样本，给定图片\(x_i\)和标签\(y_i\)确定正确分类的索引。分数函数通过图片像素计算分类得分\(f(x_i,W)\)，我们简写作\(s\)。比如：第j个分类的得分就表示为第j个元素：\(s_j=f(x_i,W)_j\)。第i个样本的多类SVM损失可公式化表示如下：<br>$$L_i=\sum_{j≠y_i}{max(0,s_j-s_{y_i}+Δ)}$$</p><p><strong>例子</strong> 下面以一个例子来说明它是如何工作的。假定有三个分类及其得分\(s=[13,-7,11]\)，并且第一个分类是正确的分类(\(y_i=0\),\(y_i\):分类索引值)。另外假定Δ(超参数，接下来将讲到)为10。上述公式是对所有不正确的分类求和(\(j≠y_i\))，所以得到：<br>$$L_i=max(0,-7-13+10)+max(0,11-13+10)$$<br>很显然max(0,-7-13+10)结果为0，这是因为正确分类得分(13)高于错误分类得分至少10(固定Δ值)分。实际上是20分，远大于10分，但是SVM只关注两者差异至少是10分(差异高于10分的一律设置为0)。max(0,11-13+10)结果为8。也就是说，即使正确分类得分比不正确分类得分高(13&gt;11)，但差异不超过固定余量10。实际上差异是2，所以损失结果输出为8(为满足余量值所需的差异值大小)。总的来说，SVM损失函数期望正确分类得分\(y_i\)高于不正确分类得分至少Δ。如果不是，就需要累积损失。<br>注意到我们用的这个模块用了线性得分函数(\(f(x_i;W)=Wx_i\))，所以我们可以将损失函数等效为：<br>$$L_i=\sum_{j≠y_i}max(0,w_j^Tx_i-w_{y_j}^Tx_i+Δ)$$<br>其中，\(w_j\)是\(W\)的第j行转置成列。但是如果我们用更复杂的得分函数，情况就不一定了。<br>上述max(0,-)函数经常被称作<strong>hinge loss</strong>。有时会听到人们会用平方hinge loss SVM(L2-SVM)来代替，对应于\(max(0,-)^2\)，这会加强对偏离余量值的‘惩罚’。未平方版本更标准，但在某些数据集上，平方hinge loss会表现更好，这取决于交叉验证阶段的操作。</p><blockquote><p>损失函数量化了对训练集预测结果的不满</p></blockquote><p><img src="http://cs231n.github.io/assets/margin.jpg" alt="多类支持向量机工作原理。多类SVM&#39;期望&#39;正确分类得分高于不正确分类得分至少一个余量值，如果一个错误分类得分落在红色区域，那么将会有累积损失，否则损失将会是0。我们的目标是找到同时满足训练数据中所有示例的约束的权重，并给出尽可能低的总损失"></p><p><strong>正则化</strong> 上面提出的损失函数存在一个bug。假定我们有一个数据集和一个满足所有样本的参数集\(W\)(即所有得分满足上述规则，\(L_i=0\))。问题是\(W\)集可能不是唯一的：可能存在许多\(W\)的相似集满足样本。有一个简单方法验证：如果参数集\(W\)满足所有样本，那么参数集\(λW\)(λ&gt;1)也将给出0损失，因为这个操作是对所有参数的统一拉伸，因它们的绝对差值也是如此。比如，如果正确分类得分和临近不正确分类得分差值是15，对所有\(W\)中元素乘2将会得到新的差值30。<br>换句话讲，我们希望对权重集\(W\)进行某种程度上的编码来消除这种歧义性。我们可以用<strong>regularization penalty R(W)(正则化惩罚)</strong>来扩展损失函数。最常用的正则化惩罚是L2范数，它通过对所有参数的元素二次惩罚来阻止大权重：$$R(W)=\sum_{k}\sum_{l}W_{k,l}^2$$<br>上面表达式，我们对\(W\)的元素平方求和。注意到正则化函数不是与数据(图像)的函数——它仅仅是基于权重的函数。正则化惩罚完善了多类SVM，包含两部分：数据损失(所有样本数据的平均损失\(L_i\))、正则化损失。也即，完整的多类SVM表示如下：<br>$$L = \underbrace{ \frac{1}{N} \sum_i L_i }<em>\text{data loss} + \underbrace{ \lambda R(W) }</em>\text{regularization loss} $$<br>或者以完整形式扩展：<br>\(L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + \Delta) \right] + \lambda \sum_k\sum_l W_{k,l}^2\)<br>其中，N是训练样本的数量。将正则化惩罚加上去，用超参量λ作为权重。这个超参量通常取决于交叉验证。<br>除了上述提到的原因之外，正则化惩罚还有许多理想的属性，我们将会在随后讲到。例如，事实证明，加入L2惩罚会使得SVM中具有更吸引力的最大边缘属性。(<a href="http://cs229.stanford.edu/notes/cs229-notes3.pdf" target="_blank" rel="noopener">CS229</a>中将会详细讲到)<br>最吸引人的特性是惩罚大权重会改善(分类器)泛化性能，因为这意味着输入维度对最终得分没有影响。例如，假定我们有输入向量：\(x=[1,1,1,1]\)和两个权重向量：\(w_1=[1,0,0,0]\),\(w_2=[0.25,0.25,0.25,0.25]\)。那么\(w_1^Tx=w_2^Tx=1\)，两个权重向量会产生相等的点积，但是对\(w_1\)的L2惩罚是1.0而对\(w_2\)的L2惩罚仅为0.25。所以，根据L2惩罚，权重向量\(w_2\)表现更好因为它实现了跟你更低的正则化损失。直观上是因为权重\(w_2\)更小且更弥散。L2惩罚更偏向于小且弥散的权重向量，’the final classifier is encouraged to take into account all input dimensions to small amounts rather than a few input dimensions and very strongly’。后面我们将看到，这个影响能够改善分类器在测试集上的泛化性能并拥有较低的过拟合。<br>注意到偏差不像权重值那样的影响强度。因此通常知识调整权重而不是偏差。然而，在实际操作中，这经常会产生一些细微的影响。最后，注意到因为正则化惩罚，我们无法在所有样例中实现0.0的精确损失。<br><strong>代码</strong> 这里给出了损失函数(未正则化)的Python实现(未矢量和半矢量形式)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i</span><span class="params">(x, y, W)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  unvectorized version. Compute the multiclass svm loss for a single example (x,y)</span></span><br><span class="line"><span class="string">  - x is a column vector representing an image (e.g. 3073 x 1 in CIFAR-10)</span></span><br><span class="line"><span class="string">    with an appended bias dimension in the 3073-rd position (i.e. bias trick)</span></span><br><span class="line"><span class="string">  - y is an integer giving index of correct class (e.g. between 0 and 9 in CIFAR-10)</span></span><br><span class="line"><span class="string">  - W is the weight matrix (e.g. 10 x 3073 in CIFAR-10)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  delta = <span class="number">1.0</span> <span class="comment"># see notes about delta later in this section</span></span><br><span class="line">  scores = W.dot(x) <span class="comment"># scores becomes of size 10 x 1, the scores for each class</span></span><br><span class="line">  correct_class_score = scores[y]</span><br><span class="line">  D = W.shape[<span class="number">0</span>] <span class="comment"># number of classes, e.g. 10</span></span><br><span class="line">  loss_i = <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> xrange(D): <span class="comment"># iterate over all wrong classes</span></span><br><span class="line">    <span class="keyword">if</span> j == y:</span><br><span class="line">      <span class="comment"># skip for the true class to only loop over incorrect classes</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># accumulate loss for the i-th example</span></span><br><span class="line">    loss_i += max(<span class="number">0</span>, scores[j] - correct_class_score + delta)</span><br><span class="line">  <span class="keyword">return</span> loss_i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i_vectorized</span><span class="params">(x, y, W)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  A faster half-vectorized implementation. half-vectorized</span></span><br><span class="line"><span class="string">  refers to the fact that for a single example the implementation contains</span></span><br><span class="line"><span class="string">  no for loops, but there is still one loop over the examples (outside this function)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  delta = <span class="number">1.0</span></span><br><span class="line">  scores = W.dot(x)</span><br><span class="line">  <span class="comment"># compute the margins for all classes in one vector operation</span></span><br><span class="line">  margins = np.maximum(<span class="number">0</span>, scores - scores[y] + delta)</span><br><span class="line">  <span class="comment"># on y-th position scores[y] - scores[y] canceled and gave delta. We want</span></span><br><span class="line">  <span class="comment"># to ignore the y-th position and only consider margin on max wrong class</span></span><br><span class="line">  margins[y] = <span class="number">0</span></span><br><span class="line">  loss_i = np.sum(margins)</span><br><span class="line">  <span class="keyword">return</span> loss_i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L</span><span class="params">(X, y, W)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  fully-vectorized implementation :</span></span><br><span class="line"><span class="string">  - X holds all the training examples as columns (e.g. 3073 x 50,000 in CIFAR-10)</span></span><br><span class="line"><span class="string">  - y is array of integers specifying correct class (e.g. 50,000-D array)</span></span><br><span class="line"><span class="string">  - W are weights (e.g. 10 x 3073)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="comment"># evaluate loss over all examples in X without using any for loops</span></span><br><span class="line">  <span class="comment"># left as exercise to reader in the assignment</span></span><br></pre></td></tr></table></figure></p><p>本节的内容是SVM损失采用一种特定的方法来测量训练数据的预测与真值标签的一致性。 此外，对训练集进行良好预测相当于最大限度地减少损失。</p><blockquote><p>我们需要做的就是提出一种找到满足最小损失的方法</p></blockquote><h4 id="实际考虑因素"><a href="#实际考虑因素" class="headerlink" title="实际考虑因素"></a>实际考虑因素</h4><p><strong>设置Δ</strong> 应该设为什么？需不需要进行交叉验证？实际上，超参量Δ在所有例子中可以被安全地设置为1.权重\(W\)的大小直接影响到最后的得分(和他们的差异)：因为我们缩小了\(W\)的值，得分之间的差异将会更低，另一方面我们放大了权重值，这会使得分之间的差异变大。因此，得分边界的确切值(e.g. Δ=1 or Δ=100)是没有意义的，因为权重可以随意缩放差异值。因此，唯一的权衡是允许权重值增长程度(通过正则化强度λ)。<br><strong>和二进制支持向量机的关系</strong> 二进制支持向量机下第i个样例的损失表示如下：$$L_i=Cmax(0,1-y_iw^Tx_i)+R(W)$$其中\(C\)是超参量，\(y_i \in {-1,1}\)。可以把二进制支持向量机理解为我们之前提出的多类SVM的一种特例：如果只有两个分类，多类SVM就成了二进制SVM。上述公式中的\(C\)和我们之前公式中的\(λ\)控制着相同的权衡，并且是倒数关系\(C \propto \frac{1}{\lambda}\)。<br><strong>原始优化</strong> 如果你以前了解SVM知识，你可能听说过内核，双重，SMO算法等。在这个课程中（神经网络）我们将一直使用无约束原始形式的优化目标。这些目标中的许多在技术上是不可微分的(例如，max(x，y)函数，因为当x=y时它具有扭结)，但实际上这不是问题，并且通常使用子梯度。<br><strong>其他多类SVM公式化</strong> 值得注意的是，本节提出的多类SVM是多个多类SVM公式化中的一个。另一个常用的公式是<em>One-Vs-All</em>(OVA)SVM，它为每个分类单独训练二进制SVM。还有不太常用的<em>All-vs-All</em>(AVA)策略。我们的公式遵从<a href="https://www.elen.ucl.ac.be/Proceedings/esann/esannpdf/es1999-461.pdf" target="_blank" rel="noopener">Weston and Watkins 1999 (pdf) </a>版本，这是一个比OVA更强大的版本(从某种意义上说，你可以构建多版本数据集，其中这个版本可以实现零数据损失，但OVA不能。如果感兴趣，请参阅论文)。最后是<em>结构化SVM</em>，它可以最大化正确分类得分与得分次高间的差距。理解这些公式之间的差异超出本课程范围。本节提出的版本是实际操作安全的，但最简单的OVA策略也可能同样有效</p><h3 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="　Softmax分类器"></a><span id="softmax">　Softmax分类器</span></h3><p>SVM是两个常用的分类器之一，另一个是<strong>Softmax classifier</strong>。如果你之前听过二进制Logistic Regression分类器，Softmax分类器是它在多类上的推广。不同于SVM将输出\(f(x_i,W)\)作为每个分类的得分，Softmax分类器给出一个更直观的输出(标准化类概率)，和稍后将讲到的概率解释。在Softmax分类器中，函数映射\(f(x_i;W)=Wx_i\)不变，但我们现在将这些分类得分解释为每个分类的非标准化对数概率，并用具有以下形式的交叉熵损失替换hinge损失：$$L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right) \hspace{0.5in} \text{or equivalently} \hspace{0.5in} L_i = -f_{y_i} + \log\sum_j e^{f_j}$$用\(f_j\)表示分类得分向量\(f\)的第j个元素。像之前一样，数据集的全部损失是所有训练样例\(L_i\)的平均值，有一个正则化术语\(R(W)\)。函数\(f_j(z) = \frac{e^{z_j}}{\sum_k e^{z_k}}\)被称作<strong>softmax function</strong>:它将任意真值得分向量压缩到值为0到1之间且和为1的向量。如果是第一次接触，softmax函数中涉及到的全交叉熵损失看起来很可怕，实际上相对容易激励。<br><strong>信息论观点</strong> “真实”分布\(p\)和预测分布\(q\)之间的交叉熵定义为：$$H(p,q) = - \sum_x p(x) \log q(x)$$Softmax分类器最小化两者之间的交叉熵(\(q = e^{f_{y_i}}  / \sum_j e^{f_j}\))，which in this interpretation is the distribution where all probability mass is on the correct class (i.e. \(p=[0,…1,…,0]\)contains a single 1 at the\(y_i\)-th position.)。此外，因为交叉熵可以被写作\(H(p,q) = H(p) + D_{KL}(p||q)\)，Δ函数\(p\)的熵为0，等同于两个分布之间KL差异(一种距离测量)的最小化。换句话说，交叉熵客观上_希望_预测分布能够在正确答案上有全部的质量。<br><strong>概率解释</strong> 下式：$$P(y_i \mid x_i; W) = \frac{e^{f_{y_i}}}{\sum_j e^{f_j} }$$可以解释为给定图像\(x_i\)和参数化\(W\)的正确标签\(y_i\)分配的（标准化）概率？？？Softmax分类器将输出向量\(f\)中的得分解释为未标准化的对数概率。指数化这些量给出的概率，并且执行除法归一化，使概率和为1。在这个概率解释中，我们因此最小化正确分类的负对数似然(这可以被解释为执行<strong>最大似然估计</strong>，MLE)。这种观点有个良好的特性，使得我们能够解释来自高斯先验超权重矩阵的完全损失函数中的正则化项\(R(W)\)，而不是我们正在执行的最大后验(MAP)估计。我们提到这些解释来帮助你的直觉，但推导的细节超出本课程范围。<br><strong>实际问题：数字稳定性</strong> 在实际编写用于计算Softmax函数的代码时，中间项\(e^{f_{y_i}}\)和\(\sum_j e^{f_j}\)会由于指数(运算)而变得非常大。划分大数值可能不稳定，因此使用归一化技巧很重要。请注意：如果我们将分子分母同乘一个常量C，并分别相加，我们得到下述表达式：\(\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}} = \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}\) \(C\)的值可以自由选择，这不会对结果造成影响，我们可以借助这个值来改善计算数值的稳定性。常用的选择是将其设为\(logC=-max_jf_j\)。代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) <span class="comment">#假设有3个分类获得较大的得分</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment">#坏:数值计算问题，潜在爆炸性计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#改善:左移f值，使得最大数字为0:</span></span><br><span class="line">f -= np.max(f) <span class="comment">#f变为[-666, -333, 0]</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># 安全计算，给出正确值</span></span><br></pre></td></tr></table></figure></p><p><strong>命名约定</strong>  确切来讲，SVM分类器使用hinge loss，或者有时候称作<strong>max-margin(最大边界) loss</strong>。Softmax分类器使用<strong>cross-entropy(交叉熵) loss</strong>。Softmax分类器名字来源于softmax函数，该函数用于将原始类分数压缩为归一化的正值，以便可以应用交叉熵损失。在实际中，需要注意的是：技术上谈论softmax损失是没有意义的，因为softmax只有压缩作用，但是它是一种相当常用的简写。</p><h3 id="SVM-vs-Softmax"><a href="#SVM-vs-Softmax" class="headerlink" title="　SVM vs. Softmax "></a><span id="svmvssoftmax">　SVM vs. Softmax </span></h3><p><img src="http://cs231n.github.io/assets/svmvssoftmax.png" alt="SVM和Softmax分类器比较"></p><p><strong>Softmax分类器提供了每个分类的可能性</strong> 与计算所有类别的未校准且不易解释的SVM不同，Softmax分类器允许我们计算所有分类的“概率”。例如：给定一个图片，SVM分类器可能给出标签为“猫，狗，船”的得分[12.5,0.6,-23.0]。Softmax分类器则将计算这三个分类的概率为[0.9,0.09,0.01]。然而，我们将概率加引号是因为这些概率的峰值或者扩散程度如何将直接取决于正则化强度\(λ\)-您负责作为系统的输入。例如：假定三个分类的非标准化对数概率输出为[1,-2,0]。Softmax函数计算如下：<br>$$[1, -2, 0] \rightarrow [e^1, e^{-2}, e^0] = [2.71, 0.14, 1] \rightarrow [0.7, 0.04, 0.26]$$<br>这一步是做了指数化和归一化。如果正则强度\(λ\)太高，权重\(W\)将会做更多惩罚以此来获得更小的权重。例如，假定权重变为原来一半([0.5,-1,0])，Softmax计算如下：<br>$$[0.5, -1, 0] \rightarrow [e^{0.5}, e^{-1}, e^0] = [1.65, 0.37, 1] \rightarrow [0.55, 0.12, 0.33]$$<br>现在概率更加分散。此外，由于非常强的正则化强度λ，权重朝向微小数量的极限，输出概率几乎是均匀的。因此，由Softmax分类器计算的概率更好地被认为是置信度，其中类似于SVM，分数的排序是可解释的，但绝对数字（或它们的差异）在技术上不是。</p><p><strong>实际上，SVM和Softmax通常具有可比性</strong> SVM和Softmax之间的性能差异通常很小，并且，不同的人对哪种分类器更好持有不同的观点。和Softmax分类器相比，SVM更local objective，这可以被当作是bug或者特性。考虑这样一个例子：分类得分为[10,-2,3]并且第一个分类是正确的分类。SVM(eg. \(Δ=1\))认为正确分类得分和其他分类得分差距已经超过边界值，因此计算的损失值为0。SVM不关心单个得分的细节：如果得分为[10,-100,-100]或者[10,9,9]，尽管边界值1是满足的，但是SVM是无关紧要的，因此损失值是0。然而对于Softmax分类器，情况是不一样的，得分[10,9,9]相比于[10,-100,-100]会积累更多的损失值。换句话说，Softmax分类器从不完全满意它产生的分数：正确的类总是有更高的概率，不正确的类总是更低的概率，并且损失总是会变得更好。然而SVM是一旦边际得到满足就会满意，并且它不会对超出次约束的精确得分进行微观管理。这可以直观地理解为一个特性：例如，一个汽车分类器可能将大部分“努力”用于将汽车从卡车上分离出来，不应受到青蛙分类(已经被分配非常低的得分并且可能聚集在数据云的完全不同的一侧)的影响</p><h3 id="Interactive-web-demo"><a href="#Interactive-web-demo" class="headerlink" title="　Interactive web demo "></a><span id="demo">　Interactive web demo </span></h3><p>演示地址：<a href="http://vision.stanford.edu/teaching/cs231n-demos/linear-classify/" target="_blank" rel="noopener">http://vision.stanford.edu/teaching/cs231n-demos/linear-classify/</a><br><img src="http://cs231n.github.io/assets/classifydemo.jpeg" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title=" 总结 "></a><span id="summary"> 总结 </span></h3><p>总结：</p><blockquote><p>定义从图像像素到分类得分的<strong>得分函数</strong>(本节中是依赖于权重W和偏差b的线性函数)<br>  不同于kNN分类器，这种<strong>参数法</strong>的优势在于一旦我们学习到这些参数值，就可以抛弃训练数据。除此之外，对测试图片的预测会很快因为它只需要一次矩阵乘法而不是去和每个训练样本比较<br>  引入<strong>偏差技巧</strong>，允许我们将偏差向量合并到权重矩阵中<br>  定义<strong>损失函数</strong>(我们为线性分类器引入了两个通用的损失函数：<strong>SVM</strong>和<strong>Softmax</strong>)来衡量训练集中给定参数和真值标签之间的兼容性。我们还发现这种方式定义的损失函数是对训练数据做出良好的预测相当于损失很小。</p></blockquote><p>我们现在看到了一种方法来获取图像数据集，并根据一组参数将每个图像映射到类别得分，我们看到了两个可用于衡量预测质量的损失函数示例。但是，我们如何有效地确定产生最佳（最低）损失的参数？这个过程是优化，它是下一节的主题。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/linear-classify/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/linear-classify/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分类&quot;&gt;&lt;a href=&quot;#线性分类&quot; class=&quot;headerlink&quot; title=&quot;线性分类&quot;&gt;&lt;/a&gt;线性分类&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入线性分类&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#score&quot;&gt;线性得分函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#interpret&quot;&gt;解释线性分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#loss&quot;&gt;损失函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#svm&quot;&gt;　多类SVM&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#softmax&quot;&gt;　Softmax分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#svmvssoftmax&quot;&gt;　SVM与Softmax&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#demo&quot;&gt;线性分类器Web交互式演示&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="视觉识别" scheme="http://blog.archiew.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog.archiew.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="线性分类" scheme="http://blog.archiew.top/tags/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记1</title>
    <link href="http://blog.archiew.top/2018/07/05/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://blog.archiew.top/2018/07/05/CS231n用于视觉识别的卷积神经网络-学习笔记1/</id>
    <published>2018-07-05T01:24:20.000Z</published>
    <updated>2018-07-06T01:46:09.267Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/classification/" target="_blank" rel="noopener">http://cs231n.github.io/classification/</a><br>翻译：<a href="http://blog.archiew.top">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="图片分类问题-amp-数据驱动方法引入"><a href="#图片分类问题-amp-数据驱动方法引入" class="headerlink" title="图片分类问题&amp;数据驱动方法引入"></a>图片分类问题&amp;数据驱动方法引入</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入图片分类、数据驱动方法，数据流</a><br><a href="#nnc">最近邻分类器</a><br><a href="#knn">　K-最近邻分类器</a><br><a href="#val">验证集、交叉验证和超参调整</a><br><a href="#procon">最近邻优缺点</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="引入图片分类、数据驱动方法，数据流"><a href="#引入图片分类、数据驱动方法，数据流" class="headerlink" title="引入图片分类、数据驱动方法，数据流"></a><span id="intro">引入图片分类、数据驱动方法，数据流</span></h3><p><strong>图片分类问题</strong> 就是从一组固定的类别标签中为输入图像分配一个标签。看似简单问题，却包含了计算机视觉的核心问题，有很大的实际应用价值。同时，后面将要讲到的其他计算机视觉任务(eg.目标检测、分割)都可以被简化为图片的分类。<br><strong>例子</strong> 在下面的图像中，图像分类模型接收单个图像并为其分配给4个可能的分类标签{cat,dog,hat,mug}。正如图片所示，我们需要明确：在计算机看来，这幅图片只是一个3维的数据集合——本例中图片表示为248x400x3(248:宽度 400:高度 3:通道数RGB)，所以计算机实际上对这副图片的认识是297600个数字——每个数字都是一个0(黑)~255(白)的整数，图片分类任务就是将这写数据转换成一个分类标签，比如：cat。<br><img src="http://cs231n.github.io/assets/classify.png" alt="图片分类任务"></p><p><strong>挑战</strong> 对人类来说，视觉识别概念相对容易，但对于计算机来说却是一个不小的算法挑战，具体表现为：</p><blockquote><ul><li>视角变化(Viewpoint variation)</li><li>尺度变化(Scale variation)</li><li>变形(Deformation)</li><li>遮挡(Occlusion)</li><li>照明变化(Illumination conditions)</li><li>背景杂乱(Background clutter)</li><li>内在变化(Intra-class variation)</li></ul></blockquote><p><img src="http://cs231n.github.io/assets/challenges.jpeg" alt="视觉识别需要面临的挑战"></p><p>好的图片分类模型需要对这些变化的向量积不变，同时要保证对图片内在变化的敏感性。<br><strong>数据驱动方法</strong> 不像写一个数据排序算法那样明确，识别单个物体的算法并不是很明显，因此我们不会尝试直接在代码中写一个对指定物体的识别算法，而是采用人类学习方式，通过为计算机提供大量的学习数据，然后开发学习算法，从这些提供数据中学习每个分类的‘特征’。这种方法被称为‘数据驱动’，因为它依赖于积累的训练数据集标记图像。以下是这种数据集的实示例：<br><img src="http://cs231n.github.io/assets/trainset.jpg" alt="用于计算机学习的图片数据集"></p><p><strong>图片分类流</strong> 以上，我们了解了图片分类的任务过程，可以总结为如下流程：</p><blockquote><ul><li>Input输入：包含N个图片的数据集(每个图片对应k个分类标签中的一个)，我们将其称为<strong>训练集</strong></li><li>Learning学习：图片分类任务是利用上述训练集学习每类图片的‘特征’，我们将其称为<strong>训练分类器</strong>或者<strong>学习模型</strong></li><li>Evalution评估：最后我们通过预测一组新的数据集分类来评估分类器的性能，直观上我们希望预测的标签与图片真实标签(称为<strong>真值</strong>)相匹配。</li></ul></blockquote><h3 id="最近邻分类器"><a href="#最近邻分类器" class="headerlink" title="最近邻分类器"></a><span id="nnc">最近邻分类器</span></h3><p>我们将第一种分类方法成为‘最邻近分类器’(Nearest Neighbor Classifier)。这个分类器和卷积神经网络不相关，并且在实际中几乎用不到，但是它给了我们一个解决图片分类问题的基本思路。<br><strong>图片分类数据集：CIFAR-10</strong> 一个图片分类常用数据集：<a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10 dataset</a>。这个数据集包含了60,000个32x32像素的小图片，每个图片都有一个标签分类(共10个分类：airplane,automobile,bird,etc)，这60,000个图片被分为两部分：50,000个训练集和10,000个测试集。下图随机展示了数据集中的部分图片<br><img src="http://cs231n.github.io/assets/nn.jpg" alt="CIFAR-10 dataset"><br>左：CIFAR-10 dataset示例图片。右：第一列展示了一些测试图片，后边各列展示了根据像素差异显示训练集中的前10个最近邻居。<br>上图可以看出右边的预测分类仅有3/10的匹配率。<br>最简单的分类器模型就是对32x32x3数据逐像素点比较差异并求和，换句话说，给定两个图片我们用两个向量\(I_1,I_2\)表示，那么合理的差异比较选择是<strong>L1 distance</strong>$$d_1(I_1,I_2)=\sum_{p}|I_1^p-I_2^p|$$<br>下图是这个过程的可视化：<br><img src="http://cs231n.github.io/assets/nneg.jpeg" alt="L1 distance比较两个图片差异。如果结果为0说明两个图片一样，如果结果很大说明两图差异比较大"></p><p>下面会给出这一分类器的代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载数据集:training data/labels、test data/labels</span></span><br><span class="line">Xtr, Ytr, Xte, Yte = load_CIFAR10(<span class="string">'data/cifar10/'</span>)</span><br><span class="line"><span class="comment">#将三维数据平铺成一维</span></span><br><span class="line">Xtr_rows = Xtr.reshape(Xtr.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment">#Xtr_rows变为50000 x 3072</span></span><br><span class="line">Xte_rows = Xte.reshape(Xte.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment">#Xte_rows变为10000 x 3072</span></span><br><span class="line"></span><br><span class="line">nn = NearestNeighbor() <span class="comment">#创建一个最近邻分类器</span></span><br><span class="line">nn.train(Xtr_rows, Ytr) <span class="comment">#在训练集(含标签)上训练分类器</span></span><br><span class="line">Yte_predict = nn.predict(Xte_rows) <span class="comment">#在测试集上预测标签</span></span><br><span class="line"><span class="comment">#打印预测分类准确度(取平均值)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'accuracy: %f'</span> % ( np.mean(Yte_predict == Yte) )</span><br></pre></td></tr></table></figure></p><p>准确度accuracy，经常作为一个评估标准来评价预测结果正确性。上面的代码中关键的是训练函数train(X,y)和预测函数predict(X)，最重要的是分类器本身的实现，下面的代码实现了一个具有L1 distane的简单的最近邻分类器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearestNeighbor</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">    <span class="string">""" X是NxD的训练集(其中每行代表一个数据样本). y是大小为N的一维数据 """</span></span><br><span class="line">    <span class="comment"># the nearest neighbor classifier simply remembers all the training data</span></span><br><span class="line">    self.Xtr = X</span><br><span class="line">    self.ytr = y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    <span class="string">""" X是NxD的测试集(每行代表一个我们需要预测标签的样本数据) """</span></span><br><span class="line">    num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 确保输入输出数据类型匹配</span></span><br><span class="line">    Ypred = np.zeros(num_test, dtype = self.ytr.dtype)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有测试集样本数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</span><br><span class="line">      <span class="comment"># 根据L1 distance找出和第i个测试图像最近邻的训练图片</span></span><br><span class="line">      distances = np.sum(np.abs(self.Xtr - X[i,:]), axis = <span class="number">1</span>)</span><br><span class="line">      min_index = np.argmin(distances) <span class="comment"># 获取最小差异图像的索引值</span></span><br><span class="line">      Ypred[i] = self.ytr[min_index] <span class="comment"># 预测最近邻样本的标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure></p><p>上述代码实现了在CIFAR-10上38.6%的准确度，相对于人类近94%或者最先进(state-of-the-art)的卷积神经网络近95%(<a href="http://www.kaggle.com/c/cifar-10/leaderboard" target="_blank" rel="noopener">最新排行</a>)的准确度来说，这个结果可谓悲观。<br><strong>距离的选择</strong> 除上述L1 distance之外，还有许多其他计算向量之间距离的方法，另一个常用的计算方法是‘L2 distance’，计算公式如下所示：<br>$$d_2(I_1-I_2)=\sqrt{\sum_p(I_1^p-I_2^p)^2}$$<br>换句话说，L1 distance计算的是像素差，而L2 distance计算的是像素差的平方和的开方，我们用一行代码来替换上述计算距离的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distances = np.sqrt(np.square(self.Xtr-X[i,:]), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>上述代码中的<code>np.sqrt</code>在实际操作中一般被略去，因为开方函数是一个单调函数。也就是说，它仅仅改变了距离的绝对尺度但保留了距离排序，因此是无关紧要的。用这种方法计算距离得到了35.4%的预测准确度(略低于用L1 distance的结果)</p><p><strong>L1 VS L2</strong> 考虑这两者之间的差异会很有趣。实际上在涉及到两向量差异时L2 distance比L1 distance更<em>unforgiving</em>，也就是说相对于大的差异来说L2 distance更偏向于中等大小的差异。L1和L2 distance(等效于一对图片差异的L1/L2范数???)时<a href="http://planetmath.org/vectorpnorm" target="_blank" rel="noopener">p范数</a>中最常用的特殊情况。</p><h4 id="K-最近邻分类器"><a href="#K-最近邻分类器" class="headerlink" title="　K-最近邻分类器"></a><span id="knn">　K-最近邻分类器</span></h4><p>注意到上述预测只是利用了给定图片最近邻图像的标签。实际上更为常用且表现更好的方法是使用我们称之为‘k-Nearest Neighbor Classifier’(K-最近邻分类器)的分类器。其原理很简单：我们在训练集中寻找与测试图片近邻的top k个图片而不是之前的金庸一个最近邻图片来做标签预测。实际上，当k=1时就是上述最近邻分类器。直观上k值越大，分类器对于异常值平滑效果越好。<br><img src="http://cs231n.github.io/assets/knn.jpeg" alt="最近邻分类器和5-最近邻分类器的比较"></p><p>虽然k-最近邻分类器优于最近分类器，但是还有一个k值的选择问题。</p><h3 id="验证集、交叉验证和超参调整"><a href="#验证集、交叉验证和超参调整" class="headerlink" title="验证集、交叉验证和超参调整"></a><span id="knc">验证集、交叉验证和超参调整</span></h3><p>k-最近邻分类器需要设定k值，如何确定最优k值？此外，还有不同的距离计算方法，如上所示的L1范式和L2范式，甚至我们未曾考虑的点积计算等。这些多样选择我们称之为<strong>超参数</strong>，在许多机器学习算法的设计中这是很常见的。通常情况下，超参数值的确定并不明显。<br>你可能想到通过尝试多个参数值来寻找出最优值。这确实是个好想法，并且我们也确实打算这样做，但是我们必须对此持谨慎的态度！实际上，我们<strong>不能使用测试集来调整超参数</strong>。在设计机器学习算法时我们必须时刻将测试集视为一个宝贵的资源，理想情况下我们只会在最后阶段运用它。否则会出现在测试集上表现良好的超参数值在部署模型到新预测图片时性能显著下降的问题。这个问题我们称之为对测试集的<strong>overfit(过拟合)</strong>。只在最后阶段使用测试集会是衡量我们的分类器模型<strong>泛化</strong>的一个好的代理。</p><blockquote><p>测试集上的评估只能使用一次，在最后阶段</p></blockquote><p>幸运的是，有一个好方法来调整超参数而不触碰到测试集。具体做法为：将一个训练集分割为两部分，一个训练集和一个较小样本的<strong>验证集</strong>。以CIFAR-10为例，我们可以将样本数据集分为：包含49,000个图片的训练集和包含1,000个图片的验证集，验证集本质上是作为伪测试集用来调整超参数的。<br>下面给出了具体在CIFAR-10上的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们已经得到了Xtr_rows, Ytr, Xte_rows, Yte</span></span><br><span class="line"><span class="comment"># Xtr_rows：50,000 x 3072 </span></span><br><span class="line">Xval_rows = Xtr_rows[:<span class="number">1000</span>, :] <span class="comment"># 取前1000样本做验证集</span></span><br><span class="line">Yval = Ytr[:<span class="number">1000</span>]</span><br><span class="line">Xtr_rows = Xtr_rows[<span class="number">1000</span>:, :] <span class="comment"># 取后49000样本做训练集</span></span><br><span class="line">Ytr = Ytr[<span class="number">1000</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找在出验证集上的最优超参数</span></span><br><span class="line">validation_accuracies = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]:</span><br><span class="line">  <span class="comment"># 选用一系列k值并在验证集上进行评估</span></span><br><span class="line">  nn = NearestNeighbor()</span><br><span class="line">  nn.train(Xtr_rows, Ytr)</span><br><span class="line">  <span class="comment"># here we assume a modified NearestNeighbor class that can take a k as input</span></span><br><span class="line">  Yval_predict = nn.predict(Xval_rows, k = k)</span><br><span class="line">  acc = np.mean(Yval_predict == Yval)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'accuracy: %f'</span> % (acc,)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 跟踪在验证集上的表现</span></span><br><span class="line">  validation_accuracies.append((k, acc))</span><br></pre></td></tr></table></figure></p><p>最后，我们可以绘制出每次验证集上的准确度图并找出最优k值，再将此k值带入分类器并在测试集上做最终评估。</p><blockquote><p>将你的训练集分割成训练集和验证集，使用验证集调整超参数，最后在测试集上做一次评估并输出分类器性能</p></blockquote><p><strong>交叉验证</strong> 如果训练集规模很小，更多的是用一种复杂的技术来调整超参数，我们称之为<strong>cross-validation(交叉验证)</strong>。还以先前例子为例，这次我们不是随意地将训练集的前1000个样本作验证集剩下的做训练集，我们可以通过迭代不同的验证集并平衡其性能以获得一种更好且噪声更小的估计k的特定值。例如，在5-折交叉验证中，我们将训练集分割成5等份，用其中的4个作为训练集剩1个做验证集，得到一个评估性能，然后迭代地分别取不同的小份做验证集，这样可以得到5个评估性能值(准确度)，最后取平均值。<br><img src="http://cs231n.github.io/assets/cvplot.png" alt="5-折交叉验证的例子，每个待选k值对应5个准确度指标，取它们的平均值绘图并找出最大值，最大值对应的k值即是我们要寻找的最优超参数k"></p><p><strong>实践</strong> 实际操作时人们会更倾向于避免交叉验证而使用单一验证，因为交叉验证会消耗大量的计算资源。人们一般会使用训练集的50%-90%作为训练剩下的做验证，而这取决于多个因素：如果超参数数量很多，你可能更倾向于分割出更大的验证集；而如果验证集中的样本数量很少(几百个)，最好是用交叉验证。常用的折数一般为3-折，5-折，10-折。<br><img src="http://cs231n.github.io/assets/crossval.jpeg" alt="常用的数据分割"></p><h3 id="最近邻优缺点"><a href="#最近邻优缺点" class="headerlink" title="最近邻优缺点"></a><span id="procon">最近邻优缺点</span></h3><p>考量最邻近分类器的优缺点是有必要的。很明显，一个优势是它很简单且易于理解，除此之外分类器无需花费时间去训练，但是我们的时间花费在了预测上，因为预测需要比较测试图片和每一个训练样本的差异。这是backwards(倒退的)，因为实际上我们更关注的是预测时的时间效率。实际上随后讲到的深度神经网络将这个权衡移到了另一个极端：在训练时花费大量资源(运算、时间)，而在训练结束它会非常快地对测试图片进行分类预测。这种操作模式在实际运用中更可取。<br>另外，对于最近邻分类器的计算复杂度是另一个活跃的研究点，并且有一些<strong>近似最近邻(ANN)</strong>算法和库可以加速数据集中最近邻的查找(eg. <a href="http://www.cs.ubc.ca/research/flann/" target="_blank" rel="noopener">FLANN</a>)。这些算法允许人们在查找期间利用空间/时间复杂度来权衡最近邻查找的正确性，并且通常依赖于涉及构建kdtree或运行k均值算法的预处理/索引阶段。<br>最近邻分类器在某些情况下会是一个很好的选择(尤其是低维度数据)，但是在实际运用中很少去用作分类设置，其中一个问题是图片是高维物体(包含了大量像素数据)，而且高维空间的距离可能非常违反直观感觉。下图说明了我们上面开发的基于像素的L2相似度与感知相似度非常不同的点：<br><img src="http://cs231n.github.io/assets/samenorm.png" alt=""></p><p><em>在高维数据(尤其是图片)上基于像素的距离可能非常不直观。原图(左)和其他三幅图片在L2像素距离上有很大差异。很明显，像素距离和感知或语义相似并不一致。</em><br>下面给出了更多可视化图片方便理解使用图片见的像素差异并不能很好地胜任分类问题。运用可视化技术(<a href="http://homepage.tudelft.nl/19j49/t-SNE.html" target="_blank" rel="noopener">t-SNE</a>)将CIFAR-10中的图片展示在二维面上，一边保留他们的(局部)成对距离。在可视化过程中距离最近的图片被认为是最相近的(根据上述L2像素距离来讲)。<br><img src="http://cs231n.github.io/assets/pixels_embed_cifar10_big.jpg" alt=""></p><p>实际上，上述图片相近的图片更多的是在背景色彩上具有相似性而不是语义上的相似性。理想情况下我们希望所有图片会形成10个聚类，因此相同类的图像彼此相邻近而忽视无关特征和变化(如背景)。但是要获得这种属性，我们必须超越原始像素。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="summary">总结</span></h3><blockquote><ul><li>引入图片分类问题。给定一个带有单个分类标签的图片集，需要预测新的测试集中图片的分类并计算预测准确度。</li><li>引入了简单分类器<strong>最近邻分类器(Nearest Neighbor classifier)</strong>。认识到与分类器相关的多个超参数(k,distance计算类型等)，并且它们的选择并不明显</li><li>认识到设置超参数的正确方法是分割训练集为两部分：训练集和伪测试集(<strong>验证集</strong>)，尝试多个不同的超参数值并且选出在验证集上表现最好的那个值</li><li>如果缺少训练集，我们讨论了一个<strong>交叉验证(cross-validation)</strong>，这会帮助我们减少估计最优超参数值的噪声</li><li>一旦寻找到最优超参数值，我们将其固定下来并在真实测试集上做单次评估</li><li>认识到最近邻分类器在CIFAR-10上可以获得约40%的准确度，实现起来会很简单但是需要存储所有训练集并且在测试集上评估会很耗时</li><li>最后，我们认识到在原始像素上计算L1和L2距离并不能胜任分类工作，因为这种距离更多地和图片背景、色彩分布相关而不是图片的语义内容。</li></ul></blockquote><p>下一讲，着手处理本节中的挑战并且最终达到90%的准确度，让我们在完成学习之后完全抛弃训练集们，并且实现在1ms之内预测图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/classification/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/classification/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片分类问题-amp-数据驱动方法引入&quot;&gt;&lt;a href=&quot;#图片分类问题-amp-数据驱动方法引入&quot; class=&quot;headerlink&quot; title=&quot;图片分类问题&amp;amp;数据驱动方法引入&quot;&gt;&lt;/a&gt;图片分类问题&amp;amp;数据驱动方法引入&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入图片分类、数据驱动方法，数据流&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#nnc&quot;&gt;最近邻分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#knn&quot;&gt;　K-最近邻分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#val&quot;&gt;验证集、交叉验证和超参调整&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#procon&quot;&gt;最近邻优缺点&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="视觉识别" scheme="http://blog.archiew.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog.archiew.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="图像分类" scheme="http://blog.archiew.top/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式C语言面试题</title>
    <link href="http://blog.archiew.top/2018/07/04/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.archiew.top/2018/07/04/嵌入式C语言面试题/</id>
    <published>2018-07-04T12:44:30.000Z</published>
    <updated>2018-07-05T11:22:08.984Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些嵌入式软件开发中C语言面试问题</p><a id="more"></a><hr><h3 id="1、预处理指令-define"><a href="#1、预处理指令-define" class="headerlink" title="1、预处理指令#define"></a>1、预处理指令#define</h3><p>有几点需要注意：首先是语法(无分号结束,字母大写,括号使用…)；其次明白预处理器会将表达式计算出来代入需要用的地方，所以尽量用表达式来清晰定义其作用而不是直接给出一常量值；还有就是要注意常量值可能的溢出问题(用UL后缀解决)<br>给出几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//用#define声明一个常数来表示一年中有多少秒（忽略闰年）</span><br><span class="line">#define SEC_PER_YEAR(60*60*24*365)UL</span><br><span class="line"></span><br><span class="line">//用#define声明一个返回两个参数较小值的宏</span><br><span class="line">#define MIN(X,Y)(A)&gt;=(B)?(B):(A)</span><br><span class="line"></span><br><span class="line">//考虑</span><br><span class="line">#define PTR int *</span><br><span class="line">PTR a, b;//等价于int *a, b;</span><br><span class="line">int *a, *b;</span><br></pre></td></tr></table></figure></p><h3 id="2、关键字static的作用"><a href="#2、关键字static的作用" class="headerlink" title="2、关键字static的作用"></a>2、关键字static的作用</h3><p>C语言中static主要有三个作用：<br>函数体内，被static修饰的变量在函数内保持值不变；<br>模块内(函数外)，被static修饰的变量成为一个本地全局变量，在模块内可被调用，模块外不可；<br>模块内，被static修饰的函数可被模块内函数调用。</p><h3 id="3、关键字const的作用"><a href="#3、关键字const的作用" class="headerlink" title="3、关键字const的作用"></a>3、关键字const的作用</h3><p>const一般用来修饰那些‘只读’的变量，防止变量被修改<br>const int a;   //常整数<br>int const a;   //同上<br>int <em>const a;  //指向整数的常指针<br>const int </em>a;  //指向常整数的指针<br>int const *a cons;  //指向常整数的常指针</p><h3 id="4、关键字volatile的作用"><a href="#4、关键字volatile的作用" class="headerlink" title="4、关键字volatile的作用"></a>4、关键字volatile的作用</h3><p>volatile用来修饰可能会被意想不到改变的变量，编译器会忽略对被volatile修饰的变量进行优化，每次取变量值都会去地址处取。（编译器优化的变量值会被‘缓存’到寄存器，这样不用每次都去变量地址处取值）<br>volatile典型应用在三个地方：<br>中断服务程序中<br>硬件寄存器<br>多线程应用中<br>eg. #define REG_N    <em>(volatile unsigned int </em>)0x80000000</p><h3 id="5、中断服务函数ISR"><a href="#5、中断服务函数ISR" class="headerlink" title="5、中断服务函数ISR"></a>5、中断服务函数ISR</h3><p>有几点需要注意：<br>没有返回值<br>尽量避免浮点运算<br>尽量避免IO操作</p><h3 id="6、强制类型转换"><a href="#6、强制类型转换" class="headerlink" title="6、强制类型转换"></a>6、强制类型转换</h3><ul><li>无符号数operate有符号数=无符号数<br>eg. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(void)&#123;</span><br><span class="line">unsigned int a=6;</span><br><span class="line">int b=-20;</span><br><span class="line">(a+b&gt;6)?puts(&quot;&gt;6&quot;):puts(&quot;&lt;=6&quot;)//a+b会强制转换为无符号数：-20转换为无符号数应该是一个很大的值，so...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些嵌入式软件开发中C语言面试问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习目标检测模型概述</title>
    <link href="http://blog.archiew.top/2018/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.archiew.top/2018/06/26/深度学习目标检测模型概述/</id>
    <published>2018-06-26T01:04:46.000Z</published>
    <updated>2018-06-26T02:04:26.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、R-CNN"><a href="#1、R-CNN" class="headerlink" title="1、R-CNN"></a>1、R-CNN</h2><p>R-CNN(Region-based Convolutional Neural Network)分三个步骤：</p><ul><li>利用’选择性搜索(Selective Search)’算法生成约2k个region proposal，以获取可能出现的目标；</li><li>对每个region proposal运行CNN；</li><li>上述得到的CNN进行如下操作：<br>  a.输入到支持向量机(SVM),以对上述区域进行分类<br>  b.输入到一个线性回归器，以收缩目标周围边界框(假如目标存在)<br>R-CNN模型图如下所示：<br><a href="">R-CNN</a></li></ul><h2 id="2、Fast-R-CNN"><a href="#2、Fast-R-CNN" class="headerlink" title="2、Fast R-CNN"></a>2、Fast R-CNN</h2><p>Fast R-CNN相较于R-CNN主要是在检测速度方面进行了提升，而提升手段如下：</p><ul><li>在推荐区域之前，先对图像进行特征提取，这样做的好处是使整个图像只使用一个CNN(之前需要对2k个推荐区域分别运行CNN)</li><li>将R-CNN中的SVM替换为softmax，softmax直接输出类概率，而使用SVM需要训练多个SVM对每个目标类进行分类<br>相较R-CNN而言Fast R-CNN在速度上提升了许多，然而Fast R-CNN仍存在未解决的瓶颈问题：用于生成region proposal的选择搜索算法。</li></ul><h2 id="3、Faster-R-CNN"><a href="#3、Faster-R-CNN" class="headerlink" title="3、Faster R-CNN"></a>3、Faster R-CNN</h2><p>Faster R-CNN在Fast R-CNN的基础上通过引入region proposal网络(RPN)来代替选择搜索算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、R-CNN&quot;&gt;&lt;a href=&quot;#1、R-CNN&quot; class=&quot;headerlink&quot; title=&quot;1、R-CNN&quot;&gt;&lt;/a&gt;1、R-CNN&lt;/h2&gt;&lt;p&gt;R-CNN(Region-based Convolutional Neural Network)分三
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://blog.archiew.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://blog.archiew.top/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="R-CNN" scheme="http://blog.archiew.top/tags/R-CNN/"/>
    
      <category term="Fast R-CNN" scheme="http://blog.archiew.top/tags/Fast-R-CNN/"/>
    
      <category term="Faster R-CNN" scheme="http://blog.archiew.top/tags/Faster-R-CNN/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 cuda-9.2安装</title>
    <link href="http://blog.archiew.top/2018/06/19/Ubuntu16-04-4-cuda-9-2%E5%AE%89%E8%A3%85/"/>
    <id>http://blog.archiew.top/2018/06/19/Ubuntu16-04-4-cuda-9-2安装/</id>
    <published>2018-06-19T13:08:41.000Z</published>
    <updated>2018-07-05T11:22:50.523Z</updated>
    
    <content type="html"><![CDATA[<p>系统：win7 64位<br>显卡：NVIDIA GT740</p><h2 id="1-Ubuntu16-04-4双系统安装"><a href="#1-Ubuntu16-04-4双系统安装" class="headerlink" title="1 Ubuntu16.04.4双系统安装"></a>1 Ubuntu16.04.4双系统安装</h2><blockquote><p>工具：<br>   EasyBCD 2.3<br>   <a href="http://cdimage.ubuntu.com/netboot/16.04/?_ga=2.212435411.69853237.1529413894-897926102.1529413894" target="_blank" rel="noopener">ubuntu-16.04.4-desktop-amd64.iso</a></p></blockquote><a id="more"></a><hr><h3 id="1-1-准备磁盘空间"><a href="#1-1-准备磁盘空间" class="headerlink" title="1.1 准备磁盘空间"></a>1.1 准备磁盘空间</h3><p>在win7下<code>win+R</code>运行diskmgmt.msc打开磁盘管理，选择一个可用空间较大的磁盘右键压缩磁盘，得到一个空的分区（100G左右）</p><h3 id="1-2-配置引导"><a href="#1-2-配置引导" class="headerlink" title="1.2 配置引导"></a>1.2 配置引导</h3><p>将ubuntu-16.04.2-desktop-amd64.iso中的initrd.lz、vmlinuz.efi 解压出来与iso一同放在C盘或D盘根目录（必须根目录）下。打开EasyBCD，添加新条目-&gt;NeoGrub-&gt;安装-&gt;配置，配置文件内容如下：<br>注意：上面的文件放在C盘根目录则为 hd0,0 ，D盘则为hd0,4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># NeoSmart NeoGrub Bootloader Configuration File  </span><br><span class="line">#  </span><br><span class="line"># This is the NeoGrub configuration file, and should be located at C:\NST\menu.lst  </span><br><span class="line"># Please see the EasyBCD Documentation for information on how to create/modify entries:  </span><br><span class="line"># http://neosmart.net/wiki/display/EBCD/  </span><br><span class="line">  </span><br><span class="line">title Install Ubuntu   </span><br><span class="line">root (hd0,4)   </span><br><span class="line">kernel (hd0,4)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8   </span><br><span class="line">initrd (hd0,4)/initrd.lz</span><br></pre></td></tr></table></figure></p><p>然后，在EasyBCD中编辑引导菜单，可以看到NeoGrub引导加载器，勾选等待用户选择，保存。</p><h3 id="1-3-进入引导"><a href="#1-3-进入引导" class="headerlink" title="1.3 进入引导"></a>1.3 进入引导</h3><p>配置完后重启，选择NeoGrub引导加载器，上述配置无误即可进入Ubuntu界面</p><h3 id="1-4-开始安装"><a href="#1-4-开始安装" class="headerlink" title="1.4 开始安装"></a>1.4 开始安装</h3><p>在Ubuntu界面使用<code>ctrl+alt+T</code>打开终端，输入命令<code>sudo umount -l /isodevice</code>卸载分区，然后点击桌面的安装程序进行安装，依次进行如下设置：</p><blockquote><p>系统语言设为English(可选)<br>   勾选‘安装Ubuntu时下载更新’<br>   安装类型选择‘其他选项’<br>   系统分区：<br>      交换空间swap：逻辑分区、空间起始位置 16384MB(一般设为机器内存大小左右)<br>      /              ：逻辑分区、空间起始位置、用于Ext4 30720MB(存放安装程序)<br>      /home          : 逻辑分区、空间起始位置、用于Ext4 剩下空闲空间扣除250MB<br>      /boot          ：主分区、空间起始位置、用于Ext4 250MB<br>      注意最下面‘安装启动引导器的设备’选择刚才分配的/boot所在分区<br>   默认设置…</p></blockquote><h3 id="1-5-添加启动项"><a href="#1-5-添加启动项" class="headerlink" title="1.5 添加启动项"></a>1.5 添加启动项</h3><p>上述安装完成重启进入win7，打开EasyBCD，添加Ubuntu启动项，删除NeoGrub引导项<br>添加新条目-&gt;Linux/BSD-&gt;类型选’GRUB2’-&gt;驱动器选’Linux-2xx MiB’-&gt;添加条目<br>切换到编辑引导菜单，删除NeoGrub引导项。   </p><h2 id="2-cuda-9-2安装"><a href="#2-cuda-9-2安装" class="headerlink" title="2 cuda-9.2安装"></a>2 cuda-9.2安装</h2><p>ubuntu 16.04默认安装了第三方开源的驱动程序nouveau，安装nvidia显卡驱动首先需要禁用nouveau，不然会碰到冲突的问题，导致无法安装nvidia显卡驱动。<br>编辑文件blacklist.conf<br>`sudo vim /etc/modprobe.d/blacklist.conf’<br>在文件最后部分插入以下两行内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure></p><p>更新系统<code>sudo update-initramfs -u</code><br>重启，验证nouveau是否禁用<br><code>lsmod | grep nouveau</code><br>没有信息显示说明nouveau已禁用<br>按<code>ctrl+alt+f1</code>进入tty1<br><code>sudo service lightdm stop</code>关闭X server<br><code>sudo ./cuda_xxx.run</code> 运行事先下载好的cuda安装包<br>全都按默认配置<br><code>sudo service lightdm start</code><br>设置环境变量文件.bashrc或profile<br><code>export PATH=/usr/local/cuda-9.2/bin:$PATH</code><br><code>export LD_LIBRARY_PATH=/usr/local/cuda-9.2/lib64:#LD_LIBRARY_PATH</code><br>更新环境变量<br><code>souce /etc/profile</code><br>安装完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统：win7 64位&lt;br&gt;显卡：NVIDIA GT740&lt;/p&gt;
&lt;h2 id=&quot;1-Ubuntu16-04-4双系统安装&quot;&gt;&lt;a href=&quot;#1-Ubuntu16-04-4双系统安装&quot; class=&quot;headerlink&quot; title=&quot;1 Ubuntu16.04.4双系统安装&quot;&gt;&lt;/a&gt;1 Ubuntu16.04.4双系统安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;工具：&lt;br&gt;   EasyBCD 2.3&lt;br&gt;   &lt;a href=&quot;http://cdimage.ubuntu.com/netboot/16.04/?_ga=2.212435411.69853237.1529413894-897926102.1529413894&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ubuntu-16.04.4-desktop-amd64.iso&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://blog.archiew.top/tags/Ubuntu/"/>
    
      <category term="cuda" scheme="http://blog.archiew.top/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式基础知识汇总</title>
    <link href="http://blog.archiew.top/2018/06/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.archiew.top/2018/06/19/嵌入式基础知识汇总/</id>
    <published>2018-06-19T01:04:51.000Z</published>
    <updated>2018-07-05T11:22:43.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-各数据类型所占字节大小"><a href="#1-各数据类型所占字节大小" class="headerlink" title="1.各数据类型所占字节大小"></a>1.各数据类型所占字节大小</h3><p><em>对于不同的处理器，所占空间大小取决于编译器的类型</em></p><a id="more"></a><hr><blockquote><p>16位编译器<br>char      : 1Byte<br>char*      : 2Byte        //也即指针变量<br>short int : 2Byte<br>int          : 2Byte<br>float      : 4Byte<br>double      : 8Byte<br>long      : 4Byte<br>long long : 8Byte</p></blockquote><blockquote><p>32位编译器<br>char       : 1Byte<br>char*      : 4Byte<br>int       : 4Byte<br>short int : 2Byte<br>float       : 4Byte<br>double      : 8Byte<br>long       : 4Byte<br>long long : 8Byte</p></blockquote><blockquote><p>64位编译器<br>char       : 1Byte<br>char*      : 8Byte<br>int          : 4Byte<br>short int : 2Byte<br>float      : 4Byte<br>double       : 8Byte<br>long       : 8Byte<br>long long : 8Byte</p></blockquote><h3 id="2-机器大小端问题"><a href="#2-机器大小端问题" class="headerlink" title="2.机器大小端问题"></a>2.机器大小端问题</h3><p>关于大小端：</p><blockquote><p>大端存储：高字节存低地址，即高位先存;(合乎阅读习惯)<br>   小端存储：低字节存低地址，即低位先存。</p></blockquote><p>例如：变量0x11223344,大小端存储如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址大端小端</span><br><span class="line">0x6ff7101144</span><br><span class="line">0x6ff7112233</span><br><span class="line">0x6ff7123322</span><br><span class="line">0x6ff7134411</span><br></pre></td></tr></table></figure></p><p>判断机器大小端方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">// 利用指针</span><br><span class="line">void test()&#123;</span><br><span class="line">int a=0x11223344;</span><br><span class="line">char *p=(char*)&amp;a;//取变量a的低地址</span><br><span class="line"></span><br><span class="line">if(0x11==*p)</span><br><span class="line">printf(&quot;大端\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;小端\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">// 利用联合体</span><br><span class="line">void test()&#123;</span><br><span class="line">union t&#123;</span><br><span class="line">int i;</span><br><span class="line">char c;</span><br><span class="line">&#125;t1;</span><br><span class="line"></span><br><span class="line">t1.i=1;</span><br><span class="line">if(1==t1.c)</span><br><span class="line">printf(&quot;小端\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;大端\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3.结构体"></a>3.结构体</h3><p>描述下面宏XXX的作用</p><blockquote><p>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</p></blockquote><p>   #define XXX(ptr, type, member) ({ \<br>   const typeof( ((type <em>)0)-&gt;member ) </em><strong>mptr = (ptr); \<br>   (type <em>)( (char </em>)</strong>mptr - offsetof(type,member) );})</p><p>假设存在结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct s&#123;</span><br><span class="line">type1 A;</span><br><span class="line">type2 B;</span><br><span class="line">type3 C;</span><br><span class="line">&#125;s1;</span><br></pre></td></tr></table></figure></p><p>变量类型用typex代替是避免考虑内存中字节对齐的问题，现在s1在内存中的分布应该是这样的(假设的数据长度)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址变量</span><br><span class="line">0x80000A</span><br><span class="line">0x80004 B</span><br><span class="line">0x8000a C</span><br></pre></td></tr></table></figure></p><p>上面的宏运算涉及到的三个参数分别为：<br>ptr: 指向结构体成员的指针，比如type2<em> p=&amp;B<br>type: 结构体类型，比如struct s<br>member: 结构体成员名字，比如B<br>那么先看宏offsetof，((TYPE </em>)0)先将零类型转换为TYPE类型指针，((TYPE <em>)0)-&gt;MEMBER将访问TYPE结构体中的数据成员MEMBER，然后&amp;((TYPE </em>)0)-&gt;MEMBER取数据成员的地址，其实时取到了MEMBER成员相对于其所在结构体的偏移，最后(size_t)&amp;((TYPE <em>)0)-&gt;MEMBER实现结果类型转换<br>再看宏XXX，const typeof(((type </em>)0)-&gt;member)<em> <strong>mptr=(ptr);将结构体成员指针赋值指针变量</strong>mprt，(type</em>)((char*)__mptr-offsetof(type,member));是用结构体数据成员的指针减去该成员在结构体中的偏移量，得到结构体的基指针，最后强制转换成结构体指针类型<br>综上所述，该宏定义实现了根据结构体某成员变量获取该结构体基地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-各数据类型所占字节大小&quot;&gt;&lt;a href=&quot;#1-各数据类型所占字节大小&quot; class=&quot;headerlink&quot; title=&quot;1.各数据类型所占字节大小&quot;&gt;&lt;/a&gt;1.各数据类型所占字节大小&lt;/h3&gt;&lt;p&gt;&lt;em&gt;对于不同的处理器，所占空间大小取决于编译器的类型&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 安装OpenCV3.2.0</title>
    <link href="http://blog.archiew.top/2018/06/15/Ubuntu16-04-4-%E5%AE%89%E8%A3%85OpenCV3-2/"/>
    <id>http://blog.archiew.top/2018/06/15/Ubuntu16-04-4-安装OpenCV3-2/</id>
    <published>2018-06-15T08:27:52.000Z</published>
    <updated>2018-07-05T11:22:35.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h2><ul><li>GCC ≥4.4.x</li><li>CMake ≥2.8.7</li><li>Cit</li><li>GTK ≥2.x,including headers (libgtk2.0-dev)</li><li>pkg-config</li><li>Python ≥2.6,Numpy ≥1.5,with developer packages(python-dev,python-numpy)</li><li>ffmpeg or libav development packages: libavcodec-dev, libavformat-dev, libswscale-dev</li><li>[可选] libtbb2 libtbb-dev</li><li>[可选] libdc1394 2.x</li><li>[可选] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev, libdc1394-22-dev</li><li>[可选] CUDA Toolkit ≥6.5 </li></ul><a id="more"></a><hr><p>通过以下命令来安装上述依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure></p><h2 id="下载OpenCV源码"><a href="#下载OpenCV源码" class="headerlink" title="下载OpenCV源码"></a>下载OpenCV源码</h2><p>1.<a href="http://opencv.org/releases.html" target="_blank" rel="noopener">下载页</a>下载最新稳定版<br>2.从Git Repository获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv.git</span><br><span class="line">git clone https://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure></p><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>1.创建临时文件夹，用于存放Makefiles等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/opencv</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure></p><p>2.配置并编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake [&lt;some optional parameters&gt;] &lt;path to the OpenCV source directory&gt;</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -D CMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">    -D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">    -D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">    -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.2.0/modules \</span><br><span class="line">    -D PYTHON_EXCUTABLE=/usr/bin/python \</span><br><span class="line">    -D WITH_CUDA=ON \    # 使用CUDA</span><br><span class="line">    -D WITH_CUBLAS=ON \</span><br><span class="line">    -D DCUDA_NVCC_FLAGS=&quot;-D_FORCE_INLINES&quot; \</span><br><span class="line">    -D CUDA_ARCH_BIN=&quot;9.2&quot; \    # 使用的CUDA所对应的版本</span><br><span class="line">    -D CUDA_ARCH_PTX=&quot;&quot; \</span><br><span class="line">    -D CUDA_FAST_MATH=ON \    # 计算速度更快但是相对不精确</span><br><span class="line">    -D WITH_TBB=ON \</span><br><span class="line">    -D WITH_V4L=ON \</span><br><span class="line">    -D WITH_QT=ON \    # 如果qt未安装可以删去此行;若因为未正确安装qt导致的Qt5Gui报错，可将build内文件全部删除后重新cmake，具体可以参考[这里](http://stackoverflow.com/questions/17420739/opencv-2-4-5-and-qt5-error-s)</span><br><span class="line">    -D WITH_GTK=ON \</span><br><span class="line">    -D WITH_OPENGL=ON \</span><br><span class="line">    -D BUILD_EXAMPLES=ON ~/opencv</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;依赖包&quot;&gt;&lt;a href=&quot;#依赖包&quot; class=&quot;headerlink&quot; title=&quot;依赖包&quot;&gt;&lt;/a&gt;依赖包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GCC ≥4.4.x&lt;/li&gt;
&lt;li&gt;CMake ≥2.8.7&lt;/li&gt;
&lt;li&gt;Cit&lt;/li&gt;
&lt;li&gt;GTK ≥2.x,including headers (libgtk2.0-dev)&lt;/li&gt;
&lt;li&gt;pkg-config&lt;/li&gt;
&lt;li&gt;Python ≥2.6,Numpy ≥1.5,with developer packages(python-dev,python-numpy)&lt;/li&gt;
&lt;li&gt;ffmpeg or libav development packages: libavcodec-dev, libavformat-dev, libswscale-dev&lt;/li&gt;
&lt;li&gt;[可选] libtbb2 libtbb-dev&lt;/li&gt;
&lt;li&gt;[可选] libdc1394 2.x&lt;/li&gt;
&lt;li&gt;[可选] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev, libdc1394-22-dev&lt;/li&gt;
&lt;li&gt;[可选] CUDA Toolkit ≥6.5 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="-Ubuntu -OpenCV" scheme="http://blog.archiew.top/tags/Ubuntu-OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>习题</title>
    <link href="http://blog.archiew.top/2018/05/26/%E4%B9%A0%E9%A2%98/"/>
    <id>http://blog.archiew.top/2018/05/26/习题/</id>
    <published>2018-05-26T12:55:12.000Z</published>
    <updated>2018-07-05T11:23:14.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-c"><a href="#c-c" class="headerlink" title="c/c++"></a>c/c++</h2><ol><li>找到单向链表中间的元素，如果有两个则取前面那个。<br>分析：类似于”烧绳子”问题：有一节粗细均匀的绳子，完全烧完需要10min，请设法用烧绳子的方法来计时7.5min。关键在于”速度”的控制。<br>本题也可借用该思想：设置快、慢指针，从头节点开始，快指针一次移动2个节点，慢指针按正常方式一次移动1个节点，大体上当快指针移动到链表尽头时，慢指针恰好位于链表中间节点。<br>为什么要用”大体上”，因为需要考虑几个特殊情况：<blockquote><p>链表长度小于3，此时快指针移动2个节点出问题<br>链表长度为奇数，快指针恰好能够移动到尾节点，此时慢节点就是中间节点<br>链表长度为偶数，快节点无法移动到尾节点(只能移动到尾节点前一节点)，此时慢节点位于链表中间节点之一，且为前面那个</p></blockquote></li></ol><p>类似地，还可以倒序找出任何位置节点，比如要找倒数第k个节点，此时只需要让快节点在一开始领先于慢节点k个节点即可，只不过这种情况下，快慢指针移动速度是一样的：都是每次移动1个字节。同样地，也需要单独考虑几种特殊情况，例如链表长度小于k。</p><a id="more"></a><hr><p>2.统计一个无符号整形数二进制形式中’1’的个数。<br>分析：最先想到的一种方法就是移位+计数，这种情况下最多需要循环次数取决于整形数的bit数。<br>一种较快的方法是依次移除该数二进制形式最右边的1(x&amp;=(x-1))，并计数，这种情况下，循环次数取决于’1’的个数。</p><p>3.What will be the output of the following C code?<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line">*(p++) += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>, *p, *(p++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：本题唯一需要注意的是C中的printf参数是<strong>从右到左压栈</strong>的。</p><p>4.关于编程中内存的常识</p><blockquote><p>栈(stack):存放局部变量、函数参数等，由编译器自动分配与释放<br>  堆(heap) :一般由程序员分配与释放，在c中用malloc申请，在c++中用new申请<br>  全局(静态区)(static):存放全局变量、静态变量。初始化的全局变量和静态变量在一块，未初始化的全局变量和静态变量在另一块，程序结束由系统释放<br>  常量区:存放常量，程序结束由系统释放<br>  代码区:存放代码</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;c-c&quot;&gt;&lt;a href=&quot;#c-c&quot; class=&quot;headerlink&quot; title=&quot;c/c++&quot;&gt;&lt;/a&gt;c/c++&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;找到单向链表中间的元素，如果有两个则取前面那个。&lt;br&gt;分析：类似于”烧绳子”问题：有一节粗细均匀的绳子，完全烧完需要10min，请设法用烧绳子的方法来计时7.5min。关键在于”速度”的控制。&lt;br&gt;本题也可借用该思想：设置快、慢指针，从头节点开始，快指针一次移动2个节点，慢指针按正常方式一次移动1个节点，大体上当快指针移动到链表尽头时，慢指针恰好位于链表中间节点。&lt;br&gt;为什么要用”大体上”，因为需要考虑几个特殊情况：&lt;blockquote&gt;
&lt;p&gt;链表长度小于3，此时快指针移动2个节点出问题&lt;br&gt;链表长度为奇数，快指针恰好能够移动到尾节点，此时慢节点就是中间节点&lt;br&gt;链表长度为偶数，快节点无法移动到尾节点(只能移动到尾节点前一节点)，此时慢节点位于链表中间节点之一，且为前面那个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似地，还可以倒序找出任何位置节点，比如要找倒数第k个节点，此时只需要让快节点在一开始领先于慢节点k个节点即可，只不过这种情况下，快慢指针移动速度是一样的：都是每次移动1个字节。同样地，也需要单独考虑几种特殊情况，例如链表长度小于k。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>搞定Python多线程和多进程</title>
    <link href="http://blog.archiew.top/2018/05/22/%E6%90%9E%E5%AE%9APython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.archiew.top/2018/05/22/搞定Python多线程和多进程/</id>
    <published>2018-05-22T12:11:13.000Z</published>
    <updated>2018-07-05T11:23:23.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、概念梳理"><a href="#1、概念梳理" class="headerlink" title="1、概念梳理"></a>1、概念梳理</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><h4 id="1-1-1-什么是线程"><a href="#1-1-1-什么是线程" class="headerlink" title="1.1.1 什么是线程"></a>1.1.1 什么是线程</h4><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程是一个execution context（执行上下文），即一个cpu执行时所需要的一串指令。</p><h4 id="1-1-2-线程的工作方式"><a href="#1-1-2-线程的工作方式" class="headerlink" title="1.1.2 线程的工作方式"></a>1.1.2 线程的工作方式</h4><p>假设你正在读一本书，没有读完，你想休息一下，但是你想在回来时恢复到当时读的具体进度。有一个方法就是记下页数、行数与字数这三个数值，这些数值就是execution context。如果你的室友在你休息的时候，使用相同的方法读这本书。你和她只需要这三个数字记下来就可以在交替的时间共同阅读这本书了。<br>线程的工作方式与此类似。CPU会给你一个在同一时间能够做多个运算的幻觉，实际上它在每个运算上只花了极少的时间，本质上CPU同一时刻只干了一件事。它能这样做就是因为它有每个运算的execution context。就像你能够和你朋友共享同一本书一样，多任务也能共享同一块CPU。</p><a id="more"></a><hr><h3 id="1-2-进程"><a href="#1-2-进程" class="headerlink" title="1.2 进程"></a>1.2 进程</h3><p>一个程序的执行实例就是一个进程。每一个进程提供执行程序所需的所有资源。（进程本质上是资源的集合）<br>一个进程有一个虚拟的地址空间、可执行的代码、操作系统的接口、安全的上下文（记录启动该进程的用户和权限等等）、唯一的进程ID、环境变量、优先级类、最小和最大的工作空间（内存空间），还要有至少一个线程。<br>每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。<br>与进程相关的资源包括:</p><blockquote><p>内存页（同一个进程中的所有线程共享同一个内存空间）<br>  文件描述符(e.g. open sockets)<br>  安全凭证（e.g.启动该进程的用户ID）</p></blockquote><h3 id="1-3-进程和线程的区别"><a href="#1-3-进程和线程的区别" class="headerlink" title="1.3 进程和线程的区别"></a>1.3 进程和线程的区别</h3><p>1.同一个进程中的线程共享同一内存空间，但是进程之间是独立的。<br>2.同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。<br>3.对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。<br>4.线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源。<br>5.同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。<br>6.创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。<br>7.一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。<br>8.线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。</p><h2 id="2、多线程"><a href="#2、多线程" class="headerlink" title="2、多线程"></a>2、多线程</h2><h3 id="2-1-线程常用方法"><a href="#2-1-线程常用方法" class="headerlink" title="2.1 线程常用方法"></a>2.1 线程常用方法</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">注释</th></tr></thead><tbody><tr><td style="text-align:center">start()</td><td style="text-align:center">线程准备就绪，等待CPU调度</td></tr><tr><td style="text-align:center">setName()</td><td style="text-align:center">为线程设置名称</td></tr><tr><td style="text-align:center">getName()</td><td style="text-align:center">获取线程名称</td></tr><tr><td style="text-align:center">setDaemon(True)</td><td style="text-align:center">设置为守护线程</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:center">逐个执行每个线程，执行完毕后继续往下执行</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:center">线程被cpu调度后自动执行线程对象的run()方法，如果想自定义线程类，直接重写run()方法</td></tr></tbody></table><h4 id="2-1-1-Thread类"><a href="#2-1-1-Thread类" class="headerlink" title="2.1.1 Thread类"></a>2.1.1 Thread类</h4><p>1、普通创建方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'0s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run, args=(<span class="string">"t1"</span>,))</span><br><span class="line">t2 = threading.Thread(target=run, args=(<span class="string">"t2"</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t1</span></span><br><span class="line"><span class="string">task t2</span></span><br><span class="line"><span class="string">2s</span></span><br><span class="line"><span class="string">2s</span></span><br><span class="line"><span class="string">1s</span></span><br><span class="line"><span class="string">1s</span></span><br><span class="line"><span class="string">0s</span></span><br><span class="line"><span class="string">0s</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p>2、继承threading.Thread来自定义线程类<br>其本质是重构Thread类的run方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()  <span class="comment"># 重构run函数必须要写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"task"</span>, self.n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'2s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'1s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'0s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"t1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"t2"</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure></p><h4 id="2-1-2-计算子线程执行的时间"><a href="#2-1-2-计算子线程执行的时间" class="headerlink" title="2.1.2 计算子线程执行的时间"></a>2.1.2 计算子线程执行的时间</h4><p>注：sleep的时候是不会占用cpu的,在sleep的时候操作系统会把线程暂时挂起。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join()  <span class="comment">#等此线程执行完后，再执行其他线程或主线程</span></span><br><span class="line">threading.current_thread()      <span class="comment">#输出当前线程</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n,threading.current_thread())    <span class="comment">#输出当前的线程</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'3s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1s'</span>)</span><br><span class="line"></span><br><span class="line">strat_time = time.time()</span><br><span class="line"></span><br><span class="line">t_obj = []   <span class="comment">#定义列表用于存放子线程实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">由主线程生成的三个子线程</span></span><br><span class="line"><span class="string">task t-0 &lt;Thread(Thread-1, started 44828)&gt;</span></span><br><span class="line"><span class="string">task t-1 &lt;Thread(Thread-2, started 42804)&gt;</span></span><br><span class="line"><span class="string">task t-2 &lt;Thread(Thread-3, started 41384)&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> t_obj:</span><br><span class="line">    t.join()            <span class="comment">#为每个子线程添加join之后，主线程就会等这些子线程执行完之后再执行。</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"cost:"</span>, time.time() - strat_time) <span class="comment">#主线程</span></span><br><span class="line"></span><br><span class="line">print(threading.current_thread())       <span class="comment">#输出当前线程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">&lt;_MainThread(MainThread, started 43740)&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="2-1-3-统计当前活跃的线程数"><a href="#2-1-3-统计当前活跃的线程数" class="headerlink" title="2.1.3 统计当前活跃的线程数"></a>2.1.3 统计当前活跃的线程数</h4><p>由于主线程比子线程快很多，当主线程执行active_count()时，其他子线程都还没执行完毕，因此利用主线程统计的活跃的线程数num = sub_num(子线程数量)+1(主线程本身)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)    </span><br><span class="line">    time.sleep(<span class="number">1</span>)       <span class="comment">#此时子线程停1s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">0.5</span>)     <span class="comment">#主线程停0.5秒</span></span><br><span class="line">print(threading.active_count()) <span class="comment">#输出当前活跃的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t-0</span></span><br><span class="line"><span class="string">task t-1</span></span><br><span class="line"><span class="string">task t-2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p>由于主线程比子线程慢很多，当主线程执行active_count()时，其他子线程都已经执行完毕，因此利用主线程统计的活跃的线程数num = 1(主线程本身)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)       <span class="comment">#此时子线程停0.5s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)     <span class="comment">#主线程停1秒</span></span><br><span class="line">print(threading.active_count()) <span class="comment">#输出活跃的线程数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t-0</span></span><br><span class="line"><span class="string">task t-1</span></span><br><span class="line"><span class="string">task t-2</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p>此外我们还能发现在python内部默认会等待最后一个进程执行完后再执行exit()，或者说python内部在此时有一个隐藏的join()。</p><h3 id="2-2-守护进程"><a href="#2-2-守护进程" class="headerlink" title="2.2 守护进程"></a>2.2 守护进程</h3><p>我们看下面这个例子，这里使用setDaemon(True)把所有的子线程都变成了主线程的守护线程，因此当主进程结束后，子线程也会随之结束。所以当主线程结束后，整个程序就退出了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)       <span class="comment">#此时子线程停1s</span></span><br><span class="line">    print(<span class="string">'3'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)   <span class="comment">#把子进程设置为守护线程，必须在start()之前设置</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">0.5</span>)     <span class="comment">#主线程停0.5秒</span></span><br><span class="line">print(threading.active_count()) <span class="comment">#输出活跃的线程数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t-0</span></span><br><span class="line"><span class="string">task t-1</span></span><br><span class="line"><span class="string">task t-2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-GIL"><a href="#2-3-GIL" class="headerlink" title="2.3 GIL"></a>2.3 GIL</h3><p>在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少核，同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。<br>GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操作cpu，只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的。<br>Python多线程的工作过程：<br>python在使用多线程的时候，调用的是c语言的原生线程。</p><blockquote><p>拿到公共数据<br>  申请gil<br>  python解释器调用os原生线程<br>  os操作cpu执行运算<br>  当该线程执行时间到后，无论运算是否已经执行完，gil都被要求释放<br>  进而由其他进程重复上面的过程<br>  等其他进程执行完后，又会切换到之前的线程（从他记录的上下文继续执行）<br>  整个过程是每个线程执行自己的运算，当执行时间到就进行切换（context switch）。</p></blockquote><p>python针对不同类型的代码执行效率也是不同的：</p><blockquote><p>1、CPU密集型代码(各种循环处理、计算等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。<br>  2、IO密集型代码(文件处理、网络爬虫等涉及文件读写的操作)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。</p></blockquote><p>使用建议？</p><blockquote><p>python下想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。</p></blockquote><p>GIL在python中的版本差异：</p><blockquote><p>1、在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100时进行释放。（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过sys.setcheckinterval 来调整）。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。<br>  2、在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</p></blockquote><h3 id="2-4-线程锁"><a href="#2-4-线程锁" class="headerlink" title="2.4 线程锁"></a>2.4 线程锁</h3><p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据，所以，出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，你可以定义多个锁, 像下面的代码, 当你需要独占某一资源时，任何一个锁都可以锁这个资源，就好比你用不同的锁都可以把相同的一个门锁住是一个道理。<br>由于线程之间是进行随机调度，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期，我们也称此为“线程不安全”。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实测：在python2.7、mac os下，运行以下代码可能会产生脏数据。但是在python3中就不一定会出现下面的问题。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">t_obj = [] </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20000</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num:"</span>, num</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">产生脏数据后的运行结果：</span></span><br><span class="line"><span class="string">num: 19999</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><h3 id="2-5-互斥锁（mutex）"><a href="#2-5-互斥锁（mutex）" class="headerlink" title="2.5 互斥锁（mutex）"></a>2.5 互斥锁（mutex）</h3><p>为了方式上面情况的发生，就出现了互斥锁(Lock)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment">#获取锁</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    lock.release()  <span class="comment">#释放锁</span></span><br><span class="line"></span><br><span class="line">lock = threading.Lock()     <span class="comment">#实例化一个锁对象</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">t_obj = []  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20000</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num:"</span>, num</span><br></pre></td></tr></table></figure></p><h3 id="2-6-递归锁"><a href="#2-6-递归锁" class="headerlink" title="2.6 递归锁"></a>2.6 递归锁</h3><p>RLcok类的用法和Lock类一模一样，但它支持嵌套，，在多个锁没有释放的时候一般会使用使用RLcok类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">   </span><br><span class="line">gl_num = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">lock = threading.RLock()</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Func</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">global</span> gl_num</span><br><span class="line">    gl_num +=<span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> gl_num</span><br><span class="line">    lock.release()</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=Func)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></p><h3 id="2-7-信号量（BoundedSemaphore类）"><a href="#2-7-信号量（BoundedSemaphore类）" class="headerlink" title="2.7 信号量（BoundedSemaphore类）"></a>2.7 信号量（BoundedSemaphore类）</h3><p>互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    semaphore.acquire()   <span class="comment">#加锁</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"run the thread:%s\n"</span> % n)</span><br><span class="line">    semaphore.release()     <span class="comment">#释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">semaphore = threading.BoundedSemaphore(<span class="number">5</span>)  <span class="comment"># 最多允许5个线程同时运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">22</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> threading.active_count() != <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># print threading.active_count()</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'-----all threads done-----'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="2-8-事件（Event类）"><a href="#2-8-事件（Event类）" class="headerlink" title="2.8 事件（Event类）"></a>2.8 事件（Event类）</h3><p>python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象，其主要提供以下几个方法： </p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">注释</th></tr></thead><tbody><tr><td style="text-align:center">clear()</td><td style="text-align:center">将flag设置为“False”</td></tr><tr><td style="text-align:center">set()</td><td style="text-align:center">将flag设置为“True”</td></tr><tr><td style="text-align:center">is_set()</td><td style="text-align:center">判断是否设置了flag</td></tr><tr><td style="text-align:center">wait()</td><td style="text-align:center">会一直监听flag，如果没有检测到flag就一直处于阻塞状态</td></tr></tbody></table><p>事件处理的机制：全局定义了一个“Flag”，当flag值为“False”，那么event.wait()就会阻塞，当flag值为“True”，那么event.wait()便不再阻塞。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用Event类模拟红绿灯</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lighter</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    event.set()     <span class="comment">#初始值为绿灯</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">5</span> &lt; count &lt;=<span class="number">10</span> :</span><br><span class="line">            event.clear()  <span class="comment"># 红灯，清除标志位</span></span><br><span class="line">            print(<span class="string">"\33[41;1mred light is on...\033[0m"</span>)</span><br><span class="line">        <span class="keyword">elif</span> count &gt; <span class="number">10</span>:</span><br><span class="line">            event.set()  <span class="comment"># 绿灯，设置标志位</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"\33[42;1mgreen light is on...\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> event.is_set():      <span class="comment">#判断是否设置了标志位</span></span><br><span class="line">            print(<span class="string">"[%s] running..."</span>%name)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"[%s] sees red light,waiting..."</span>%name)</span><br><span class="line">            event.wait()</span><br><span class="line">            print(<span class="string">"[%s] green light is on,start going..."</span>%name)</span><br><span class="line"></span><br><span class="line">light = threading.Thread(target=lighter,)</span><br><span class="line">light.start()</span><br><span class="line"></span><br><span class="line">car = threading.Thread(target=car,args=(<span class="string">"MINI"</span>,))</span><br><span class="line">car.start()</span><br></pre></td></tr></table></figure></p><h3 id="2-9-条件（Condition类）"><a href="#2-9-条件（Condition类）" class="headerlink" title="2.9 条件（Condition类）"></a>2.9 条件（Condition类）</h3><p>使得线程等待，只有满足某条件时，才释放n个线程</p><h3 id="2-10-定时器（Timer类）"><a href="#2-10-定时器（Timer类）" class="headerlink" title="2.10 定时器（Timer类）"></a>2.10 定时器（Timer类）</h3><p>定时器，指定n秒后执行某操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world"</span>)</span><br><span class="line"> </span><br><span class="line">t = Timer(<span class="number">1</span>, hello)</span><br><span class="line">t.start()  <span class="comment"># after 1 seconds, "hello, world" will be printed</span></span><br></pre></td></tr></table></figure></p><h2 id="3、多进程"><a href="#3、多进程" class="headerlink" title="3、多进程"></a>3、多进程</h2><p>在linux中，每个进程都是由父进程提供的。每启动一个子进程就从父进程克隆一份数据，但是进程之间的数据本身是不能共享的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(title)</span>:</span></span><br><span class="line">    print(title)</span><br><span class="line">    print(<span class="string">'module name:'</span>, __name__)</span><br><span class="line">    print(<span class="string">'parent process:'</span>, os.getppid())  <span class="comment">#获取父进程id</span></span><br><span class="line">    print(<span class="string">'process id:'</span>, os.getpid())   <span class="comment">#获取自己的进程id</span></span><br><span class="line">    print(<span class="string">"\n\n"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    info(<span class="string">'\033[31;1mfunction f\033[0m'</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    info(<span class="string">'\033[32;1mmain process line\033[0m'</span>)</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><h3 id="3-1-进程间通信"><a href="#3-1-进程间通信" class="headerlink" title="3.1 进程间通信"></a>3.1 进程间通信</h3><p>由于进程之间数据是不共享的，所以不会出现多线程GIL带来的问题。多进程之间的通信通过Queue()或Pipe()来实现</p><h4 id="3-1-1-Queue"><a href="#3-1-1-Queue" class="headerlink" title="3.1.1 Queue()"></a>3.1.1 Queue()</h4><p>使用方法跟threading里的queue差不多<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put([<span class="number">42</span>, <span class="keyword">None</span>, <span class="string">'hello'</span>])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=f, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())    <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><h4 id="3-1-2-Pipe"><a href="#3-1-2-Pipe" class="headerlink" title="3.1.2 Pipe()"></a>3.1.2 Pipe()</h4><p>Pipe的本质是进程之间的数据传递，而不是数据共享，这和socket有点像。pipe()返回两个连接对象分别表示管道的两端，每端都有send()和recv()方法。如果两个进程试图在同一时间的同一端进行读取和写入那么，这可能会损坏管道中的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">42</span>, <span class="keyword">None</span>, <span class="string">'hello'</span>])</span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe() </span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><h4 id="3-1-3-Manager"><a href="#3-1-3-Manager" class="headerlink" title="3.1.3 Manager"></a>3.1.3 Manager</h4><p>通过Manager可实现进程间数据的共享。Manager()返回的manager对象会通过一个服务进程，来使其他进程通过代理的方式操作python对象。manager对象支持 list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value ,Array.<br><figure class="highlight plain"><figcaption><span>multiprocessing import Process, Manager</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">def f(d, l):</span><br><span class="line">    d[1] = &apos;1&apos;</span><br><span class="line">    d[&apos;2&apos;] = 2</span><br><span class="line">    d[0.25] = None</span><br><span class="line">    l.append(1)</span><br><span class="line">    print(l)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    with Manager() as manager:</span><br><span class="line">        d = manager.dict()</span><br><span class="line"> </span><br><span class="line">        l = manager.list(range(5))</span><br><span class="line">        p_list = []</span><br><span class="line">        for i in range(10):</span><br><span class="line">            p = Process(target=f, args=(d, l))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line">        for res in p_list:</span><br><span class="line">            res.join()</span><br><span class="line"> </span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure></p><h3 id="3-3-进程锁（进程同步）"><a href="#3-3-进程锁（进程同步）" class="headerlink" title="3.3 进程锁（进程同步）"></a>3.3 进程锁（进程同步）</h3><p>数据输出的时候保证不同进程的输出内容在同一块屏幕正常显示，防止数据乱序的情况。<br>Without using the lock output from the different processes is liable to get all mixed up.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(l, i)</span>:</span></span><br><span class="line">    l.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'hello world'</span>, i)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        l.release()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Process(target=f, args=(lock, num)).start()</span><br></pre></td></tr></table></figure></p><h3 id="3-4-进程池"><a href="#3-4-进程池" class="headerlink" title="3.4 进程池"></a>3.4 进程池</h3><p>由于进程启动的开销比较大，使用多进程的时候会导致大量内存空间被消耗。为了防止这种情况发生可以使用进程池，（由于启动线程的开销比较小，所以不需要线程池这种概念，多线程只会频繁得切换cpu导致系统变慢，并不会占用过多的内存空间）<br>进程池中常用方法：<br>apply() 同步执行（串行）<br>apply_async() 异步执行（并行）<br>terminate() 立刻关闭进程池<br>join() 主进程等待所有子进程执行完毕。必须在close或terminate()之后。<br>close() 等待所有进程结束后，才关闭进程池。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Process,Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Bar</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'--&gt;exec done:'</span>,arg)</span><br><span class="line"> </span><br><span class="line">pool = Pool(<span class="number">5</span>)  <span class="comment">#允许进程池同时放入5个进程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    pool.apply_async(func=Foo, args=(i,), callback=Bar)  <span class="comment">#func子进程执行完后，才会执行callback，否则callback不执行（而且callback是由父进程来执行了）</span></span><br><span class="line">    <span class="comment">#pool.apply(func=Foo, args=(i,))</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'end'</span>)</span><br><span class="line">pool.close()</span><br><span class="line">pool.join() <span class="comment">#主进程等待所有子进程执行完毕。必须在close()或terminate()之后。</span></span><br></pre></td></tr></table></figure></p><p>进程池内部维护一个进程序列，当使用时，去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。在上面的程序中产生了10个进程，但是只能有5同时被放入进程池，剩下的都被暂时挂起，并不占用内存空间，等前面的五个进程执行完后，再执行剩下5个进程。</p><h2 id="4、补充：协程"><a href="#4、补充：协程" class="headerlink" title="4、补充：协程"></a>4、补充：协程</h2><p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统，它本质上是操作系统提供的功能。而协程的操作则是程序员指定的，在python中通过yield，人为的实现并发处理。<br>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时。协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。<br>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO）。<br>常用第三方模块gevent和greenlet。（本质上，gevent是对greenlet的高级封装，因此一般用它就行，这是一个相当高效的模块。）</p><h3 id="4-1-greenlet"><a href="#4-1-greenlet" class="headerlink" title="4.1 greenlet"></a>4.1 greenlet</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">12</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    print(<span class="number">34</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">56</span>)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    print(<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure><p>实际上，greenlet就是通过switch方法在不同的任务之间进行切换。</p><h3 id="4-2-gevent"><a href="#4-2-gevent" class="headerlink" title="4.2 gevent"></a>4.2 gevent</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'GET: %s'</span> % url)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    data = resp.text</span><br><span class="line">    print(<span class="string">'%d bytes received from %s.'</span> % (len(data), url))</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://www.python.org/'</span>),</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://www.yahoo.com/'</span>),</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://github.com/'</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>通过joinall将任务f和它的参数进行统一调度，实现单线程中的协程。代码封装层次很高，实际使用只需要了解它的几个主要方法即可。</p><p><strong>转载自：</strong><a href="https://www.cnblogs.com/whatisfantasy/p/6440585.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">what is fantasy 的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、概念梳理&quot;&gt;&lt;a href=&quot;#1、概念梳理&quot; class=&quot;headerlink&quot; title=&quot;1、概念梳理&quot;&gt;&lt;/a&gt;1、概念梳理&lt;/h2&gt;&lt;h3 id=&quot;1-1-线程&quot;&gt;&lt;a href=&quot;#1-1-线程&quot; class=&quot;headerlink&quot; title=&quot;1.1 线程&quot;&gt;&lt;/a&gt;1.1 线程&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-什么是线程&quot;&gt;&lt;a href=&quot;#1-1-1-什么是线程&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 什么是线程&quot;&gt;&lt;/a&gt;1.1.1 什么是线程&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程是一个execution context（执行上下文），即一个cpu执行时所需要的一串指令。&lt;/p&gt;
&lt;h4 id=&quot;1-1-2-线程的工作方式&quot;&gt;&lt;a href=&quot;#1-1-2-线程的工作方式&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 线程的工作方式&quot;&gt;&lt;/a&gt;1.1.2 线程的工作方式&lt;/h4&gt;&lt;p&gt;假设你正在读一本书，没有读完，你想休息一下，但是你想在回来时恢复到当时读的具体进度。有一个方法就是记下页数、行数与字数这三个数值，这些数值就是execution context。如果你的室友在你休息的时候，使用相同的方法读这本书。你和她只需要这三个数字记下来就可以在交替的时间共同阅读这本书了。&lt;br&gt;线程的工作方式与此类似。CPU会给你一个在同一时间能够做多个运算的幻觉，实际上它在每个运算上只花了极少的时间，本质上CPU同一时刻只干了一件事。它能这样做就是因为它有每个运算的execution context。就像你能够和你朋友共享同一本书一样，多任务也能共享同一块CPU。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线程" scheme="http://blog.archiew.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://blog.archiew.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>中缀表达式Vs后缀表达式</title>
    <link href="http://blog.archiew.top/2018/05/21/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8FVs%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.archiew.top/2018/05/21/中缀表达式Vs后缀表达式/</id>
    <published>2018-05-21T13:32:03.000Z</published>
    <updated>2018-07-05T11:23:31.074Z</updated>
    
    <content type="html"><![CDATA[<p>中缀表达式，运算符放两个操作数中间的，考虑运算顺序，通用记法。<br>后缀表达式(逆波兰)，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。<br>后缀表达式存在的目的在于<strong>便于计算机通过栈操作计算</strong></p><a id="more"></a><hr><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式:"></a>中缀表达式转后缀表达式:</h2><p>以表达式<code>1+(2-3)*4-5/67</code>为例<br>顺序读入表达式，遵循以下规则：</p><ul><li>遇到数字直接输出</li><li>符号栈空或遇到左括号时，直接将符号入栈</li><li>遇到右括号，符号出栈并输出直到遇到左括号（左括号不输出）</li><li>遇到其他运算符（加减乘除），不断与栈顶符号对比，若优先级不高于栈顶符号，则输出栈顶符号，否则入栈</li><li>最后，将栈中操作符依次输出</li></ul><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 中缀转后缀</span><br><span class="line">s = input()</span><br><span class="line">t = []</span><br><span class="line">res = &apos;&apos;</span><br><span class="line">operator = &#123;</span><br><span class="line">    &apos;+&apos;: 0,</span><br><span class="line">    &apos;-&apos;: 0,</span><br><span class="line">    &apos;*&apos;: 1,</span><br><span class="line">    &apos;/&apos;: 1,</span><br><span class="line">    &#125;</span><br><span class="line">last_isnum = 0</span><br><span class="line"></span><br><span class="line">for i in s:</span><br><span class="line">    </span><br><span class="line">    if i not in [&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;,&apos;(&apos;,&apos;)&apos;]: #数字直接输出</span><br><span class="line">        if last_isnum:</span><br><span class="line">            res += i</span><br><span class="line">        else:</span><br><span class="line">            res += &apos; &apos;+i</span><br><span class="line">        last_isnum = 1</span><br><span class="line">    elif i == &apos;(&apos;:   #处理左括号</span><br><span class="line">        last_isnum = 0</span><br><span class="line">        t.append(i)</span><br><span class="line">    elif i == &apos;)&apos;:   #处理右括号</span><br><span class="line">        temp = t.pop()</span><br><span class="line">        while temp is not &apos;(&apos;:</span><br><span class="line">            if last_isnum == 1:</span><br><span class="line">                res += &apos; &apos;</span><br><span class="line">            res += temp</span><br><span class="line">            temp = t.pop()</span><br><span class="line">        last_isnum = 0</span><br><span class="line">    else:   #其他操作符处理</span><br><span class="line">        while t:</span><br><span class="line">            top = t.pop()</span><br><span class="line">            if top is not &apos;(&apos; and operator[i] &lt;= operator[top]:</span><br><span class="line">                if last_isnum == 1:</span><br><span class="line">                    res += &apos; &apos;</span><br><span class="line">                res += top</span><br><span class="line">                pass</span><br><span class="line">            else:</span><br><span class="line">                t.append(top)</span><br><span class="line">                break</span><br><span class="line">        t.append(i)</span><br><span class="line">        last_isnum = 0</span><br><span class="line">   </span><br><span class="line">while t:</span><br><span class="line">    res += &apos; &apos;+t.pop()</span><br><span class="line"></span><br><span class="line">print(res.strip())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 1+(2-3)/4-5/67</span><br><span class="line">1 2 3 - 4 / + 5 67 / -</span><br></pre></td></tr></table></figure></p><h2 id="后缀表达式转中缀表达式"><a href="#后缀表达式转中缀表达式" class="headerlink" title="后缀表达式转中缀表达式"></a>后缀表达式转中缀表达式</h2><p>以表达式<code>1 2 3 - 4 / + 5 67 / -</code>为例<br>顺序读入表达式，遵循以下规则：</p><ul><li>遇到非运算符，直接入栈</li><li>遇到运算符，从栈中弹出最上层两个元素，并与运算符组合，将结果入栈<br>代码实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 后缀转中缀</span><br><span class="line">res = 0</span><br><span class="line">s = input()</span><br><span class="line">s = s.split(&apos; &apos;)</span><br><span class="line">t = []</span><br><span class="line">for i in s:</span><br><span class="line">    if i not in [&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;]:</span><br><span class="line">        t.append(i)</span><br><span class="line">    else:</span><br><span class="line">        temp1 = t.pop()</span><br><span class="line">        temp2 = t.pop()</span><br><span class="line">        if i == &apos;+&apos;:</span><br><span class="line">            temp = &apos;(&apos;+temp2+&apos;+&apos;+temp1+&apos;)&apos;</span><br><span class="line">        elif i == &apos;-&apos;:</span><br><span class="line">            temp = &apos;(&apos;+temp2+&apos;-&apos;+temp1+&apos;)&apos;</span><br><span class="line">        elif i == &apos;*&apos;:</span><br><span class="line">            temp = temp2+&apos;*&apos;+temp1</span><br><span class="line">        elif i == &apos;/&apos;:</span><br><span class="line">            temp = temp2+&apos;/&apos;+temp1</span><br><span class="line">        t.append(temp)</span><br><span class="line">    print(t)</span><br><span class="line">print(t.pop())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 1 2 3 - 4 / + 5 67 / -</span><br><span class="line">((1+(2-3)/4)-5/67)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中缀表达式，运算符放两个操作数中间的，考虑运算顺序，通用记法。&lt;br&gt;后缀表达式(逆波兰)，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。&lt;br&gt;后缀表达式存在的目的在于&lt;strong&gt;便于计算机通过栈操作计算&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Generator</title>
    <link href="http://blog.archiew.top/2018/05/16/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Generator/"/>
    <id>http://blog.archiew.top/2018/05/16/深入剖析Generator/</id>
    <published>2018-05-16T13:57:31.000Z</published>
    <updated>2018-05-17T03:12:30.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generator是如何工作的？"><a href="#Generator是如何工作的？" class="headerlink" title="Generator是如何工作的？"></a>Generator是如何工作的？</h2><p>在剖析Generator之前，不妨先来回顾一下Python中普通函数是如何工作的。正常情况下，当Python主函数调用一个子函数时，子函数从主函数那里获得cpu控制权直到子函数结束或触发异常，然后主函数重新获得cpu控制权，继续执行后续任务。<br>以上我们可以通过查看Python字节码来说明。首先我们创建如下两个函数<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">a = 1</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def bar():</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><p>通过’反汇编’获得字节码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(foo)</span><br><span class="line">  2           0 LOAD_CONST               1 (1)</span><br><span class="line">              2 STORE_FAST               0 (a)</span><br><span class="line"></span><br><span class="line">  3           4 LOAD_GLOBAL              0 (bar)</span><br><span class="line">              6 CALL_FUNCTION            0</span><br><span class="line">              8 POP_TOP</span><br><span class="line">             10 LOAD_CONST               0 (None)</span><br><span class="line">             12 RETURN_VALUE</span><br></pre></td></tr></table></figure><p>foo函数首先加载bar到它的栈帧并调用(CALL_FUNCTION)它，然后把bar的返回值从栈中弹出，加载None到堆栈并返回。<br>有一点很重要：<strong>Python的栈帧实际上时分配在堆中的!</strong>Python解释器是用标准C语言实现的，它的栈帧是正常的栈帧(分配在栈空间)，而Python的栈帧是在堆中处理的，这就意味着Python中的栈帧在函数调用结束后依然可以存在，下面我们来看看这种现象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import inspect</span><br><span class="line">&gt;&gt;&gt; frame = None</span><br><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">a = 1</span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def bar():</span><br><span class="line">global frame</span><br><span class="line">frame = inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; foo()</span><br><span class="line">&gt;&gt;&gt; # The frame was executing the code for &apos;bar&apos;.</span><br><span class="line">&gt;&gt;&gt; frame.f_code.co_name</span><br><span class="line">&apos;bar&apos;</span><br><span class="line">&gt;&gt;&gt; # Its back pointer refers to the frame for &apos;foo&apos;.</span><br><span class="line">&gt;&gt;&gt; caller_frame = frame.f_back</span><br><span class="line">&gt;&gt;&gt; caller_frame.f_code.co_name</span><br><span class="line">&apos;foo&apos;</span><br></pre></td></tr></table></figure></p><p><img src="http://aosabook.org/en/500L/crawler-images/function-calls.png" alt="函数调用"></p><p>接下来看看Generator。下面是一个Generator函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def gen_fn():</span><br><span class="line">result = yield 1</span><br><span class="line">print(&apos;result of yield: &#123;&#125;&apos;.format(result))</span><br><span class="line">result2 = yield 2</span><br><span class="line">print(&apos;result of 2nd yield: &#123;&#125;&apos;.format(result2))</span><br><span class="line">return &apos;done&apos;</span><br></pre></td></tr></table></figure></p><p>Python规定：当一个函数中含有yield语句时，该函数会被当成是Generator函数，那么Python解释器是怎么实现这一点的呢？<br>实际上，当gen_fn函数编译为字节码时，遇到yield语句，解释器知道这是一个Generator函数，于是把对应的标志位(是的！Python是根据Generator标志位来表明该函数是一个Generator函数)。<br>可以看一下gen_fn函数对应的Generator标志位如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # The generator flag is bit position 5.</span><br><span class="line">&gt;&gt;&gt; generator_bit = 1 &lt;&lt; 5</span><br><span class="line">&gt;&gt;&gt; bool(gen_fn.__code__.co_flags &amp; generator_bit)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>所有对gen_fn的调用都指向同一个代码空间，但是每一个调用都有自己的栈帧，这些栈帧并非真正意义上的栈，而是上述所讲Python中的栈，它们时分配在堆空间的。<br><img src="http://aosabook.org/en/500L/crawler-images/generator.png" alt="Generator"><br>上图可以看到在Generator的栈帧中包含一个’f_lasti’的指针，改指针用于指向最后执行指令的位置(字节码中)，初始化为-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; gen = gen_fn()</span><br><span class="line">&gt;&gt;&gt; gen.gi_frame.f_lasti</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p><p>第一次调用<code>send</code>，Generator到达第一个<code>yield</code>并且暂停，<code>send</code>返回值为1。此时’f_lasti’指向第一个<code>yield</code>在字节码中的位置2。<br>第二次调用<code>send</code>，Generator到达第二个<code>yield</code>并且暂停，<code>send</code>返回值为2。此时’f_lasti’指向第二个<code>yield</code>在字节码中的位置22。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; gen.send(None)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; gen.gi_frame.f_lasti</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; gen.send(None)</span><br><span class="line">result of yield: None</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; gen.gi_frame.f_lasti</span><br><span class="line">22</span><br></pre></td></tr></table></figure><p>可以看到，Generator函数可以随时随地被任何函数暂停，这是因为其栈帧并非真正意义上的栈空间：它是分配在堆空间的。</p><p>译自：<em><a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="noopener">a-web-crawler-with-asyncio-coroutines</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Generator是如何工作的？&quot;&gt;&lt;a href=&quot;#Generator是如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;Generator是如何工作的？&quot;&gt;&lt;/a&gt;Generator是如何工作的？&lt;/h2&gt;&lt;p&gt;在剖析Generator之前，不妨先来回顾一下Python中普通函数是如何工作的。正常情况下，当Python主函数调用一个子函数时，子函数从主函数那里获得cpu控制权直到子函数结束或触发异常，然后主函数重新获得cpu控制权，继续执行后续任务。&lt;br&gt;以上我们可以通过查看Python字节码来说明。首先我们创建如下两个函数&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.archiew.top/tags/Python/"/>
    
      <category term="Generator" scheme="http://blog.archiew.top/tags/Generator/"/>
    
  </entry>
  
</feed>

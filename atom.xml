<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archiew的个人博客</title>
  <icon>https://www.gravatar.com/avatar/51d9bfd6e3a8e42ee493acb38f2ec057</icon>
  <subtitle>Simple is all ！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog365.top/"/>
  <updated>2018-07-08T14:23:48.278Z</updated>
  <id>http://blog365.top/</id>
  
  <author>
    <name>archiew</name>
    <email>archiew.top@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记2</title>
    <link href="http://blog365.top/2018/07/06/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://blog365.top/2018/07/06/CS231n用于视觉识别的卷积神经网络-学习笔记2/</id>
    <published>2018-07-06T00:59:46.000Z</published>
    <updated>2018-07-08T14:23:48.278Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/linear-classify/" target="_blank" rel="noopener">http://cs231n.github.io/linear-classify/</a><br>翻译：<a href="http://blog.archiew.top" target="_blank" rel="noopener">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入线性分类</a><br><a href="#score">线性得分函数</a><br><a href="#interpret">解释线性分类器</a><br><a href="#loss">损失函数</a><br><a href="#svm">　多类SVM</a><br><a href="#softmax">　Softmax分类器</a><br><a href="#svmvssoftmax">　SVM与Softmax</a><br><a href="#demo">线性分类器Web交互式演示</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="线性分类-1"><a href="#线性分类-1" class="headerlink" title="线性分类"></a><span id="intro">线性分类</span></h3><p>上一讲中，我们介绍了图像分类的问题，即从一组固定的类别中为图像分配单个标签的任务。更重要的是，我们描述了<strong>k-最近邻（kNN）</strong>分类器，它通过将图像与训练集中的（带注释的）图像进行比较来标记图像。正如我们所看到的，kNN有许多缺点：</p><blockquote><ul><li>分类器需要存储所有训练数据以供接下来与测试数据作比较。因为数据集大小很容易达到千兆字节，所以这会导致空间效率低下。</li><li>对测试图像的分类很耗费资源因为它需要与训练集中的所有图像进行比较。</li></ul></blockquote><p><strong>预览</strong> 接下来我们要开发出来一种更加高效的方法去进行图像分类，最终自然地扩展到整个神经网络和卷积神经网络。该方法涉及两个主要部分：将原始数据映射为分类得分的<strong>score function(得分函数)</strong>，量化预测分数和真值标签之间差异的<strong>lose function(损失函数)</strong>。我们将这个问题看作优化问题：最小化关于得分函数参数的损失函数。</p><h3 id="线性得分函数"><a href="#线性得分函数" class="headerlink" title="线性得分函数"></a><span id="score">线性得分函数</span></h3><p>首先定义得分函数，该函数将图像像素值映射为每个分类的置信度分数。接下来通过一个具体例子来说明。假定图像训练集\(x_i\in{R^D}\)，与之对应的标签集为\(y_i\)，其中\(i=1…N\),\(y_i\in{1…K}\)。也就是说，我们有\(N\)个样本(每个样本维度\(D\))和\(K\)个独立标签分类。例如，对于CIFAR-10，我们的训练集有\(N=50,000\)个图片，每个图片有\(D=32x32x3=3072\)个像素，独立分类数\(K=10\)。我们现在定义原始像素映射到分类得分的得分函数：$$f:R^D→R^K$$<br><strong>线性分类器(Linear classifier)</strong> 在这里，我们从最简单的线性映射开始：$$f(x_i,W,b)=Wx_i+b$$在上述等式中，假定图片\(x_i\)已经被平铺成一个单一列向量[Dx1]。矩阵\(W\)(大小：[KxD])和向量\(b\)(大小：[Kx1])是函数的<strong>参数</strong>。在CIFAR-10中，\(x_i\)是第i个被平铺成[3072x1]的图片，\(W\)是[10x3072],\(b\)是[10x1]，也就是我们输入3072个像素值，并获得代表分类的分的10个数据输出。参数\(W\)被称作<strong>权重</strong>，\(b\)被称作<strong>偏差向量</strong>因为它影响输出得分但并不与真实数据\(x_i\)交互。<br>注意：</p><blockquote><ul><li>单个矩阵相乘\(Wx_i\)有效地并行评估10个独立分类器，\(W\)中的每行都是一个分类器</li><li>输入数据\((x_i,y_i)\)是给定的，我们控制参数\(W,b\)的设置。目标是计算全部训练集中图片分类得分并与真值分类标签相匹配。直观上我们希望正确分类能够得到比错误分类更高的分数</li><li>这种方法的一个优势是训练集用来学习参数\(W,b\)，一旦学习完成，就可以完全抛弃训练集只保留学习到的参数。因为新的测试图片可以通过此函数进行简单的前向传递并且基于得分进行分类</li><li>最后，注意到对测试图片的分类仅涉及到一次矩阵乘法和加法，这将比之前的比较测试图片与训练图片差异快得多。</li></ul></blockquote><blockquote><p>卷积神经网络将图像像素映射为上述提到的得分，但是映射\(f\)将会更复杂并且包含更多的参数</p></blockquote><h3 id="解释线性分类器"><a href="#解释线性分类器" class="headerlink" title="解释线性分类器"></a><span id="interpret">解释线性分类器</span></h3><p>注意到线性分类器计算图像3个通道所有像素值的加权和作为分类得分。根据我们设置的权重值的精度，映射函数能够反映出对图片某些位置某种颜色的倾向。例如，设想图像中有许多蓝色像素点(可能被看作是‘水’)可能被分类为‘船’。我们可能希望‘船’分类器在图片蓝色通道上有许多正权重值(蓝色的存在会增加船分类的得分)，而在红/蓝通道上有负权重值(红/蓝的存在会降低船分类的得分)。<br><img src="http://cs231n.github.io/assets/imagemap.jpg" alt="图像映射为分类得分的例子。为方便可视化展示，我们假定图像仅含4个黑白像素，并且给定了3个分类标签：猫(red),狗(green),船(blue)。注意：这里的颜色并不代表图像颜色通道，仅作区分不同类用。将图像像素平铺成一列，执行矩阵乘法加法得到每个分类的得分。注意：上图中给出的权重值是随机的，因此得分结果并不准确，实际上我们希望得分结果中猫分类得分应该是最高的。"></p><p><strong>将图像类比为高维点</strong> 因为图片被平铺为高维列向量，因此我们可以将图片对应到高维空间内的一个点(eg.CIFAR-10中的每个图片都可对应为3072维空间中的一个点)。类似地，整个数据集就对应该空间中的一组(含标签)点集。<br>因为我们定义分类得分为图像像素加权和，所以每个分类得分是整个空间的线性函数。我们无法可视化3072维空间但是设想将其压缩为2维，然后尝试可视化分类器的操作过程。<br><img src="http://cs231n.github.io/assets/pixelspace.jpeg" alt="图像空间的可视化表示，每个图片都是对应空间的一个点。以汽车分类器(red)为例，红线上点表示对应于汽车分类器的得分为0的图像。红色箭头表示汽车分类器得分增加的方向，所以红线右侧的点有正值(呈线性增加)得分，左侧的点有负值(呈线性减小)得分。"></p><p>\(W\)中的每行对应一个分类的分类器。这些数的几何解释是，当我们改变\(W\)的每一行，像素空间对应线将会旋转不同方向。另一方面偏差\(b\)允许我们的分类器翻转这条线？？？尤其要注意的是没有偏差的话，对输入\(x_i=0\)将会输出0分，无论权重值为多少，因此所有线将会穿过原点。（这段没太懂）</p><p><strong>将线性分类器解释为模板匹配</strong> 权重\(W\)的另一种解释是每行对应一个分类模板(或者称作‘原型’)。对一个图片，每个分类的得分是通过比较每个模板和图片的内积(或点积)获得。用专业术语说，线性分类器在做模板匹配，而模板是在不断学习的。其实我们还是在做最近邻工作，只不过这里使用内积来代替L1或L2距离。<br><img src="http://cs231n.github.io/assets/templates.jpg" alt="学习CIFAR-10结束时的权重示例。注意：如我们所期望的那样，船模板包含了许多蓝色像素。因此对于一幅海洋中的船图片该模板做内积将会给出高分"></p><p>除此之外，注意到上图中马的模板似乎包含了一个‘双头’马，这是因为数据集中包含了面向左侧和面向右侧两种含马的训练图片，线性分类器将这两个模型合并到一个模板图中。类似地，汽车模板似乎合并了多个模型(不同角度不同颜色)到一个模板中。最终的模板呈现红色，表明数据集中含有大量红色汽车图片。那么实际上这个线性分类器在正确识别不同颜色汽车方面还有所欠缺，随后我们在神经网络中会做这部分工作。神经网能够通过隐藏层中的中间神经元来检测特殊的汽车类型(eg.向左的绿色汽车，向前的蓝色汽车)，后层神经元可以将这些结合起来得到更精确的汽车分类得分。<br><strong>偏差技巧</strong> 为简化，这里有个小技巧，我们可以将参数\(W,b\)合为一个。常用方法是将两个参数集结合成一个单一矩阵，具体要通过扩展向量\(x_i\)的维度(增加一列)，多余出来的量默认用1来填充。这样，之前的得分函数就会变成下面这样单一矩阵乘法：$$f(x_i,W)=Wx_i$$还以CIFAR-10为例，\(x_i\)将由[3072x1]变为[3073x1]，\(W\)由[10x072]变为[10x3073]。\(W\)中多出来的列对应于偏差\(b_i\)。下面的图可能会便于理解：<br><img src="http://cs231n.github.io/assets/wb.jpeg" alt="偏差简化技巧示意图"></p><p><strong>图片预处理</strong> 上面例子中我们使用图像原始像素([0…255])，在机器学习中，更为常见的是规范化我们的输入。尤其重要的是通过减去每个特征的均值来<strong>中心化数据</strong>。对于图像而言就是要计算训练图片的均值，然后用每个图像去减去它得到像素范围在[-127,127]的图像。更进一步的常用方法是将每个图像像素值缩放至[-1,1]。零均值中心可能更重要，但我们打算放到理解了梯度下降之后再来讲。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a><span id="loss">损失函数</span></h3><p>上面章节定义了从像素值到分类得分的映射函数，通过一系列权重\(W\)使其参数化。我们希望通过调整权重值来达到预测分类得分和训练数据分类标签结果一致。<br>上面对猫的图片分类中，由于我们提供了随意的权重值，导致猫的分类得分远小于其他两个分类得分。我们将用一个<strong>损失函数</strong>(或叫<strong>成本函数</strong>，<strong>目标</strong>)来衡量得分结果与图片分类真值的差异。直观来讲，好的分类结果对应低的损失值，与之对应，坏的分类结果对应高的损失值。</p><h3 id="多类SVM损失"><a href="#多类SVM损失" class="headerlink" title="　多类SVM损失"></a><span id="#svm">　多类SVM损失</span></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/linear-classify/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/linear-classify/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分类&quot;&gt;&lt;a href=&quot;#线性分类&quot; class=&quot;headerlink&quot; title=&quot;线性分类&quot;&gt;&lt;/a&gt;线性分类&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入线性分类&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#score&quot;&gt;线性得分函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#interpret&quot;&gt;解释线性分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#loss&quot;&gt;损失函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#svm&quot;&gt;　多类SVM&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#softmax&quot;&gt;　Softmax分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#svmvssoftmax&quot;&gt;　SVM与Softmax&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#demo&quot;&gt;线性分类器Web交互式演示&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="视觉识别" scheme="http://blog365.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog365.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="线性分类" scheme="http://blog365.top/tags/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/"/>
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记1</title>
    <link href="http://blog365.top/2018/07/05/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://blog365.top/2018/07/05/CS231n用于视觉识别的卷积神经网络-学习笔记1/</id>
    <published>2018-07-05T01:24:20.000Z</published>
    <updated>2018-07-06T01:46:09.267Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/classification/" target="_blank" rel="noopener">http://cs231n.github.io/classification/</a><br>翻译：<a href="http://blog.archiew.top" target="_blank" rel="noopener">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="图片分类问题-amp-数据驱动方法引入"><a href="#图片分类问题-amp-数据驱动方法引入" class="headerlink" title="图片分类问题&amp;数据驱动方法引入"></a>图片分类问题&amp;数据驱动方法引入</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入图片分类、数据驱动方法，数据流</a><br><a href="#nnc">最近邻分类器</a><br><a href="#knn">　K-最近邻分类器</a><br><a href="#val">验证集、交叉验证和超参调整</a><br><a href="#procon">最近邻优缺点</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="引入图片分类、数据驱动方法，数据流"><a href="#引入图片分类、数据驱动方法，数据流" class="headerlink" title="引入图片分类、数据驱动方法，数据流"></a><span id="intro">引入图片分类、数据驱动方法，数据流</span></h3><p><strong>图片分类问题</strong> 就是从一组固定的类别标签中为输入图像分配一个标签。看似简单问题，却包含了计算机视觉的核心问题，有很大的实际应用价值。同时，后面将要讲到的其他计算机视觉任务(eg.目标检测、分割)都可以被简化为图片的分类。<br><strong>例子</strong> 在下面的图像中，图像分类模型接收单个图像并为其分配给4个可能的分类标签{cat,dog,hat,mug}。正如图片所示，我们需要明确：在计算机看来，这幅图片只是一个3维的数据集合——本例中图片表示为248x400x3(248:宽度 400:高度 3:通道数RGB)，所以计算机实际上对这副图片的认识是297600个数字——每个数字都是一个0(黑)~255(白)的整数，图片分类任务就是将这写数据转换成一个分类标签，比如：cat。<br><img src="http://cs231n.github.io/assets/classify.png" alt="图片分类任务"></p><p><strong>挑战</strong> 对人类来说，视觉识别概念相对容易，但对于计算机来说却是一个不小的算法挑战，具体表现为：</p><blockquote><ul><li>视角变化(Viewpoint variation)</li><li>尺度变化(Scale variation)</li><li>变形(Deformation)</li><li>遮挡(Occlusion)</li><li>照明变化(Illumination conditions)</li><li>背景杂乱(Background clutter)</li><li>内在变化(Intra-class variation)</li></ul></blockquote><p><img src="http://cs231n.github.io/assets/challenges.jpeg" alt="视觉识别需要面临的挑战"></p><p>好的图片分类模型需要对这些变化的向量积不变，同时要保证对图片内在变化的敏感性。<br><strong>数据驱动方法</strong> 不像写一个数据排序算法那样明确，识别单个物体的算法并不是很明显，因此我们不会尝试直接在代码中写一个对指定物体的识别算法，而是采用人类学习方式，通过为计算机提供大量的学习数据，然后开发学习算法，从这些提供数据中学习每个分类的‘特征’。这种方法被称为‘数据驱动’，因为它依赖于积累的训练数据集标记图像。以下是这种数据集的实示例：<br><img src="http://cs231n.github.io/assets/trainset.jpg" alt="用于计算机学习的图片数据集"></p><p><strong>图片分类流</strong> 以上，我们了解了图片分类的任务过程，可以总结为如下流程：</p><blockquote><ul><li>Input输入：包含N个图片的数据集(每个图片对应k个分类标签中的一个)，我们将其称为<strong>训练集</strong></li><li>Learning学习：图片分类任务是利用上述训练集学习每类图片的‘特征’，我们将其称为<strong>训练分类器</strong>或者<strong>学习模型</strong></li><li>Evalution评估：最后我们通过预测一组新的数据集分类来评估分类器的性能，直观上我们希望预测的标签与图片真实标签(称为<strong>真值</strong>)相匹配。</li></ul></blockquote><h3 id="最近邻分类器"><a href="#最近邻分类器" class="headerlink" title="最近邻分类器"></a><span id="nnc">最近邻分类器</span></h3><p>我们将第一种分类方法成为‘最邻近分类器’(Nearest Neighbor Classifier)。这个分类器和卷积神经网络不相关，并且在实际中几乎用不到，但是它给了我们一个解决图片分类问题的基本思路。<br><strong>图片分类数据集：CIFAR-10</strong> 一个图片分类常用数据集：<a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10 dataset</a>。这个数据集包含了60,000个32x32像素的小图片，每个图片都有一个标签分类(共10个分类：airplane,automobile,bird,etc)，这60,000个图片被分为两部分：50,000个训练集和10,000个测试集。下图随机展示了数据集中的部分图片<br><img src="http://cs231n.github.io/assets/nn.jpg" alt="CIFAR-10 dataset"><br>左：CIFAR-10 dataset示例图片。右：第一列展示了一些测试图片，后边各列展示了根据像素差异显示训练集中的前10个最近邻居。<br>上图可以看出右边的预测分类仅有3/10的匹配率。<br>最简单的分类器模型就是对32x32x3数据逐像素点比较差异并求和，换句话说，给定两个图片我们用两个向量\(I_1,I_2\)表示，那么合理的差异比较选择是<strong>L1 distance</strong>$$d_1(I_1,I_2)=\sum_{p}|I_1^p-I_2^p|$$<br>下图是这个过程的可视化：<br><img src="http://cs231n.github.io/assets/nneg.jpeg" alt="L1 distance比较两个图片差异。如果结果为0说明两个图片一样，如果结果很大说明两图差异比较大"></p><p>下面会给出这一分类器的代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载数据集:training data/labels、test data/labels</span></span><br><span class="line">Xtr, Ytr, Xte, Yte = load_CIFAR10(<span class="string">'data/cifar10/'</span>)</span><br><span class="line"><span class="comment">#将三维数据平铺成一维</span></span><br><span class="line">Xtr_rows = Xtr.reshape(Xtr.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment">#Xtr_rows变为50000 x 3072</span></span><br><span class="line">Xte_rows = Xte.reshape(Xte.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment">#Xte_rows变为10000 x 3072</span></span><br><span class="line"></span><br><span class="line">nn = NearestNeighbor() <span class="comment">#创建一个最近邻分类器</span></span><br><span class="line">nn.train(Xtr_rows, Ytr) <span class="comment">#在训练集(含标签)上训练分类器</span></span><br><span class="line">Yte_predict = nn.predict(Xte_rows) <span class="comment">#在测试集上预测标签</span></span><br><span class="line"><span class="comment">#打印预测分类准确度(取平均值)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'accuracy: %f'</span> % ( np.mean(Yte_predict == Yte) )</span><br></pre></td></tr></table></figure></p><p>准确度accuracy，经常作为一个评估标准来评价预测结果正确性。上面的代码中关键的是训练函数train(X,y)和预测函数predict(X)，最重要的是分类器本身的实现，下面的代码实现了一个具有L1 distane的简单的最近邻分类器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearestNeighbor</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">    <span class="string">""" X是NxD的训练集(其中每行代表一个数据样本). y是大小为N的一维数据 """</span></span><br><span class="line">    <span class="comment"># the nearest neighbor classifier simply remembers all the training data</span></span><br><span class="line">    self.Xtr = X</span><br><span class="line">    self.ytr = y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    <span class="string">""" X是NxD的测试集(每行代表一个我们需要预测标签的样本数据) """</span></span><br><span class="line">    num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 确保输入输出数据类型匹配</span></span><br><span class="line">    Ypred = np.zeros(num_test, dtype = self.ytr.dtype)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有测试集样本数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</span><br><span class="line">      <span class="comment"># 根据L1 distance找出和第i个测试图像最近邻的训练图片</span></span><br><span class="line">      distances = np.sum(np.abs(self.Xtr - X[i,:]), axis = <span class="number">1</span>)</span><br><span class="line">      min_index = np.argmin(distances) <span class="comment"># 获取最小差异图像的索引值</span></span><br><span class="line">      Ypred[i] = self.ytr[min_index] <span class="comment"># 预测最近邻样本的标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure></p><p>上述代码实现了在CIFAR-10上38.6%的准确度，相对于人类近94%或者最先进(state-of-the-art)的卷积神经网络近95%(<a href="http://www.kaggle.com/c/cifar-10/leaderboard" target="_blank" rel="noopener">最新排行</a>)的准确度来说，这个结果可谓悲观。<br><strong>距离的选择</strong> 除上述L1 distance之外，还有许多其他计算向量之间距离的方法，另一个常用的计算方法是‘L2 distance’，计算公式如下所示：<br>$$d_2(I_1-I_2)=\sqrt{\sum_p(I_1^p-I_2^p)^2}$$<br>换句话说，L1 distance计算的是像素差，而L2 distance计算的是像素差的平方和的开方，我们用一行代码来替换上述计算距离的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distances = np.sqrt(np.square(self.Xtr-X[i,:]), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>上述代码中的<code>np.sqrt</code>在实际操作中一般被略去，因为开方函数是一个单调函数。也就是说，它仅仅改变了距离的绝对尺度但保留了距离排序，因此是无关紧要的。用这种方法计算距离得到了35.4%的预测准确度(略低于用L1 distance的结果)</p><p><strong>L1 VS L2</strong> 考虑这两者之间的差异会很有趣。实际上在涉及到两向量差异时L2 distance比L1 distance更<em>unforgiving</em>，也就是说相对于大的差异来说L2 distance更偏向于中等大小的差异。L1和L2 distance(等效于一对图片差异的L1/L2范数???)时<a href="http://planetmath.org/vectorpnorm" target="_blank" rel="noopener">p范数</a>中最常用的特殊情况。</p><h4 id="K-最近邻分类器"><a href="#K-最近邻分类器" class="headerlink" title="　K-最近邻分类器"></a><span id="knn">　K-最近邻分类器</span></h4><p>注意到上述预测只是利用了给定图片最近邻图像的标签。实际上更为常用且表现更好的方法是使用我们称之为‘k-Nearest Neighbor Classifier’(K-最近邻分类器)的分类器。其原理很简单：我们在训练集中寻找与测试图片近邻的top k个图片而不是之前的金庸一个最近邻图片来做标签预测。实际上，当k=1时就是上述最近邻分类器。直观上k值越大，分类器对于异常值平滑效果越好。<br><img src="http://cs231n.github.io/assets/knn.jpeg" alt="最近邻分类器和5-最近邻分类器的比较"></p><p>虽然k-最近邻分类器优于最近分类器，但是还有一个k值的选择问题。</p><h3 id="验证集、交叉验证和超参调整"><a href="#验证集、交叉验证和超参调整" class="headerlink" title="验证集、交叉验证和超参调整"></a><span id="knc">验证集、交叉验证和超参调整</span></h3><p>k-最近邻分类器需要设定k值，如何确定最优k值？此外，还有不同的距离计算方法，如上所示的L1范式和L2范式，甚至我们未曾考虑的点积计算等。这些多样选择我们称之为<strong>超参数</strong>，在许多机器学习算法的设计中这是很常见的。通常情况下，超参数值的确定并不明显。<br>你可能想到通过尝试多个参数值来寻找出最优值。这确实是个好想法，并且我们也确实打算这样做，但是我们必须对此持谨慎的态度！实际上，我们<strong>不能使用测试集来调整超参数</strong>。在设计机器学习算法时我们必须时刻将测试集视为一个宝贵的资源，理想情况下我们只会在最后阶段运用它。否则会出现在测试集上表现良好的超参数值在部署模型到新预测图片时性能显著下降的问题。这个问题我们称之为对测试集的<strong>overfit(过拟合)</strong>。只在最后阶段使用测试集会是衡量我们的分类器模型<strong>泛化</strong>的一个好的代理。</p><blockquote><p>测试集上的评估只能使用一次，在最后阶段</p></blockquote><p>幸运的是，有一个好方法来调整超参数而不触碰到测试集。具体做法为：将一个训练集分割为两部分，一个训练集和一个较小样本的<strong>验证集</strong>。以CIFAR-10为例，我们可以将样本数据集分为：包含49,000个图片的训练集和包含1,000个图片的验证集，验证集本质上是作为伪测试集用来调整超参数的。<br>下面给出了具体在CIFAR-10上的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们已经得到了Xtr_rows, Ytr, Xte_rows, Yte</span></span><br><span class="line"><span class="comment"># Xtr_rows：50,000 x 3072 </span></span><br><span class="line">Xval_rows = Xtr_rows[:<span class="number">1000</span>, :] <span class="comment"># 取前1000样本做验证集</span></span><br><span class="line">Yval = Ytr[:<span class="number">1000</span>]</span><br><span class="line">Xtr_rows = Xtr_rows[<span class="number">1000</span>:, :] <span class="comment"># 取后49000样本做训练集</span></span><br><span class="line">Ytr = Ytr[<span class="number">1000</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找在出验证集上的最优超参数</span></span><br><span class="line">validation_accuracies = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]:</span><br><span class="line">  <span class="comment"># 选用一系列k值并在验证集上进行评估</span></span><br><span class="line">  nn = NearestNeighbor()</span><br><span class="line">  nn.train(Xtr_rows, Ytr)</span><br><span class="line">  <span class="comment"># here we assume a modified NearestNeighbor class that can take a k as input</span></span><br><span class="line">  Yval_predict = nn.predict(Xval_rows, k = k)</span><br><span class="line">  acc = np.mean(Yval_predict == Yval)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'accuracy: %f'</span> % (acc,)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 跟踪在验证集上的表现</span></span><br><span class="line">  validation_accuracies.append((k, acc))</span><br></pre></td></tr></table></figure></p><p>最后，我们可以绘制出每次验证集上的准确度图并找出最优k值，再将此k值带入分类器并在测试集上做最终评估。</p><blockquote><p>将你的训练集分割成训练集和验证集，使用验证集调整超参数，最后在测试集上做一次评估并输出分类器性能</p></blockquote><p><strong>交叉验证</strong> 如果训练集规模很小，更多的是用一种复杂的技术来调整超参数，我们称之为<strong>cross-validation(交叉验证)</strong>。还以先前例子为例，这次我们不是随意地将训练集的前1000个样本作验证集剩下的做训练集，我们可以通过迭代不同的验证集并平衡其性能以获得一种更好且噪声更小的估计k的特定值。例如，在5-折交叉验证中，我们将训练集分割成5等份，用其中的4个作为训练集剩1个做验证集，得到一个评估性能，然后迭代地分别取不同的小份做验证集，这样可以得到5个评估性能值(准确度)，最后取平均值。<br><img src="http://cs231n.github.io/assets/cvplot.png" alt="5-折交叉验证的例子，每个待选k值对应5个准确度指标，取它们的平均值绘图并找出最大值，最大值对应的k值即是我们要寻找的最优超参数k"></p><p><strong>实践</strong> 实际操作时人们会更倾向于避免交叉验证而使用单一验证，因为交叉验证会消耗大量的计算资源。人们一般会使用训练集的50%-90%作为训练剩下的做验证，而这取决于多个因素：如果超参数数量很多，你可能更倾向于分割出更大的验证集；而如果验证集中的样本数量很少(几百个)，最好是用交叉验证。常用的折数一般为3-折，5-折，10-折。<br><img src="http://cs231n.github.io/assets/crossval.jpeg" alt="常用的数据分割"></p><h3 id="最近邻优缺点"><a href="#最近邻优缺点" class="headerlink" title="最近邻优缺点"></a><span id="procon">最近邻优缺点</span></h3><p>考量最邻近分类器的优缺点是有必要的。很明显，一个优势是它很简单且易于理解，除此之外分类器无需花费时间去训练，但是我们的时间花费在了预测上，因为预测需要比较测试图片和每一个训练样本的差异。这是backwards(倒退的)，因为实际上我们更关注的是预测时的时间效率。实际上随后讲到的深度神经网络将这个权衡移到了另一个极端：在训练时花费大量资源(运算、时间)，而在训练结束它会非常快地对测试图片进行分类预测。这种操作模式在实际运用中更可取。<br>另外，对于最近邻分类器的计算复杂度是另一个活跃的研究点，并且有一些<strong>近似最近邻(ANN)</strong>算法和库可以加速数据集中最近邻的查找(eg. <a href="http://www.cs.ubc.ca/research/flann/" target="_blank" rel="noopener">FLANN</a>)。这些算法允许人们在查找期间利用空间/时间复杂度来权衡最近邻查找的正确性，并且通常依赖于涉及构建kdtree或运行k均值算法的预处理/索引阶段。<br>最近邻分类器在某些情况下会是一个很好的选择(尤其是低维度数据)，但是在实际运用中很少去用作分类设置，其中一个问题是图片是高维物体(包含了大量像素数据)，而且高维空间的距离可能非常违反直观感觉。下图说明了我们上面开发的基于像素的L2相似度与感知相似度非常不同的点：<br><img src="http://cs231n.github.io/assets/samenorm.png" alt=""></p><p><em>在高维数据(尤其是图片)上基于像素的距离可能非常不直观。原图(左)和其他三幅图片在L2像素距离上有很大差异。很明显，像素距离和感知或语义相似并不一致。</em><br>下面给出了更多可视化图片方便理解使用图片见的像素差异并不能很好地胜任分类问题。运用可视化技术(<a href="http://homepage.tudelft.nl/19j49/t-SNE.html" target="_blank" rel="noopener">t-SNE</a>)将CIFAR-10中的图片展示在二维面上，一边保留他们的(局部)成对距离。在可视化过程中距离最近的图片被认为是最相近的(根据上述L2像素距离来讲)。<br><img src="http://cs231n.github.io/assets/pixels_embed_cifar10_big.jpg" alt=""></p><p>实际上，上述图片相近的图片更多的是在背景色彩上具有相似性而不是语义上的相似性。理想情况下我们希望所有图片会形成10个聚类，因此相同类的图像彼此相邻近而忽视无关特征和变化(如背景)。但是要获得这种属性，我们必须超越原始像素。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="summary">总结</span></h3><blockquote><ul><li>引入图片分类问题。给定一个带有单个分类标签的图片集，需要预测新的测试集中图片的分类并计算预测准确度。</li><li>引入了简单分类器<strong>最近邻分类器(Nearest Neighbor classifier)</strong>。认识到与分类器相关的多个超参数(k,distance计算类型等)，并且它们的选择并不明显</li><li>认识到设置超参数的正确方法是分割训练集为两部分：训练集和伪测试集(<strong>验证集</strong>)，尝试多个不同的超参数值并且选出在验证集上表现最好的那个值</li><li>如果缺少训练集，我们讨论了一个<strong>交叉验证(cross-validation)</strong>，这会帮助我们减少估计最优超参数值的噪声</li><li>一旦寻找到最优超参数值，我们将其固定下来并在真实测试集上做单次评估</li><li>认识到最近邻分类器在CIFAR-10上可以获得约40%的准确度，实现起来会很简单但是需要存储所有训练集并且在测试集上评估会很耗时</li><li>最后，我们认识到在原始像素上计算L1和L2距离并不能胜任分类工作，因为这种距离更多地和图片背景、色彩分布相关而不是图片的语义内容。</li></ul></blockquote><p>下一讲，着手处理本节中的挑战并且最终达到90%的准确度，让我们在完成学习之后完全抛弃训练集们，并且实现在1ms之内预测图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/classification/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/classification/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片分类问题-amp-数据驱动方法引入&quot;&gt;&lt;a href=&quot;#图片分类问题-amp-数据驱动方法引入&quot; class=&quot;headerlink&quot; title=&quot;图片分类问题&amp;amp;数据驱动方法引入&quot;&gt;&lt;/a&gt;图片分类问题&amp;amp;数据驱动方法引入&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入图片分类、数据驱动方法，数据流&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#nnc&quot;&gt;最近邻分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#knn&quot;&gt;　K-最近邻分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#val&quot;&gt;验证集、交叉验证和超参调整&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#procon&quot;&gt;最近邻优缺点&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="视觉识别" scheme="http://blog365.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog365.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图像分类" scheme="http://blog365.top/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式C语言面试题</title>
    <link href="http://blog365.top/2018/07/04/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog365.top/2018/07/04/嵌入式C语言面试题/</id>
    <published>2018-07-04T12:44:30.000Z</published>
    <updated>2018-07-05T11:22:08.984Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些嵌入式软件开发中C语言面试问题</p><a id="more"></a><hr><h3 id="1、预处理指令-define"><a href="#1、预处理指令-define" class="headerlink" title="1、预处理指令#define"></a>1、预处理指令#define</h3><p>有几点需要注意：首先是语法(无分号结束,字母大写,括号使用…)；其次明白预处理器会将表达式计算出来代入需要用的地方，所以尽量用表达式来清晰定义其作用而不是直接给出一常量值；还有就是要注意常量值可能的溢出问题(用UL后缀解决)<br>给出几个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用#define声明一个常数来表示一年中有多少秒（忽略闰年）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC_PER_YEAR(60*60*24*365)UL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用#define声明一个返回两个参数较小值的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(X,Y)(A)&gt;=(B)?(B):(A)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR int *</span></span><br><span class="line">PTR a, b;<span class="comment">//等价于int *a, b;</span></span><br><span class="line"><span class="keyword">int</span> *a, *b;</span><br></pre></td></tr></table></figure></p><h3 id="2、关键字static的作用"><a href="#2、关键字static的作用" class="headerlink" title="2、关键字static的作用"></a>2、关键字static的作用</h3><p>C语言中static主要有三个作用：<br>函数体内，被static修饰的变量在函数内保持值不变；<br>模块内(函数外)，被static修饰的变量成为一个本地全局变量，在模块内可被调用，模块外不可；<br>模块内，被static修饰的函数可被模块内函数调用。</p><h3 id="3、关键字const的作用"><a href="#3、关键字const的作用" class="headerlink" title="3、关键字const的作用"></a>3、关键字const的作用</h3><p>const一般用来修饰那些‘只读’的变量，防止变量被修改<br>const int a;   //常整数<br>int const a;   //同上<br>int <em>const a;  //指向整数的常指针<br>const int </em>a;  //指向常整数的指针<br>int const *a cons;  //指向常整数的常指针</p><h3 id="4、关键字volatile的作用"><a href="#4、关键字volatile的作用" class="headerlink" title="4、关键字volatile的作用"></a>4、关键字volatile的作用</h3><p>volatile用来修饰可能会被意想不到改变的变量，编译器会忽略对被volatile修饰的变量进行优化，每次取变量值都会去地址处取。（编译器优化的变量值会被‘缓存’到寄存器，这样不用每次都去变量地址处取值）<br>volatile典型应用在三个地方：<br>中断服务程序中<br>硬件寄存器<br>多线程应用中<br>eg. #define REG_N    <em>(volatile unsigned int </em>)0x80000000</p><h3 id="5、中断服务函数ISR"><a href="#5、中断服务函数ISR" class="headerlink" title="5、中断服务函数ISR"></a>5、中断服务函数ISR</h3><p>有几点需要注意：<br>没有返回值<br>尽量避免浮点运算<br>尽量避免IO操作</p><h3 id="6、强制类型转换"><a href="#6、强制类型转换" class="headerlink" title="6、强制类型转换"></a>6、强制类型转换</h3><ul><li>无符号数operate有符号数=无符号数<br>eg. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">-20</span>;</span><br><span class="line">(a+b&gt;<span class="number">6</span>)?<span class="built_in">puts</span>(<span class="string">"&gt;6"</span>):<span class="built_in">puts</span>(<span class="string">"&lt;=6"</span>)<span class="comment">//a+b会强制转换为无符号数：-20转换为无符号数应该是一个很大的值，so...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些嵌入式软件开发中C语言面试问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog365.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深度学习目标检测模型概述</title>
    <link href="http://blog365.top/2018/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog365.top/2018/06/26/深度学习目标检测模型概述/</id>
    <published>2018-06-26T01:04:46.000Z</published>
    <updated>2018-06-26T02:04:26.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、R-CNN"><a href="#1、R-CNN" class="headerlink" title="1、R-CNN"></a>1、R-CNN</h2><p>R-CNN(Region-based Convolutional Neural Network)分三个步骤：</p><ul><li>利用’选择性搜索(Selective Search)’算法生成约2k个region proposal，以获取可能出现的目标；</li><li>对每个region proposal运行CNN；</li><li>上述得到的CNN进行如下操作：<br>  a.输入到支持向量机(SVM),以对上述区域进行分类<br>  b.输入到一个线性回归器，以收缩目标周围边界框(假如目标存在)<br>R-CNN模型图如下所示：<br><a href="">R-CNN</a></li></ul><h2 id="2、Fast-R-CNN"><a href="#2、Fast-R-CNN" class="headerlink" title="2、Fast R-CNN"></a>2、Fast R-CNN</h2><p>Fast R-CNN相较于R-CNN主要是在检测速度方面进行了提升，而提升手段如下：</p><ul><li>在推荐区域之前，先对图像进行特征提取，这样做的好处是使整个图像只使用一个CNN(之前需要对2k个推荐区域分别运行CNN)</li><li>将R-CNN中的SVM替换为softmax，softmax直接输出类概率，而使用SVM需要训练多个SVM对每个目标类进行分类<br>相较R-CNN而言Fast R-CNN在速度上提升了许多，然而Fast R-CNN仍存在未解决的瓶颈问题：用于生成region proposal的选择搜索算法。</li></ul><h2 id="3、Faster-R-CNN"><a href="#3、Faster-R-CNN" class="headerlink" title="3、Faster R-CNN"></a>3、Faster R-CNN</h2><p>Faster R-CNN在Fast R-CNN的基础上通过引入region proposal网络(RPN)来代替选择搜索算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、R-CNN&quot;&gt;&lt;a href=&quot;#1、R-CNN&quot; class=&quot;headerlink&quot; title=&quot;1、R-CNN&quot;&gt;&lt;/a&gt;1、R-CNN&lt;/h2&gt;&lt;p&gt;R-CNN(Region-based Convolutional Neural Network)分三
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://blog365.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://blog365.top/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="R-CNN" scheme="http://blog365.top/tags/R-CNN/"/>
    
      <category term="Fast R-CNN" scheme="http://blog365.top/tags/Fast-R-CNN/"/>
    
      <category term="Faster R-CNN" scheme="http://blog365.top/tags/Faster-R-CNN/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 cuda-9.2安装</title>
    <link href="http://blog365.top/2018/06/19/Ubuntu16-04-4-cuda-9-2%E5%AE%89%E8%A3%85/"/>
    <id>http://blog365.top/2018/06/19/Ubuntu16-04-4-cuda-9-2安装/</id>
    <published>2018-06-19T13:08:41.000Z</published>
    <updated>2018-07-05T11:22:50.523Z</updated>
    
    <content type="html"><![CDATA[<p>系统：win7 64位<br>显卡：NVIDIA GT740</p><h2 id="1-Ubuntu16-04-4双系统安装"><a href="#1-Ubuntu16-04-4双系统安装" class="headerlink" title="1 Ubuntu16.04.4双系统安装"></a>1 Ubuntu16.04.4双系统安装</h2><blockquote><p>工具：<br>   EasyBCD 2.3<br>   <a href="http://cdimage.ubuntu.com/netboot/16.04/?_ga=2.212435411.69853237.1529413894-897926102.1529413894" target="_blank" rel="noopener">ubuntu-16.04.4-desktop-amd64.iso</a></p></blockquote><a id="more"></a><hr><h3 id="1-1-准备磁盘空间"><a href="#1-1-准备磁盘空间" class="headerlink" title="1.1 准备磁盘空间"></a>1.1 准备磁盘空间</h3><p>在win7下<code>win+R</code>运行diskmgmt.msc打开磁盘管理，选择一个可用空间较大的磁盘右键压缩磁盘，得到一个空的分区（100G左右）</p><h3 id="1-2-配置引导"><a href="#1-2-配置引导" class="headerlink" title="1.2 配置引导"></a>1.2 配置引导</h3><p>将ubuntu-16.04.2-desktop-amd64.iso中的initrd.lz、vmlinuz.efi 解压出来与iso一同放在C盘或D盘根目录（必须根目录）下。打开EasyBCD，添加新条目-&gt;NeoGrub-&gt;安装-&gt;配置，配置文件内容如下：<br>注意：上面的文件放在C盘根目录则为 hd0,0 ，D盘则为hd0,4<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NeoSmart NeoGrub Bootloader Configuration File  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># This is the NeoGrub configuration file, and should be located at C:\NST\menu.lst  </span></span><br><span class="line"><span class="comment"># Please see the EasyBCD Documentation for information on how to create/modify entries:  </span></span><br><span class="line"><span class="comment"># http://neosmart.net/wiki/display/EBCD/  </span></span><br><span class="line">  </span><br><span class="line">title Install Ubuntu   </span><br><span class="line">root (hd0,4)   </span><br><span class="line">kernel (hd0,4)/vmlinuz.efi <span class="attribute">boot</span>=casper iso-scan/<span class="attribute">filename</span>=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash <span class="attribute">locale</span>=zh_CN.UTF-8   </span><br><span class="line">initrd (hd0,4)/initrd.lz</span><br></pre></td></tr></table></figure></p><p>然后，在EasyBCD中编辑引导菜单，可以看到NeoGrub引导加载器，勾选等待用户选择，保存。</p><h3 id="1-3-进入引导"><a href="#1-3-进入引导" class="headerlink" title="1.3 进入引导"></a>1.3 进入引导</h3><p>配置完后重启，选择NeoGrub引导加载器，上述配置无误即可进入Ubuntu界面</p><h3 id="1-4-开始安装"><a href="#1-4-开始安装" class="headerlink" title="1.4 开始安装"></a>1.4 开始安装</h3><p>在Ubuntu界面使用<code>ctrl+alt+T</code>打开终端，输入命令<code>sudo umount -l /isodevice</code>卸载分区，然后点击桌面的安装程序进行安装，依次进行如下设置：</p><blockquote><p>系统语言设为English(可选)<br>   勾选‘安装Ubuntu时下载更新’<br>   安装类型选择‘其他选项’<br>   系统分区：<br>      交换空间swap：逻辑分区、空间起始位置 16384MB(一般设为机器内存大小左右)<br>      /              ：逻辑分区、空间起始位置、用于Ext4 30720MB(存放安装程序)<br>      /home          : 逻辑分区、空间起始位置、用于Ext4 剩下空闲空间扣除250MB<br>      /boot          ：主分区、空间起始位置、用于Ext4 250MB<br>      注意最下面‘安装启动引导器的设备’选择刚才分配的/boot所在分区<br>   默认设置…</p></blockquote><h3 id="1-5-添加启动项"><a href="#1-5-添加启动项" class="headerlink" title="1.5 添加启动项"></a>1.5 添加启动项</h3><p>上述安装完成重启进入win7，打开EasyBCD，添加Ubuntu启动项，删除NeoGrub引导项<br>添加新条目-&gt;Linux/BSD-&gt;类型选’GRUB2’-&gt;驱动器选’Linux-2xx MiB’-&gt;添加条目<br>切换到编辑引导菜单，删除NeoGrub引导项。   </p><h2 id="2-cuda-9-2安装"><a href="#2-cuda-9-2安装" class="headerlink" title="2 cuda-9.2安装"></a>2 cuda-9.2安装</h2><p>ubuntu 16.04默认安装了第三方开源的驱动程序nouveau，安装nvidia显卡驱动首先需要禁用nouveau，不然会碰到冲突的问题，导致无法安装nvidia显卡驱动。<br>编辑文件blacklist.conf<br>`sudo vim /etc/modprobe.d/blacklist.conf’<br>在文件最后部分插入以下两行内容<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau <span class="attribute">modeset</span>=0</span><br></pre></td></tr></table></figure></p><p>更新系统<code>sudo update-initramfs -u</code><br>重启，验证nouveau是否禁用<br><code>lsmod | grep nouveau</code><br>没有信息显示说明nouveau已禁用<br>按<code>ctrl+alt+f1</code>进入tty1<br><code>sudo service lightdm stop</code>关闭X server<br><code>sudo ./cuda_xxx.run</code> 运行事先下载好的cuda安装包<br>全都按默认配置<br><code>sudo service lightdm start</code><br>设置环境变量文件.bashrc或profile<br><code>export PATH=/usr/local/cuda-9.2/bin:$PATH</code><br><code>export LD_LIBRARY_PATH=/usr/local/cuda-9.2/lib64:#LD_LIBRARY_PATH</code><br>更新环境变量<br><code>souce /etc/profile</code><br>安装完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统：win7 64位&lt;br&gt;显卡：NVIDIA GT740&lt;/p&gt;
&lt;h2 id=&quot;1-Ubuntu16-04-4双系统安装&quot;&gt;&lt;a href=&quot;#1-Ubuntu16-04-4双系统安装&quot; class=&quot;headerlink&quot; title=&quot;1 Ubuntu16.04.4双系统安装&quot;&gt;&lt;/a&gt;1 Ubuntu16.04.4双系统安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;工具：&lt;br&gt;   EasyBCD 2.3&lt;br&gt;   &lt;a href=&quot;http://cdimage.ubuntu.com/netboot/16.04/?_ga=2.212435411.69853237.1529413894-897926102.1529413894&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ubuntu-16.04.4-desktop-amd64.iso&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://blog365.top/tags/Ubuntu/"/>
    
      <category term="cuda" scheme="http://blog365.top/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式基础知识汇总</title>
    <link href="http://blog365.top/2018/06/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://blog365.top/2018/06/19/嵌入式基础知识汇总/</id>
    <published>2018-06-19T01:04:51.000Z</published>
    <updated>2018-07-05T11:22:43.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-各数据类型所占字节大小"><a href="#1-各数据类型所占字节大小" class="headerlink" title="1.各数据类型所占字节大小"></a>1.各数据类型所占字节大小</h3><p><em>对于不同的处理器，所占空间大小取决于编译器的类型</em></p><a id="more"></a><hr><blockquote><p>16位编译器<br>char      : 1Byte<br>char*      : 2Byte        //也即指针变量<br>short int : 2Byte<br>int          : 2Byte<br>float      : 4Byte<br>double      : 8Byte<br>long      : 4Byte<br>long long : 8Byte</p></blockquote><blockquote><p>32位编译器<br>char       : 1Byte<br>char*      : 4Byte<br>int       : 4Byte<br>short int : 2Byte<br>float       : 4Byte<br>double      : 8Byte<br>long       : 4Byte<br>long long : 8Byte</p></blockquote><blockquote><p>64位编译器<br>char       : 1Byte<br>char*      : 8Byte<br>int          : 4Byte<br>short int : 2Byte<br>float      : 4Byte<br>double       : 8Byte<br>long       : 8Byte<br>long long : 8Byte</p></blockquote><h3 id="2-机器大小端问题"><a href="#2-机器大小端问题" class="headerlink" title="2.机器大小端问题"></a>2.机器大小端问题</h3><p>关于大小端：</p><blockquote><p>大端存储：高字节存低地址，即高位先存;(合乎阅读习惯)<br>   小端存储：低字节存低地址，即低位先存。</p></blockquote><p>例如：变量0x11223344,大小端存储如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址大端小端</span><br><span class="line"><span class="number">0x6ff710</span><span class="number">11</span><span class="number">44</span></span><br><span class="line"><span class="number">0x6ff711</span><span class="number">22</span><span class="number">33</span></span><br><span class="line"><span class="number">0x6ff712</span><span class="number">33</span><span class="number">22</span></span><br><span class="line"><span class="number">0x6ff713</span><span class="number">44</span><span class="number">11</span></span><br></pre></td></tr></table></figure></p><p>判断机器大小端方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="comment">// 利用指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">char</span> *p=(<span class="keyword">char</span>*)&amp;a;<span class="comment">//取变量a的低地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0x11</span>==*p)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"大端\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"小端\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="comment">// 利用联合体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">union</span> t&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">&#125;t1;</span><br><span class="line"></span><br><span class="line">t1.i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>==t1.c)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"小端\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"大端\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3.结构体"></a>3.结构体</h3><p>描述下面宏XXX的作用</p><blockquote><p>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</p></blockquote><p>   #define XXX(ptr, type, member) ({ \<br>   const typeof( ((type <em>)0)-&gt;member ) </em><strong>mptr = (ptr); \<br>   (type <em>)( (char </em>)</strong>mptr - offsetof(type,member) );})</p><p>假设存在结构体：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct s&#123;</span><br><span class="line">type1 A<span class="comment">;</span></span><br><span class="line">type2 <span class="keyword">B;</span></span><br><span class="line"><span class="keyword"></span>type3 C<span class="comment">;</span></span><br><span class="line">&#125;<span class="built_in">s1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>变量类型用typex代替是避免考虑内存中字节对齐的问题，现在s1在内存中的分布应该是这样的(假设的数据长度)：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址变量</span><br><span class="line"><span class="number">0x80000</span><span class="keyword">A</span></span><br><span class="line"><span class="number">0x80004</span> B</span><br><span class="line"><span class="number">0</span>x8000a C</span><br></pre></td></tr></table></figure></p><p>上面的宏运算涉及到的三个参数分别为：<br>ptr: 指向结构体成员的指针，比如type2<em> p=&amp;B<br>type: 结构体类型，比如struct s<br>member: 结构体成员名字，比如B<br>那么先看宏offsetof，((TYPE </em>)0)先将零类型转换为TYPE类型指针，((TYPE <em>)0)-&gt;MEMBER将访问TYPE结构体中的数据成员MEMBER，然后&amp;((TYPE </em>)0)-&gt;MEMBER取数据成员的地址，其实时取到了MEMBER成员相对于其所在结构体的偏移，最后(size_t)&amp;((TYPE <em>)0)-&gt;MEMBER实现结果类型转换<br>再看宏XXX，const typeof(((type </em>)0)-&gt;member)<em> <strong>mptr=(ptr);将结构体成员指针赋值指针变量</strong>mprt，(type</em>)((char*)__mptr-offsetof(type,member));是用结构体数据成员的指针减去该成员在结构体中的偏移量，得到结构体的基指针，最后强制转换成结构体指针类型<br>综上所述，该宏定义实现了根据结构体某成员变量获取该结构体基地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-各数据类型所占字节大小&quot;&gt;&lt;a href=&quot;#1-各数据类型所占字节大小&quot; class=&quot;headerlink&quot; title=&quot;1.各数据类型所占字节大小&quot;&gt;&lt;/a&gt;1.各数据类型所占字节大小&lt;/h3&gt;&lt;p&gt;&lt;em&gt;对于不同的处理器，所占空间大小取决于编译器的类型&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog365.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 安装OpenCV3.2.0</title>
    <link href="http://blog365.top/2018/06/15/Ubuntu16-04-4-%E5%AE%89%E8%A3%85OpenCV3-2/"/>
    <id>http://blog365.top/2018/06/15/Ubuntu16-04-4-安装OpenCV3-2/</id>
    <published>2018-06-15T08:27:52.000Z</published>
    <updated>2018-07-05T11:22:35.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h2><ul><li>GCC ≥4.4.x</li><li>CMake ≥2.8.7</li><li>Cit</li><li>GTK ≥2.x,including headers (libgtk2.0-dev)</li><li>pkg-config</li><li>Python ≥2.6,Numpy ≥1.5,with developer packages(python-dev,python-numpy)</li><li>ffmpeg or libav development packages: libavcodec-dev, libavformat-dev, libswscale-dev</li><li>[可选] libtbb2 libtbb-dev</li><li>[可选] libdc1394 2.x</li><li>[可选] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev, libdc1394-22-dev</li><li>[可选] CUDA Toolkit ≥6.5 </li></ul><a id="more"></a><hr><p>通过以下命令来安装上述依赖包：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install build-essential</span><br><span class="line">sudo apt-<span class="built_in">get</span> install cmake git libgtk2<span class="number">.0</span>-<span class="built_in">dev</span> pkg-config libavcodec-<span class="built_in">dev</span> libavformat-<span class="built_in">dev</span> libswscale-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install python-<span class="built_in">dev</span> python-numpy libtbb2 libtbb-<span class="built_in">dev</span> libjpeg-<span class="built_in">dev</span> libpng-<span class="built_in">dev</span> libtiff-<span class="built_in">dev</span> libjasper-<span class="built_in">dev</span> libdc1394<span class="number">-22</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p><h2 id="下载OpenCV源码"><a href="#下载OpenCV源码" class="headerlink" title="下载OpenCV源码"></a>下载OpenCV源码</h2><p>1.<a href="http://opencv.org/releases.html" target="_blank" rel="noopener">下载页</a>下载最新稳定版<br>2.从Git Repository获取：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/opencv/opencv.git</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure></p><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>1.创建临时文件夹，用于存放Makefiles等<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opencv</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure></p><p>2.配置并编译<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake <span class="meta">[&lt;some optional parameters&gt;]</span> &lt;path <span class="keyword">to</span> the OpenCV source directory&gt;</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -<span class="ruby">D CMAKE_INSTALL_PREFIX=<span class="regexp">/usr/local</span> \</span></span><br><span class="line"><span class="ruby">    -D INSTALL_PYTHON_EXAMPLES=ON \</span></span><br><span class="line"><span class="ruby">    -D INSTALL_C_EXAMPLES=OFF \</span></span><br><span class="line"><span class="ruby">    -D OPENCV_EXTRA_MODULES_PATH=~<span class="regexp">/opencv_contrib-3.2.0/modules</span> \</span></span><br><span class="line"><span class="ruby">    -D PYTHON_EXCUTABLE=<span class="regexp">/usr/bin</span><span class="regexp">/python \</span></span></span><br><span class="line"><span class="ruby">    -D WITH_CUDA=ON \    <span class="comment"># 使用CUDA</span></span></span><br><span class="line"><span class="ruby">    -D WITH_CUBLAS=ON \</span></span><br><span class="line"><span class="ruby">    -D DCUDA_NVCC_FLAGS=<span class="string">"-D_FORCE_INLINES"</span> \</span></span><br><span class="line"><span class="ruby">    -D CUDA_ARCH_BIN=<span class="string">"9.2"</span> \    <span class="comment"># 使用的CUDA所对应的版本</span></span></span><br><span class="line"><span class="ruby">    -D CUDA_ARCH_PTX=<span class="string">""</span> \</span></span><br><span class="line"><span class="ruby">    -D CUDA_FAST_MATH=ON \    <span class="comment"># 计算速度更快但是相对不精确</span></span></span><br><span class="line"><span class="ruby">    -D WITH_TBB=ON \</span></span><br><span class="line"><span class="ruby">    -D WITH_V4L=ON \</span></span><br><span class="line"><span class="ruby">    -D WITH_QT=ON \    <span class="comment"># 如果qt未安装可以删去此行;若因为未正确安装qt导致的Qt5Gui报错，可将build内文件全部删除后重新cmake，具体可以参考[这里](http://stackoverflow.com/questions/17420739/opencv-2-4-5-and-qt5-error-s)</span></span></span><br><span class="line"><span class="ruby">    -D WITH_GTK=ON \</span></span><br><span class="line"><span class="ruby">    -D WITH_OPENGL=ON \</span></span><br><span class="line"><span class="ruby">    -D BUILD_EXAMPLES=ON ~<span class="regexp">/opencv</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;依赖包&quot;&gt;&lt;a href=&quot;#依赖包&quot; class=&quot;headerlink&quot; title=&quot;依赖包&quot;&gt;&lt;/a&gt;依赖包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GCC ≥4.4.x&lt;/li&gt;
&lt;li&gt;CMake ≥2.8.7&lt;/li&gt;
&lt;li&gt;Cit&lt;/li&gt;
&lt;li&gt;GTK ≥2.x,including headers (libgtk2.0-dev)&lt;/li&gt;
&lt;li&gt;pkg-config&lt;/li&gt;
&lt;li&gt;Python ≥2.6,Numpy ≥1.5,with developer packages(python-dev,python-numpy)&lt;/li&gt;
&lt;li&gt;ffmpeg or libav development packages: libavcodec-dev, libavformat-dev, libswscale-dev&lt;/li&gt;
&lt;li&gt;[可选] libtbb2 libtbb-dev&lt;/li&gt;
&lt;li&gt;[可选] libdc1394 2.x&lt;/li&gt;
&lt;li&gt;[可选] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev, libdc1394-22-dev&lt;/li&gt;
&lt;li&gt;[可选] CUDA Toolkit ≥6.5 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="-Ubuntu -OpenCV" scheme="http://blog365.top/tags/Ubuntu-OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>习题</title>
    <link href="http://blog365.top/2018/05/26/%E4%B9%A0%E9%A2%98/"/>
    <id>http://blog365.top/2018/05/26/习题/</id>
    <published>2018-05-26T12:55:12.000Z</published>
    <updated>2018-07-05T11:23:14.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-c"><a href="#c-c" class="headerlink" title="c/c++"></a>c/c++</h2><ol><li>找到单向链表中间的元素，如果有两个则取前面那个。<br>分析：类似于”烧绳子”问题：有一节粗细均匀的绳子，完全烧完需要10min，请设法用烧绳子的方法来计时7.5min。关键在于”速度”的控制。<br>本题也可借用该思想：设置快、慢指针，从头节点开始，快指针一次移动2个节点，慢指针按正常方式一次移动1个节点，大体上当快指针移动到链表尽头时，慢指针恰好位于链表中间节点。<br>为什么要用”大体上”，因为需要考虑几个特殊情况：<blockquote><p>链表长度小于3，此时快指针移动2个节点出问题<br>链表长度为奇数，快指针恰好能够移动到尾节点，此时慢节点就是中间节点<br>链表长度为偶数，快节点无法移动到尾节点(只能移动到尾节点前一节点)，此时慢节点位于链表中间节点之一，且为前面那个</p></blockquote></li></ol><p>类似地，还可以倒序找出任何位置节点，比如要找倒数第k个节点，此时只需要让快节点在一开始领先于慢节点k个节点即可，只不过这种情况下，快慢指针移动速度是一样的：都是每次移动1个字节。同样地，也需要单独考虑几种特殊情况，例如链表长度小于k。</p><a id="more"></a><hr><p>2.统计一个无符号整形数二进制形式中’1’的个数。<br>分析：最先想到的一种方法就是移位+计数，这种情况下最多需要循环次数取决于整形数的bit数。<br>一种较快的方法是依次移除该数二进制形式最右边的1(x&amp;=(x-1))，并计数，这种情况下，循环次数取决于’1’的个数。</p><p>3.What will be the output of the following C code?<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line">*(p++) += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>, *p, *(p++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：本题唯一需要注意的是C中的printf参数是<strong>从右到左压栈</strong>的。</p><p>4.关于编程中内存的常识</p><blockquote><p>栈(stack):存放局部变量、函数参数等，由编译器自动分配与释放<br>  堆(heap) :一般由程序员分配与释放，在c中用malloc申请，在c++中用new申请<br>  全局(静态区)(static):存放全局变量、静态变量。初始化的全局变量和静态变量在一块，未初始化的全局变量和静态变量在另一块，程序结束由系统释放<br>  常量区:存放常量，程序结束由系统释放<br>  代码区:存放代码</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;c-c&quot;&gt;&lt;a href=&quot;#c-c&quot; class=&quot;headerlink&quot; title=&quot;c/c++&quot;&gt;&lt;/a&gt;c/c++&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;找到单向链表中间的元素，如果有两个则取前面那个。&lt;br&gt;分析：类似于”烧绳子”问题：有一节粗细均匀的绳子，完全烧完需要10min，请设法用烧绳子的方法来计时7.5min。关键在于”速度”的控制。&lt;br&gt;本题也可借用该思想：设置快、慢指针，从头节点开始，快指针一次移动2个节点，慢指针按正常方式一次移动1个节点，大体上当快指针移动到链表尽头时，慢指针恰好位于链表中间节点。&lt;br&gt;为什么要用”大体上”，因为需要考虑几个特殊情况：&lt;blockquote&gt;
&lt;p&gt;链表长度小于3，此时快指针移动2个节点出问题&lt;br&gt;链表长度为奇数，快指针恰好能够移动到尾节点，此时慢节点就是中间节点&lt;br&gt;链表长度为偶数，快节点无法移动到尾节点(只能移动到尾节点前一节点)，此时慢节点位于链表中间节点之一，且为前面那个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类似地，还可以倒序找出任何位置节点，比如要找倒数第k个节点，此时只需要让快节点在一开始领先于慢节点k个节点即可，只不过这种情况下，快慢指针移动速度是一样的：都是每次移动1个字节。同样地，也需要单独考虑几种特殊情况，例如链表长度小于k。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>搞定Python多线程和多进程</title>
    <link href="http://blog365.top/2018/05/22/%E6%90%9E%E5%AE%9APython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog365.top/2018/05/22/搞定Python多线程和多进程/</id>
    <published>2018-05-22T12:11:13.000Z</published>
    <updated>2018-07-05T11:23:23.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、概念梳理"><a href="#1、概念梳理" class="headerlink" title="1、概念梳理"></a>1、概念梳理</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><h4 id="1-1-1-什么是线程"><a href="#1-1-1-什么是线程" class="headerlink" title="1.1.1 什么是线程"></a>1.1.1 什么是线程</h4><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程是一个execution context（执行上下文），即一个cpu执行时所需要的一串指令。</p><h4 id="1-1-2-线程的工作方式"><a href="#1-1-2-线程的工作方式" class="headerlink" title="1.1.2 线程的工作方式"></a>1.1.2 线程的工作方式</h4><p>假设你正在读一本书，没有读完，你想休息一下，但是你想在回来时恢复到当时读的具体进度。有一个方法就是记下页数、行数与字数这三个数值，这些数值就是execution context。如果你的室友在你休息的时候，使用相同的方法读这本书。你和她只需要这三个数字记下来就可以在交替的时间共同阅读这本书了。<br>线程的工作方式与此类似。CPU会给你一个在同一时间能够做多个运算的幻觉，实际上它在每个运算上只花了极少的时间，本质上CPU同一时刻只干了一件事。它能这样做就是因为它有每个运算的execution context。就像你能够和你朋友共享同一本书一样，多任务也能共享同一块CPU。</p><a id="more"></a><hr><h3 id="1-2-进程"><a href="#1-2-进程" class="headerlink" title="1.2 进程"></a>1.2 进程</h3><p>一个程序的执行实例就是一个进程。每一个进程提供执行程序所需的所有资源。（进程本质上是资源的集合）<br>一个进程有一个虚拟的地址空间、可执行的代码、操作系统的接口、安全的上下文（记录启动该进程的用户和权限等等）、唯一的进程ID、环境变量、优先级类、最小和最大的工作空间（内存空间），还要有至少一个线程。<br>每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。<br>与进程相关的资源包括:</p><blockquote><p>内存页（同一个进程中的所有线程共享同一个内存空间）<br>  文件描述符(e.g. open sockets)<br>  安全凭证（e.g.启动该进程的用户ID）</p></blockquote><h3 id="1-3-进程和线程的区别"><a href="#1-3-进程和线程的区别" class="headerlink" title="1.3 进程和线程的区别"></a>1.3 进程和线程的区别</h3><p>1.同一个进程中的线程共享同一内存空间，但是进程之间是独立的。<br>2.同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。<br>3.对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。<br>4.线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源。<br>5.同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。<br>6.创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。<br>7.一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。<br>8.线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。</p><h2 id="2、多线程"><a href="#2、多线程" class="headerlink" title="2、多线程"></a>2、多线程</h2><h3 id="2-1-线程常用方法"><a href="#2-1-线程常用方法" class="headerlink" title="2.1 线程常用方法"></a>2.1 线程常用方法</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">注释</th></tr></thead><tbody><tr><td style="text-align:center">start()</td><td style="text-align:center">线程准备就绪，等待CPU调度</td></tr><tr><td style="text-align:center">setName()</td><td style="text-align:center">为线程设置名称</td></tr><tr><td style="text-align:center">getName()</td><td style="text-align:center">获取线程名称</td></tr><tr><td style="text-align:center">setDaemon(True)</td><td style="text-align:center">设置为守护线程</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:center">逐个执行每个线程，执行完毕后继续往下执行</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:center">线程被cpu调度后自动执行线程对象的run()方法，如果想自定义线程类，直接重写run()方法</td></tr></tbody></table><h4 id="2-1-1-Thread类"><a href="#2-1-1-Thread类" class="headerlink" title="2.1.1 Thread类"></a>2.1.1 Thread类</h4><p>1、普通创建方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'0s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run, args=(<span class="string">"t1"</span>,))</span><br><span class="line">t2 = threading.Thread(target=run, args=(<span class="string">"t2"</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t1</span></span><br><span class="line"><span class="string">task t2</span></span><br><span class="line"><span class="string">2s</span></span><br><span class="line"><span class="string">2s</span></span><br><span class="line"><span class="string">1s</span></span><br><span class="line"><span class="string">1s</span></span><br><span class="line"><span class="string">0s</span></span><br><span class="line"><span class="string">0s</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p>2、继承threading.Thread来自定义线程类<br>其本质是重构Thread类的run方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()  <span class="comment"># 重构run函数必须要写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"task"</span>, self.n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'2s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'1s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'0s'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"t1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"t2"</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure></p><h4 id="2-1-2-计算子线程执行的时间"><a href="#2-1-2-计算子线程执行的时间" class="headerlink" title="2.1.2 计算子线程执行的时间"></a>2.1.2 计算子线程执行的时间</h4><p>注：sleep的时候是不会占用cpu的,在sleep的时候操作系统会把线程暂时挂起。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">join()  <span class="comment">#等此线程执行完后，再执行其他线程或主线程</span></span><br><span class="line">threading.current_thread()      <span class="comment">#输出当前线程</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n,threading.current_thread())    <span class="comment">#输出当前的线程</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'3s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2s'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1s'</span>)</span><br><span class="line"></span><br><span class="line">strat_time = time.time()</span><br><span class="line"></span><br><span class="line">t_obj = []   <span class="comment">#定义列表用于存放子线程实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">由主线程生成的三个子线程</span></span><br><span class="line"><span class="string">task t-0 &lt;Thread(Thread-1, started 44828)&gt;</span></span><br><span class="line"><span class="string">task t-1 &lt;Thread(Thread-2, started 42804)&gt;</span></span><br><span class="line"><span class="string">task t-2 &lt;Thread(Thread-3, started 41384)&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> t_obj:</span><br><span class="line">    t.join()            <span class="comment">#为每个子线程添加join之后，主线程就会等这些子线程执行完之后再执行。</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"cost:"</span>, time.time() - strat_time) <span class="comment">#主线程</span></span><br><span class="line"></span><br><span class="line">print(threading.current_thread())       <span class="comment">#输出当前线程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">&lt;_MainThread(MainThread, started 43740)&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="2-1-3-统计当前活跃的线程数"><a href="#2-1-3-统计当前活跃的线程数" class="headerlink" title="2.1.3 统计当前活跃的线程数"></a>2.1.3 统计当前活跃的线程数</h4><p>由于主线程比子线程快很多，当主线程执行active_count()时，其他子线程都还没执行完毕，因此利用主线程统计的活跃的线程数num = sub_num(子线程数量)+1(主线程本身)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)    </span><br><span class="line">    time.sleep(<span class="number">1</span>)       <span class="comment">#此时子线程停1s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">0.5</span>)     <span class="comment">#主线程停0.5秒</span></span><br><span class="line">print(threading.active_count()) <span class="comment">#输出当前活跃的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t-0</span></span><br><span class="line"><span class="string">task t-1</span></span><br><span class="line"><span class="string">task t-2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p>由于主线程比子线程慢很多，当主线程执行active_count()时，其他子线程都已经执行完毕，因此利用主线程统计的活跃的线程数num = 1(主线程本身)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)       <span class="comment">#此时子线程停0.5s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)     <span class="comment">#主线程停1秒</span></span><br><span class="line">print(threading.active_count()) <span class="comment">#输出活跃的线程数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t-0</span></span><br><span class="line"><span class="string">task t-1</span></span><br><span class="line"><span class="string">task t-2</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><p>此外我们还能发现在python内部默认会等待最后一个进程执行完后再执行exit()，或者说python内部在此时有一个隐藏的join()。</p><h3 id="2-2-守护进程"><a href="#2-2-守护进程" class="headerlink" title="2.2 守护进程"></a>2.2 守护进程</h3><p>我们看下面这个例子，这里使用setDaemon(True)把所有的子线程都变成了主线程的守护线程，因此当主进程结束后，子线程也会随之结束。所以当主线程结束后，整个程序就退出了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"task"</span>, n)</span><br><span class="line">    time.sleep(<span class="number">1</span>)       <span class="comment">#此时子线程停1s</span></span><br><span class="line">    print(<span class="string">'3'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'2'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.setDaemon(<span class="keyword">True</span>)   <span class="comment">#把子进程设置为守护线程，必须在start()之前设置</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">0.5</span>)     <span class="comment">#主线程停0.5秒</span></span><br><span class="line">print(threading.active_count()) <span class="comment">#输出活跃的线程数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">task t-0</span></span><br><span class="line"><span class="string">task t-1</span></span><br><span class="line"><span class="string">task t-2</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-GIL"><a href="#2-3-GIL" class="headerlink" title="2.3 GIL"></a>2.3 GIL</h3><p>在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少核，同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。<br>GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操作cpu，只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的。<br>Python多线程的工作过程：<br>python在使用多线程的时候，调用的是c语言的原生线程。</p><blockquote><p>拿到公共数据<br>  申请gil<br>  python解释器调用os原生线程<br>  os操作cpu执行运算<br>  当该线程执行时间到后，无论运算是否已经执行完，gil都被要求释放<br>  进而由其他进程重复上面的过程<br>  等其他进程执行完后，又会切换到之前的线程（从他记录的上下文继续执行）<br>  整个过程是每个线程执行自己的运算，当执行时间到就进行切换（context switch）。</p></blockquote><p>python针对不同类型的代码执行效率也是不同的：</p><blockquote><p>1、CPU密集型代码(各种循环处理、计算等等)，在这种情况下，由于计算工作多，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。<br>  2、IO密集型代码(文件处理、网络爬虫等涉及文件读写的操作)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。</p></blockquote><p>使用建议？</p><blockquote><p>python下想要充分利用多核CPU，就用多进程。因为每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。</p></blockquote><p>GIL在python中的版本差异：</p><blockquote><p>1、在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100时进行释放。（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过sys.setcheckinterval 来调整）。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。<br>  2、在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</p></blockquote><h3 id="2-4-线程锁"><a href="#2-4-线程锁" class="headerlink" title="2.4 线程锁"></a>2.4 线程锁</h3><p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据，所以，出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，你可以定义多个锁, 像下面的代码, 当你需要独占某一资源时，任何一个锁都可以锁这个资源，就好比你用不同的锁都可以把相同的一个门锁住是一个道理。<br>由于线程之间是进行随机调度，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期，我们也称此为“线程不安全”。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实测：在python2.7、mac os下，运行以下代码可能会产生脏数据。但是在python3中就不一定会出现下面的问题。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">t_obj = [] </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20000</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num:"</span>, num</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">产生脏数据后的运行结果：</span></span><br><span class="line"><span class="string">num: 19999</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p><h3 id="2-5-互斥锁（mutex）"><a href="#2-5-互斥锁（mutex）" class="headerlink" title="2.5 互斥锁（mutex）"></a>2.5 互斥锁（mutex）</h3><p>为了方式上面情况的发生，就出现了互斥锁(Lock)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    lock.acquire()  <span class="comment">#获取锁</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    lock.release()  <span class="comment">#释放锁</span></span><br><span class="line"></span><br><span class="line">lock = threading.Lock()     <span class="comment">#实例化一个锁对象</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">t_obj = []  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20000</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line">    t_obj.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_obj:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num:"</span>, num</span><br></pre></td></tr></table></figure></p><h3 id="2-6-递归锁"><a href="#2-6-递归锁" class="headerlink" title="2.6 递归锁"></a>2.6 递归锁</h3><p>RLcok类的用法和Lock类一模一样，但它支持嵌套，，在多个锁没有释放的时候一般会使用使用RLcok类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">   </span><br><span class="line">gl_num = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">lock = threading.RLock()</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Func</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">global</span> gl_num</span><br><span class="line">    gl_num +=<span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> gl_num</span><br><span class="line">    lock.release()</span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=Func)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></p><h3 id="2-7-信号量（BoundedSemaphore类）"><a href="#2-7-信号量（BoundedSemaphore类）" class="headerlink" title="2.7 信号量（BoundedSemaphore类）"></a>2.7 信号量（BoundedSemaphore类）</h3><p>互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    semaphore.acquire()   <span class="comment">#加锁</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"run the thread:%s\n"</span> % n)</span><br><span class="line">    semaphore.release()     <span class="comment">#释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">semaphore = threading.BoundedSemaphore(<span class="number">5</span>)  <span class="comment"># 最多允许5个线程同时运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">22</span>):</span><br><span class="line">    t = threading.Thread(target=run, args=(<span class="string">"t-%s"</span> % i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> threading.active_count() != <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># print threading.active_count()</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'-----all threads done-----'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="2-8-事件（Event类）"><a href="#2-8-事件（Event类）" class="headerlink" title="2.8 事件（Event类）"></a>2.8 事件（Event类）</h3><p>python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象，其主要提供以下几个方法： </p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">注释</th></tr></thead><tbody><tr><td style="text-align:center">clear()</td><td style="text-align:center">将flag设置为“False”</td></tr><tr><td style="text-align:center">set()</td><td style="text-align:center">将flag设置为“True”</td></tr><tr><td style="text-align:center">is_set()</td><td style="text-align:center">判断是否设置了flag</td></tr><tr><td style="text-align:center">wait()</td><td style="text-align:center">会一直监听flag，如果没有检测到flag就一直处于阻塞状态</td></tr></tbody></table><p>事件处理的机制：全局定义了一个“Flag”，当flag值为“False”，那么event.wait()就会阻塞，当flag值为“True”，那么event.wait()便不再阻塞。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用Event类模拟红绿灯</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lighter</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    event.set()     <span class="comment">#初始值为绿灯</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">5</span> &lt; count &lt;=<span class="number">10</span> :</span><br><span class="line">            event.clear()  <span class="comment"># 红灯，清除标志位</span></span><br><span class="line">            print(<span class="string">"\33[41;1mred light is on...\033[0m"</span>)</span><br><span class="line">        <span class="keyword">elif</span> count &gt; <span class="number">10</span>:</span><br><span class="line">            event.set()  <span class="comment"># 绿灯，设置标志位</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"\33[42;1mgreen light is on...\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> event.is_set():      <span class="comment">#判断是否设置了标志位</span></span><br><span class="line">            print(<span class="string">"[%s] running..."</span>%name)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"[%s] sees red light,waiting..."</span>%name)</span><br><span class="line">            event.wait()</span><br><span class="line">            print(<span class="string">"[%s] green light is on,start going..."</span>%name)</span><br><span class="line"></span><br><span class="line">light = threading.Thread(target=lighter,)</span><br><span class="line">light.start()</span><br><span class="line"></span><br><span class="line">car = threading.Thread(target=car,args=(<span class="string">"MINI"</span>,))</span><br><span class="line">car.start()</span><br></pre></td></tr></table></figure></p><h3 id="2-9-条件（Condition类）"><a href="#2-9-条件（Condition类）" class="headerlink" title="2.9 条件（Condition类）"></a>2.9 条件（Condition类）</h3><p>使得线程等待，只有满足某条件时，才释放n个线程</p><h3 id="2-10-定时器（Timer类）"><a href="#2-10-定时器（Timer类）" class="headerlink" title="2.10 定时器（Timer类）"></a>2.10 定时器（Timer类）</h3><p>定时器，指定n秒后执行某操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world"</span>)</span><br><span class="line"> </span><br><span class="line">t = Timer(<span class="number">1</span>, hello)</span><br><span class="line">t.start()  <span class="comment"># after 1 seconds, "hello, world" will be printed</span></span><br></pre></td></tr></table></figure></p><h2 id="3、多进程"><a href="#3、多进程" class="headerlink" title="3、多进程"></a>3、多进程</h2><p>在linux中，每个进程都是由父进程提供的。每启动一个子进程就从父进程克隆一份数据，但是进程之间的数据本身是不能共享的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(title)</span>:</span></span><br><span class="line">    print(title)</span><br><span class="line">    print(<span class="string">'module name:'</span>, __name__)</span><br><span class="line">    print(<span class="string">'parent process:'</span>, os.getppid())  <span class="comment">#获取父进程id</span></span><br><span class="line">    print(<span class="string">'process id:'</span>, os.getpid())   <span class="comment">#获取自己的进程id</span></span><br><span class="line">    print(<span class="string">"\n\n"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    info(<span class="string">'\033[31;1mfunction f\033[0m'</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    info(<span class="string">'\033[32;1mmain process line\033[0m'</span>)</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><h3 id="3-1-进程间通信"><a href="#3-1-进程间通信" class="headerlink" title="3.1 进程间通信"></a>3.1 进程间通信</h3><p>由于进程之间数据是不共享的，所以不会出现多线程GIL带来的问题。多进程之间的通信通过Queue()或Pipe()来实现</p><h4 id="3-1-1-Queue"><a href="#3-1-1-Queue" class="headerlink" title="3.1.1 Queue()"></a>3.1.1 Queue()</h4><p>使用方法跟threading里的queue差不多<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put([<span class="number">42</span>, <span class="keyword">None</span>, <span class="string">'hello'</span>])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=f, args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())    <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><h4 id="3-1-2-Pipe"><a href="#3-1-2-Pipe" class="headerlink" title="3.1.2 Pipe()"></a>3.1.2 Pipe()</h4><p>Pipe的本质是进程之间的数据传递，而不是数据共享，这和socket有点像。pipe()返回两个连接对象分别表示管道的两端，每端都有send()和recv()方法。如果两个进程试图在同一时间的同一端进行读取和写入那么，这可能会损坏管道中的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">42</span>, <span class="keyword">None</span>, <span class="string">'hello'</span>])</span><br><span class="line">    conn.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe() </span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(parent_conn.recv())   <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></p><h4 id="3-1-3-Manager"><a href="#3-1-3-Manager" class="headerlink" title="3.1.3 Manager"></a>3.1.3 Manager</h4><p>通过Manager可实现进程间数据的共享。Manager()返回的manager对象会通过一个服务进程，来使其他进程通过代理的方式操作python对象。manager对象支持 list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value ,Array.<br><figure class="highlight plain"><figcaption><span>multiprocessing import Process, Manager</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">def f(d, l):</span><br><span class="line">    d[1] = &apos;1&apos;</span><br><span class="line">    d[&apos;2&apos;] = 2</span><br><span class="line">    d[0.25] = None</span><br><span class="line">    l.append(1)</span><br><span class="line">    print(l)</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    with Manager() as manager:</span><br><span class="line">        d = manager.dict()</span><br><span class="line"> </span><br><span class="line">        l = manager.list(range(5))</span><br><span class="line">        p_list = []</span><br><span class="line">        for i in range(10):</span><br><span class="line">            p = Process(target=f, args=(d, l))</span><br><span class="line">            p.start()</span><br><span class="line">            p_list.append(p)</span><br><span class="line">        for res in p_list:</span><br><span class="line">            res.join()</span><br><span class="line"> </span><br><span class="line">        print(d)</span><br><span class="line">        print(l)</span><br></pre></td></tr></table></figure></p><h3 id="3-3-进程锁（进程同步）"><a href="#3-3-进程锁（进程同步）" class="headerlink" title="3.3 进程锁（进程同步）"></a>3.3 进程锁（进程同步）</h3><p>数据输出的时候保证不同进程的输出内容在同一块屏幕正常显示，防止数据乱序的情况。<br>Without using the lock output from the different processes is liable to get all mixed up.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(l, i)</span>:</span></span><br><span class="line">    l.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'hello world'</span>, i)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        l.release()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Process(target=f, args=(lock, num)).start()</span><br></pre></td></tr></table></figure></p><h3 id="3-4-进程池"><a href="#3-4-进程池" class="headerlink" title="3.4 进程池"></a>3.4 进程池</h3><p>由于进程启动的开销比较大，使用多进程的时候会导致大量内存空间被消耗。为了防止这种情况发生可以使用进程池，（由于启动线程的开销比较小，所以不需要线程池这种概念，多线程只会频繁得切换cpu导致系统变慢，并不会占用过多的内存空间）<br>进程池中常用方法：<br>apply() 同步执行（串行）<br>apply_async() 异步执行（并行）<br>terminate() 立刻关闭进程池<br>join() 主进程等待所有子进程执行完毕。必须在close或terminate()之后。<br>close() 等待所有进程结束后，才关闭进程池。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Process,Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Bar</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'--&gt;exec done:'</span>,arg)</span><br><span class="line"> </span><br><span class="line">pool = Pool(<span class="number">5</span>)  <span class="comment">#允许进程池同时放入5个进程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    pool.apply_async(func=Foo, args=(i,), callback=Bar)  <span class="comment">#func子进程执行完后，才会执行callback，否则callback不执行（而且callback是由父进程来执行了）</span></span><br><span class="line">    <span class="comment">#pool.apply(func=Foo, args=(i,))</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'end'</span>)</span><br><span class="line">pool.close()</span><br><span class="line">pool.join() <span class="comment">#主进程等待所有子进程执行完毕。必须在close()或terminate()之后。</span></span><br></pre></td></tr></table></figure></p><p>进程池内部维护一个进程序列，当使用时，去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。在上面的程序中产生了10个进程，但是只能有5同时被放入进程池，剩下的都被暂时挂起，并不占用内存空间，等前面的五个进程执行完后，再执行剩下5个进程。</p><h2 id="4、补充：协程"><a href="#4、补充：协程" class="headerlink" title="4、补充：协程"></a>4、补充：协程</h2><p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统，它本质上是操作系统提供的功能。而协程的操作则是程序员指定的，在python中通过yield，人为的实现并发处理。<br>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时。协程，则只使用一个线程，分解一个线程成为多个“微线程”，在一个线程中规定某个代码块的执行顺序。<br>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO）。<br>常用第三方模块gevent和greenlet。（本质上，gevent是对greenlet的高级封装，因此一般用它就行，这是一个相当高效的模块。）</p><h3 id="4-1-greenlet"><a href="#4-1-greenlet" class="headerlink" title="4.1 greenlet"></a>4.1 greenlet</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">12</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    print(<span class="number">34</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">56</span>)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    print(<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure><p>实际上，greenlet就是通过switch方法在不同的任务之间进行切换。</p><h3 id="4-2-gevent"><a href="#4-2-gevent" class="headerlink" title="4.2 gevent"></a>4.2 gevent</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'GET: %s'</span> % url)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    data = resp.text</span><br><span class="line">    print(<span class="string">'%d bytes received from %s.'</span> % (len(data), url))</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://www.python.org/'</span>),</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://www.yahoo.com/'</span>),</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://github.com/'</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>通过joinall将任务f和它的参数进行统一调度，实现单线程中的协程。代码封装层次很高，实际使用只需要了解它的几个主要方法即可。</p><p><strong>转载自：</strong><a href="https://www.cnblogs.com/whatisfantasy/p/6440585.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">what is fantasy 的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、概念梳理&quot;&gt;&lt;a href=&quot;#1、概念梳理&quot; class=&quot;headerlink&quot; title=&quot;1、概念梳理&quot;&gt;&lt;/a&gt;1、概念梳理&lt;/h2&gt;&lt;h3 id=&quot;1-1-线程&quot;&gt;&lt;a href=&quot;#1-1-线程&quot; class=&quot;headerlink&quot; title=&quot;1.1 线程&quot;&gt;&lt;/a&gt;1.1 线程&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-什么是线程&quot;&gt;&lt;a href=&quot;#1-1-1-什么是线程&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 什么是线程&quot;&gt;&lt;/a&gt;1.1.1 什么是线程&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程是一个execution context（执行上下文），即一个cpu执行时所需要的一串指令。&lt;/p&gt;
&lt;h4 id=&quot;1-1-2-线程的工作方式&quot;&gt;&lt;a href=&quot;#1-1-2-线程的工作方式&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 线程的工作方式&quot;&gt;&lt;/a&gt;1.1.2 线程的工作方式&lt;/h4&gt;&lt;p&gt;假设你正在读一本书，没有读完，你想休息一下，但是你想在回来时恢复到当时读的具体进度。有一个方法就是记下页数、行数与字数这三个数值，这些数值就是execution context。如果你的室友在你休息的时候，使用相同的方法读这本书。你和她只需要这三个数字记下来就可以在交替的时间共同阅读这本书了。&lt;br&gt;线程的工作方式与此类似。CPU会给你一个在同一时间能够做多个运算的幻觉，实际上它在每个运算上只花了极少的时间，本质上CPU同一时刻只干了一件事。它能这样做就是因为它有每个运算的execution context。就像你能够和你朋友共享同一本书一样，多任务也能共享同一块CPU。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线程" scheme="http://blog365.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://blog365.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>中缀表达式Vs后缀表达式</title>
    <link href="http://blog365.top/2018/05/21/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8FVs%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog365.top/2018/05/21/中缀表达式Vs后缀表达式/</id>
    <published>2018-05-21T13:32:03.000Z</published>
    <updated>2018-07-05T11:23:31.074Z</updated>
    
    <content type="html"><![CDATA[<p>中缀表达式，运算符放两个操作数中间的，考虑运算顺序，通用记法。<br>后缀表达式(逆波兰)，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。<br>后缀表达式存在的目的在于<strong>便于计算机通过栈操作计算</strong></p><a id="more"></a><hr><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式:"></a>中缀表达式转后缀表达式:</h2><p>以表达式<code>1+(2-3)*4-5/67</code>为例<br>顺序读入表达式，遵循以下规则：</p><ul><li>遇到数字直接输出</li><li>符号栈空或遇到左括号时，直接将符号入栈</li><li>遇到右括号，符号出栈并输出直到遇到左括号（左括号不输出）</li><li>遇到其他运算符（加减乘除），不断与栈顶符号对比，若优先级不高于栈顶符号，则输出栈顶符号，否则入栈</li><li>最后，将栈中操作符依次输出</li></ul><p>代码实现：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 中缀转后缀</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">res</span> = <span class="string">''</span></span><br><span class="line">operator = &#123;</span><br><span class="line">    <span class="string">'+'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'-'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'*'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'/'</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">last_isnum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in <span class="variable">s:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i not in [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>,<span class="string">'('</span>,<span class="string">')'</span>]: #数字直接输出</span><br><span class="line">        <span class="keyword">if</span> last_isnum:</span><br><span class="line">            <span class="keyword">res</span> += i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">res</span> += <span class="string">' '</span>+i</span><br><span class="line">        last_isnum = <span class="number">1</span></span><br><span class="line">    elif i == <span class="string">'('</span>:   #处理左括号</span><br><span class="line">        last_isnum = <span class="number">0</span></span><br><span class="line">        t.<span class="keyword">append</span>(i)</span><br><span class="line">    elif i == <span class="string">')'</span>:   #处理右括号</span><br><span class="line">        temp = t.<span class="keyword">pop</span>()</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> not <span class="string">'('</span>:</span><br><span class="line">            <span class="keyword">if</span> last_isnum == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">res</span> += <span class="string">' '</span></span><br><span class="line">            <span class="keyword">res</span> += temp</span><br><span class="line">            temp = t.<span class="keyword">pop</span>()</span><br><span class="line">        last_isnum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:   #其他操作符处理</span><br><span class="line">        <span class="keyword">while</span> <span class="variable">t:</span></span><br><span class="line">            top = t.<span class="keyword">pop</span>()</span><br><span class="line">            <span class="keyword">if</span> top <span class="keyword">is</span> not <span class="string">'('</span> <span class="built_in">and</span> operator[i] &lt;= operator[top]:</span><br><span class="line">                <span class="keyword">if</span> last_isnum == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">res</span> += <span class="string">' '</span></span><br><span class="line">                <span class="keyword">res</span> += top</span><br><span class="line">                pass</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                t.<span class="keyword">append</span>(top)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        t.<span class="keyword">append</span>(i)</span><br><span class="line">        last_isnum = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> <span class="variable">t:</span></span><br><span class="line">    <span class="keyword">res</span> += <span class="string">' '</span>+t.<span class="keyword">pop</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">res</span>.strip())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="number">1</span>+(<span class="number">2</span>-<span class="number">3</span>)/<span class="number">4</span>-<span class="number">5</span>/<span class="number">67</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> - <span class="number">4</span> / + <span class="number">5</span> <span class="number">67</span> / -</span><br></pre></td></tr></table></figure></p><h2 id="后缀表达式转中缀表达式"><a href="#后缀表达式转中缀表达式" class="headerlink" title="后缀表达式转中缀表达式"></a>后缀表达式转中缀表达式</h2><p>以表达式<code>1 2 3 - 4 / + 5 67 / -</code>为例<br>顺序读入表达式，遵循以下规则：</p><ul><li>遇到非运算符，直接入栈</li><li>遇到运算符，从栈中弹出最上层两个元素，并与运算符组合，将结果入栈<br>代码实现：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 后缀转中缀</span><br><span class="line"><span class="keyword">res</span> = <span class="number">0</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">s = s.<span class="keyword">split</span>(<span class="string">' '</span>)</span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i in <span class="variable">s:</span></span><br><span class="line">    <span class="keyword">if</span> i not in [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>]:</span><br><span class="line">        t.<span class="keyword">append</span>(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp1 = t.<span class="keyword">pop</span>()</span><br><span class="line">        temp2 = t.<span class="keyword">pop</span>()</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">'+'</span>:</span><br><span class="line">            temp = <span class="string">'('</span>+temp2+<span class="string">'+'</span>+temp1+<span class="string">')'</span></span><br><span class="line">        elif i == <span class="string">'-'</span>:</span><br><span class="line">            temp = <span class="string">'('</span>+temp2+<span class="string">'-'</span>+temp1+<span class="string">')'</span></span><br><span class="line">        elif i == <span class="string">'*'</span>:</span><br><span class="line">            temp = temp2+<span class="string">'*'</span>+temp1</span><br><span class="line">        elif i == <span class="string">'/'</span>:</span><br><span class="line">            temp = temp2+<span class="string">'/'</span>+temp1</span><br><span class="line">        t.<span class="keyword">append</span>(temp)</span><br><span class="line">    <span class="keyword">print</span>(t)</span><br><span class="line"><span class="keyword">print</span>(t.<span class="keyword">pop</span>())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> - <span class="number">4</span> / + <span class="number">5</span> <span class="number">67</span> / -</span><br><span class="line">((<span class="number">1</span>+(<span class="number">2</span>-<span class="number">3</span>)/<span class="number">4</span>)-<span class="number">5</span>/<span class="number">67</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中缀表达式，运算符放两个操作数中间的，考虑运算顺序，通用记法。&lt;br&gt;后缀表达式(逆波兰)，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。&lt;br&gt;后缀表达式存在的目的在于&lt;strong&gt;便于计算机通过栈操作计算&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Generator</title>
    <link href="http://blog365.top/2018/05/16/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Generator/"/>
    <id>http://blog365.top/2018/05/16/深入剖析Generator/</id>
    <published>2018-05-16T13:57:31.000Z</published>
    <updated>2018-05-17T03:12:30.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generator是如何工作的？"><a href="#Generator是如何工作的？" class="headerlink" title="Generator是如何工作的？"></a>Generator是如何工作的？</h2><p>在剖析Generator之前，不妨先来回顾一下Python中普通函数是如何工作的。正常情况下，当Python主函数调用一个子函数时，子函数从主函数那里获得cpu控制权直到子函数结束或触发异常，然后主函数重新获得cpu控制权，继续执行后续任务。<br>以上我们可以通过查看Python字节码来说明。首先我们创建如下两个函数<br><a id="more"></a><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><p>通过’反汇编’获得字节码:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(foo)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">2</span> STORE_FAST               <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line">  <span class="number">3</span>           <span class="number">4</span> LOAD_GLOBAL              <span class="number">0</span> (bar)</span><br><span class="line">              <span class="number">6</span> CALL_FUNCTION            <span class="number">0</span></span><br><span class="line">              <span class="number">8</span> POP_TOP</span><br><span class="line">             <span class="number">10</span> LOAD_CONST               <span class="number">0</span> (None)</span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>foo函数首先加载bar到它的栈帧并调用(CALL_FUNCTION)它，然后把bar的返回值从栈中弹出，加载None到堆栈并返回。<br>有一点很重要：<strong>Python的栈帧实际上时分配在堆中的!</strong>Python解释器是用标准C语言实现的，它的栈帧是正常的栈帧(分配在栈空间)，而Python的栈帧是在堆中处理的，这就意味着Python中的栈帧在函数调用结束后依然可以存在，下面我们来看看这种现象：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import inspect</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; frame = None</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">global frame</span><br><span class="line">frame = inspect.currentframe()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; foo()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># The frame was executing the code for 'bar'.</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; frame.f_code.co_name</span><br><span class="line"><span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># Its back pointer refers to the frame for 'foo'.</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; caller_frame = frame.f_back</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; caller_frame.f_code.co_name</span><br><span class="line"><span class="string">'foo'</span></span><br></pre></td></tr></table></figure></p><p><img src="http://aosabook.org/en/500L/crawler-images/function-calls.png" alt="函数调用"></p><p>接下来看看Generator。下面是一个Generator函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_fn</span><span class="params">()</span>:</span></span><br><span class="line">result = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">print(<span class="string">'result of yield: &#123;&#125;'</span>.format(result))</span><br><span class="line">result2 = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">print(<span class="string">'result of 2nd yield: &#123;&#125;'</span>.format(result2))</span><br><span class="line"><span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></table></figure></p><p>Python规定：当一个函数中含有yield语句时，该函数会被当成是Generator函数，那么Python解释器是怎么实现这一点的呢？<br>实际上，当gen_fn函数编译为字节码时，遇到yield语句，解释器知道这是一个Generator函数，于是把对应的标志位(是的！Python是根据Generator标志位来表明该函数是一个Generator函数)。<br>可以看一下gen_fn函数对应的Generator标志位如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="comment"># The generator flag is bit position 5.</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; generator_bit = 1 &lt;&lt; 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; bool(gen_fn.__code__.co_flags &amp; generator_bit)</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>所有对gen_fn的调用都指向同一个代码空间，但是每一个调用都有自己的栈帧，这些栈帧并非真正意义上的栈，而是上述所讲Python中的栈，它们时分配在堆空间的。<br><img src="http://aosabook.org/en/500L/crawler-images/generator.png" alt="Generator"><br>上图可以看到在Generator的栈帧中包含一个’f_lasti’的指针，改指针用于指向最后执行指令的位置(字节码中)，初始化为-1<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen = gen_fn()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.gi_frame.f_lasti</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>第一次调用<code>send</code>，Generator到达第一个<code>yield</code>并且暂停，<code>send</code>返回值为1。此时’f_lasti’指向第一个<code>yield</code>在字节码中的位置2。<br>第二次调用<code>send</code>，Generator到达第二个<code>yield</code>并且暂停，<code>send</code>返回值为2。此时’f_lasti’指向第二个<code>yield</code>在字节码中的位置22。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.send(None)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.gi_frame.f_lasti</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.send(None)</span><br><span class="line">result of <span class="symbol">yield:</span> None</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; gen.gi_frame.f_lasti</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><p>可以看到，Generator函数可以随时随地被任何函数暂停，这是因为其栈帧并非真正意义上的栈空间：它是分配在堆空间的。</p><p>译自：<em><a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="noopener">a-web-crawler-with-asyncio-coroutines</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Generator是如何工作的？&quot;&gt;&lt;a href=&quot;#Generator是如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;Generator是如何工作的？&quot;&gt;&lt;/a&gt;Generator是如何工作的？&lt;/h2&gt;&lt;p&gt;在剖析Generator之前，不妨先来回顾一下Python中普通函数是如何工作的。正常情况下，当Python主函数调用一个子函数时，子函数从主函数那里获得cpu控制权直到子函数结束或触发异常，然后主函数重新获得cpu控制权，继续执行后续任务。&lt;br&gt;以上我们可以通过查看Python字节码来说明。首先我们创建如下两个函数&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
      <category term="Generator" scheme="http://blog365.top/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别</title>
    <link href="http://blog365.top/2018/05/15/%E5%90%8C%E6%AD%A5IO%E3%80%81%E5%BC%82%E6%AD%A5IO%E3%80%81%E9%98%BB%E5%A1%9EIO%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog365.top/2018/05/15/同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别/</id>
    <published>2018-05-15T03:22:48.000Z</published>
    <updated>2018-05-16T14:32:14.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>同步IO、异步IO、阻塞IO、非阻塞IO，这几个词常见于各种各样的与网络相关的文章之中，往往不同上下文中它们的意思是不一样的，以致于我在很长一段时间对此感到困惑，所以想写一篇文章整理一下。</p><blockquote><p>POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO<br>按POSIX的描述似乎把同步和阻塞划等号，异步和非阻塞划等号，但是为什么有的人说同步IO不等于阻塞IO呢？先来说说几种常见的IO模型吧。</p></blockquote><a id="more"></a><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>这里统一使用Linux下的系统调用recv作为例子，它用于从套接字上接收一个消息，因为是一个系统调用，所以调用时会从用户进程空间切换到内核空间运行一段时间再切换回来。默认情况下recv会等到网络数据到达并且复制到用户进程空间或者发生错误时返回，而第4个参数flags可以让它马上返回。</p><h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型，因为如果水龙头没有水，他也要等到有水并装满杯子才能离开去做别的事情。很显然，这种IO模型是同步的。<br><img src="http://image.euphie.net/2017-09-24-23-18-01.png" alt="阻塞式I/O模型"></p><h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p>改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。B同学也用杯子装水，打开水龙头后发现没有水，它离开了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场(回到用户进程空间)，可以做他自己的事情。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)，因此它还是同步IO。<br><img src="http://image.euphie.net/2017-09-24-23-19-53.png" alt="非阻塞式I/O模型"></p><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是阻塞于select或poll，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有阻塞于系统调用的IO操作(不包括数据从内核复制到用户空间时的阻塞，因为这相对于网络IO来说确实很短暂)，如果按这样理解，这种IO模型也能称之为非阻塞IO模型，但是按POSIX来看，它也是同步IO，那么也和楼上一样称之为同步非阻塞IO吧。<br>这种IO模型比较特别，分个段。因为它能同时监听多个文件描述符(fd)。这个时候C同学来装水，发现有一排水龙头，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，过了一会阿姨告诉他有水了，但不知道是哪个水龙头有水，自己看吧。于是C同学一个个打开，往杯子里装水(recv)。这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，主要区别在于舍管阿姨会告诉C同学哪几个水龙头有水了，不需要一个个打开看(当然还有其它区别)。<br><img src="http://image.euphie.net/2017-09-24-23-21-54.png" alt="I/O复用模型"></p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv)。D同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(省不了装水的时间啊)。<br><img src="http://image.euphie.net/2017-09-24-23-22-38.png" alt="信号驱动I/O模型"></p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情(没有recv)，这才是真正的异步IO。<br><img src="http://image.euphie.net/2017-09-24-23-23-36.png" alt="异步I/O模型"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IO分两阶段：</p><blockquote><p>1.数据准备阶段<br>  2.内核空间复制回用户进程缓冲区阶段</p></blockquote><p>一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。只有异步IO模型是符合POSIX异步IO操作含义的，不管在阶段1还是阶段2都可以干别的事。</p><h4 id="ps：以上图片均截自UNIX网络编程卷1。"><a href="#ps：以上图片均截自UNIX网络编程卷1。" class="headerlink" title="ps：以上图片均截自UNIX网络编程卷1。"></a>ps：以上图片均截自UNIX网络编程卷1。</h4><p>—转载自：<a href="http://www.cnblogs.com/euphie/p/6376508.html" target="_blank" rel="noopener">同步IO、异步IO、阻塞IO、非阻塞IO之间的联系与区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;POSIX&quot;&gt;&lt;a href=&quot;#POSIX&quot; class=&quot;headerlink&quot; title=&quot;POSIX&quot;&gt;&lt;/a&gt;POSIX&lt;/h2&gt;&lt;p&gt;同步IO、异步IO、阻塞IO、非阻塞IO，这几个词常见于各种各样的与网络相关的文章之中，往往不同上下文中它们的意思是不一样的，以致于我在很长一段时间对此感到困惑，所以想写一篇文章整理一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;POSIX(可移植操作系统接口)把同步IO操作定义为导致进程阻塞直到IO完成的操作，反之则是异步IO&lt;br&gt;按POSIX的描述似乎把同步和阻塞划等号，异步和非阻塞划等号，但是为什么有的人说同步IO不等于阻塞IO呢？先来说说几种常见的IO模型吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="IO操作" scheme="http://blog365.top/tags/IO%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python反射机制</title>
    <link href="http://blog365.top/2018/05/02/Python%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog365.top/2018/05/02/Python反射机制/</id>
    <published>2018-05-02T12:55:32.000Z</published>
    <updated>2018-05-16T14:07:16.494Z</updated>
    
    <content type="html"><![CDATA[<p>对编程语言比较熟悉的朋友，应该知道“反射”这个机制。Python作为一门动态语言，当然不会缺少这一重要功能。然而，在网络上却很少见到有详细或者深刻的剖析论文。下面结合一个web路由的实例来阐述Python的反射机制的使用场景和核心本质。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"f1是这个函数的名字！"</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="string">"f1"</span></span><br><span class="line">print(<span class="string">"%s是个字符串"</span> % s)</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们必须区分两个概念，f1和“f1”。前者是函数f1的函数名，后者只是一个叫”f1“的字符串，两者是不同的事物。我们可以用f1()的方式调用函数f1，但我们不能用”f1”()的方式调用函数。说白了就是，<strong>不能通过字符串来调用名字看起来相同的函数！</strong><br><a id="more"></a></p><h2 id="二、web实例"><a href="#二、web实例" class="headerlink" title="二、web实例"></a>二、web实例</h2><p>考虑有这么一个场景，根据用户输入的url的不同，调用不同的函数，实现不同的操作，也就是一个url路由器的功能，这在web框架里是核心部件之一。下面有一个精简版的示例：<br>首先，有一个commons模块，它里面有几个函数，分别用于展示不同的页面，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是一个登陆页面！"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是一个退出页面！"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"这是网站主页面！"</span>)</span><br></pre></td></tr></table></figure></p><p>其次，有一个visit模块，作为程序入口，接受用户输入，展示相应的页面，代码如下：（这段代码是比较初级的写法）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">"login"</span>:</span><br><span class="line">        commons.login()</span><br><span class="line">    <span class="keyword">elif</span> inp == <span class="string">"logout"</span>:</span><br><span class="line">        commons.logout()</span><br><span class="line">    <span class="keyword">elif</span> inp == <span class="string">"home"</span>:</span><br><span class="line">        commons.home()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure></p><p>我们运行visit.py，输入：home，页面结果如下：</p><blockquote><p>请输入您想访问页面的url：  home<br>这是网站主页面！</p></blockquote><p>这就实现了一个简单的WEB路由功能，根据不同的url，执行不同的函数，获得不同的页面。<br>然而，让我们考虑一个问题，如果commons模块里有成百上千个函数呢(这非常正常)?。难道你在visit模块里写上成百上千个elif?显然这是不可能的！那么怎么破？</p><h2 id="三、反射机制"><a href="#三、反射机制" class="headerlink" title="三、反射机制"></a>三、反射机制</h2><p>仔细观察visit中的代码，我们会发现用户输入的url字符串和相应调用的函数名好像！如果能用这个字符串直接调用函数就好了！但是，前面我们已经说了字符串是不能用来调用函数的。为了解决这个问题，Python为我们提供一个强大的内置函数：getattr!我们将前面的visit修改一下，代码如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import commons</span><br><span class="line"> </span><br><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(commons,inp)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>首先说明一下getattr函数的使用方法：它接收2个参数，前面的是一个对象或者模块，后面的是一个字符串，注意了！是个字符串！<br>例子中，用户输入储存在inp中，这个inp就是个字符串，getattr函数让程序去commons这个模块里，寻找一个叫inp的成员（是叫，不是等于），这个过程就相当于我们把一个字符串变成一个函数名的过程。然后，把获得的结果赋值给func这个变量，实际上func就指向了commons里的某个函数。最后通过调用func函数，实现对commons里函数的调用。这完全就是一个动态访问的过程，一切都不写死，全部根据用户输入来变化。<br>执行上面的代码，结果和最开始的是一样的。<br>这就是Python的反射，它的核心本质其实就是<strong>利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动！</strong><br>这段话，不一定准确，但大概就是这么个意思。</p><h2 id="四、进一步完善"><a href="#四、进一步完善" class="headerlink" title="四、进一步完善"></a>四、进一步完善</h2><p>上面的代码还有个小瑕疵，那就是如果用户输入一个非法的url，比如jpg，由于在commons里没有同名的函数，肯定会产生运行错误，具体如下：</p><blockquote><p>请输入您想访问页面的url：  jpg<br>Traceback (most recent call last):<br>  File “F:/Python/pycharm/s13/reflect/visit.py”, line 16, in <module><br>    run()<br>  File “F:/Python/pycharm/s13/reflect/visit.py”, line 11, in run<br>    func = getattr(commons,inp)<br>AttributeError: module ‘commons’ has no attribute ‘jpg’</module></p></blockquote><p>那怎么办呢？其实，Python考虑的很全面了，它同样提供了一个叫hasattr的内置函数，用于判断commons中是否具有某个成员。我们将代码修改一下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import commons</span><br><span class="line"> </span><br><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> hasattr(commons,inp):</span><br><span class="line">        <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(commons,inp)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>通过hasattr的判断，可以防止非法输入错误，并将其统一定位到错误页面。<br>其实，研究过python内置函数的朋友，应该注意到还有delattr和setattr两个内置函数。从字面上已经很好理解他们的作用了。<br>Python的四个重要内置函数：getattr、hasattr、delattr和setattr较为全面的实现了基于字符串的反射机制。他们都是对内存内的模块进行操作，并不会对源文件进行修改。    </p><h2 id="五、动态导入模块"><a href="#五、动态导入模块" class="headerlink" title="五、动态导入模块"></a>五、动态导入模块</h2><p>上面的例子是在某个特定的目录结构下才能正常实现的，也就是commons和visit模块在同一目录下，并且所有的页面处理函数都在commons模块内。如下图：<br><img src="https://images2015.cnblogs.com/blog/948404/201606/948404-20160611234648715-2037989511.png" alt=""><br>但在现实使用环境中，页面处理函数往往被分类放置在不同目录的不同模块中，也就是如下图：<br><img src="https://images2015.cnblogs.com/blog/948404/201606/948404-20160611235720511-1977401480.png" alt=""><br>难道我们要在visit模块里写上一大堆的import 语句逐个导入account、manage、commons模块吗？要是有1000个这种模块呢？<br>刚才我们分析完了基于字符串的反射，实现了动态的函数调用功能，我们不禁会想那么能不能动态导入模块呢？这完全是可以的！<br><strong> python提供了一个特殊的方法：<strong>import</strong>(字符串参数)。通过它，我们就可以实现类似的反射功能。<strong>import</strong>()方法会根据参数，动态的导入同名的模块。</strong><br>我们再修改一下上面的visit模块的代码。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    modules, <span class="function"><span class="keyword">func</span> = <span class="title">inp</span>.<span class="title">split</span><span class="params">(<span class="string">"/"</span>)</span></span></span><br><span class="line">    obj = __import__(modules)</span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, <span class="function"><span class="keyword">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(obj, func)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>运行一下：</p><blockquote><p>请输入您想访问页面的url：  commons/home<br>这是网站主页面！<br>请输入您想访问页面的url：  account/find<br>这是一个查找功能页面！</p></blockquote><p>我们来分析一下上面的代码：<br>首先，我们并没有定义任何一行import语句；<br>其次，用户的输入inp被要求为类似“commons/home”这种格式，其实也就是模拟web框架里的url地址，斜杠左边指向模块名，右边指向模块中的成员名。<br>然后，modules,func = inp.split(“/“)处理了用户输入，使我们获得的2个字符串，并分别保存在modules和func变量里。<br>接下来，最关键的是obj = <strong>import</strong>(modules)这一行，它让程序去导入了modules这个变量保存的字符串同名的模块，并将它赋值给obj变量。<br>最后的调用中，getattr去modules模块中调用func成员的含义和以前是一样的。<br>总结：通过<strong>import</strong>函数，我们实现了基于字符串的动态的模块导入。<br>同样的，这里也有个小瑕疵！<br>如果我们的目录结构是这样的：<br><img src="https://images2015.cnblogs.com/blog/948404/201606/948404-20160612002138605-2025008087.png" alt=""><br>那么在visit的模块调用语句中，必须进行修改，我们想当然地会这么做：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">run</span>():</span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    modules, <span class="function"><span class="keyword">func</span> = <span class="title">inp</span>.<span class="title">split</span><span class="params">(<span class="string">"/"</span>)</span></span></span><br><span class="line">    obj = __import__(<span class="string">"lib."</span> + modules)      <span class="meta">#注意字符串的拼接</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, <span class="function"><span class="keyword">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> = <span class="title">getattr</span><span class="params">(obj, func)</span></span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p><p>改了这么一个地方:obj = <strong>import</strong>(“lib.” + modules)，看起来似乎没什么问题，和import lib.commons的传统方法类似，但实际上运行的时候会有错误。</p><blockquote><p>请输入您想访问页面的url：  commons/home<br>404<br>请输入您想访问页面的url：  account/find<br>404</p></blockquote><p>为什么呢？因为<strong> 对于lib.xxx.xxx.xxx这一类的模块导入路径，<strong>import</strong>默认只会导入最开头的圆点左边的目录 </strong>，也就是“lib”。我们可以做个测试，在visit同级目录内新建一个文件，代码如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = __import__(<span class="string">"lib.commons"</span>)</span><br><span class="line">print(<span class="name">obj</span>)</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">module</span> <span class="string">'lib'</span> (<span class="keyword">namespace</span>)&gt;</span><br></pre></td></tr></table></figure></p><p>这个问题怎么解决呢？加上fromlist = True参数即可！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">"请输入您想访问页面的url：  "</span>).strip()</span><br><span class="line">    modules, func = inp.split(<span class="string">"/"</span>)</span><br><span class="line">    obj = __import__(<span class="string">"lib."</span> + modules, fromlist=<span class="keyword">True</span>)  <span class="comment"># 注意fromlist参数</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, func):</span><br><span class="line">        func = getattr(obj, func)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"404"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure></p><p>至此，动态导入模块的问题基本都解决了，只剩下最后一个，那就是万一用户输入错误的模块名呢？比如用户输入了somemodules/find，由于实际上不存在somemodules这个模块，必然会报错！那有没有类似上面hasattr内置函数这么个功能呢？答案是没有！碰到这种，你只能通过异常处理来解决。</p><h2 id="六、最后的思考"><a href="#六、最后的思考" class="headerlink" title="六、最后的思考"></a>六、最后的思考</h2><p>可能有人会问Python不是有两个内置函数exec和eval吗？他们同样能够执行字符串。比如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="string">"print('haha')"</span>)</span></span></span><br></pre></td></tr></table></figure></p><blockquote><p>结果：<br>haha</p></blockquote><p>那么直接使用它们不行吗？非要那么费劲地使用getattr，<strong>import</strong>干嘛？<br>其实，在上面的例子中，围绕的核心主题是如何利用字符串驱动不同的事件，比如导入模块、调用函数等等，这些都是Python的反射机制，是一种编程方法、设计模式的体现，凝聚了高内聚、松耦合的编程思想，不能简单的用执行字符串来代替。当然，exec和eval也有它的舞台，在web框架里也经常被使用。</p><p><strong> 转载自: <a href="https://www.cnblogs.com/Guido-admirers/p/6206212.html" target="_blank" rel="noopener">https://www.cnblogs.com/Guido-admirers/p/6206212.html</a> </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对编程语言比较熟悉的朋友，应该知道“反射”这个机制。Python作为一门动态语言，当然不会缺少这一重要功能。然而，在网络上却很少见到有详细或者深刻的剖析论文。下面结合一个web路由的实例来阐述Python的反射机制的使用场景和核心本质。&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;f1是这个函数的名字！&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;f1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;%s是个字符串&quot;&lt;/span&gt; % s)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的代码中，我们必须区分两个概念，f1和“f1”。前者是函数f1的函数名，后者只是一个叫”f1“的字符串，两者是不同的事物。我们可以用f1()的方式调用函数f1，但我们不能用”f1”()的方式调用函数。说白了就是，&lt;strong&gt;不能通过字符串来调用名字看起来相同的函数！&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog365.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
      <category term="反射机制" scheme="http://blog365.top/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>制作RSS电子书并推送给kindle</title>
    <link href="http://blog365.top/2018/04/22/%E5%88%B6%E4%BD%9Crss%E7%94%B5%E5%AD%90%E4%B9%A6%E5%B9%B6%E6%8E%A8%E9%80%81%E7%BB%99kindle/"/>
    <id>http://blog365.top/2018/04/22/制作rss电子书并推送给kindle/</id>
    <published>2018-04-22T03:33:09.000Z</published>
    <updated>2018-05-16T14:31:56.445Z</updated>
    
    <content type="html"><![CDATA[<p>简易信息聚合(Really Simple Syndication, RSS)是一种基于XML标准在互联网上被广泛采用的内容包装和投递协议。RSS允许用户以计算机可读的标准格式来获取（订阅）网站内容更新。相对于直接访问网站，使用Rss订阅能更快地<br>获取网站内容更新。RSS具有以下几个特点：</p><ul><li>来源多样的个性化“聚合”特性。</li><li>信息发布的时效、低成本特性。</li><li>无“垃圾”信息、便利的本地内容管理特性。</li></ul><a id="more"></a><hr><p>本文给出用python实现将RSS转换为电子书并推送给kindle的方法，可以自主方便地订阅自己感兴趣的RSS(类似<a href="http://www.dogear.cn/" target="_blank" rel="noopener">狗耳朵</a>、<a href="http://kindle4RSS.com/" target="_blank" rel="noopener">Kindle4RSS</a>之类)。</p><h2 id="一、获取并解析RSS内容"><a href="#一、获取并解析RSS内容" class="headerlink" title="一、获取并解析RSS内容"></a>一、获取并解析RSS内容</h2><p>对于RSS内容的获取解析，python有专门的第三方库可以实现：<a href="https://pypi.org/project/feedparser/" target="_blank" rel="noopener">feedparser</a>。所以我们首先安装feedparser:<br><code>pip install feedparser</code><br>然后来测试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">""" </span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">   Version:          Python3.6</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"></span><br><span class="line">contents = feedparser.parse(<span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>)</span><br><span class="line">print(contents)</span><br><span class="line"><span class="comment"># 打印如下：</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">'feed'</span>: &#123;</span><br><span class="line"><span class="string">'title'</span>: <span class="string">'新闻国内'</span>,</span><br><span class="line"><span class="string">'title_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'新闻国内'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'image'</span>: &#123;</span><br><span class="line"><span class="string">'title'</span>: <span class="string">'新闻国内'</span>,</span><br><span class="line"><span class="string">'title_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'新闻国内'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'links'</span>: [&#123;</span><br><span class="line"><span class="string">'rel'</span>: <span class="string">'alternate'</span>,</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://news.qq.com'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'link'</span>: <span class="string">'http://news.qq.com'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://mat1.qq.com/news/RSS/logo_news.gif'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'subtitle'</span>: <span class="string">'新闻国内'</span>,</span><br><span class="line"><span class="string">'subtitle_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'新闻国内'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'links'</span>: [&#123;</span><br><span class="line"><span class="string">'rel'</span>: <span class="string">'alternate'</span>,</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://news.qq.com/china_index.shtml'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'link'</span>: <span class="string">'http://news.qq.com/china_index.shtml'</span>,</span><br><span class="line"><span class="string">'rights'</span>: <span class="string">'Copyright 1998 - 2005 TENCENT Inc. All Rights Reserved'</span>,</span><br><span class="line"><span class="string">'rights_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'Copyright 1998 - 2005 TENCENT Inc. All Rights Reserved'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'language'</span>: <span class="string">'zh-cn'</span>,</span><br><span class="line"><span class="string">'generator_detail'</span>: &#123;</span><br><span class="line"><span class="string">'name'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'generator'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'entries'</span>: [&#123;</span><br><span class="line"><span class="string">'title'</span>: <span class="string">'钳工张学海：从0.05毫米的合格走向0.01毫米的卓越'</span>,</span><br><span class="line"><span class="string">'title_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'钳工张学海：从0.05毫米的合格走向0.01毫米的卓越'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'links'</span>: [&#123;</span><br><span class="line"><span class="string">'rel'</span>: <span class="string">'alternate'</span>,</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'href'</span>: <span class="string">'http://news.qq.com/a/20180422/006743.htm'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'link'</span>: <span class="string">'http://news.qq.com/a/20180422/006743.htm'</span>,</span><br><span class="line"><span class="string">'authors'</span>: [&#123;</span><br><span class="line"><span class="string">'name'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="string">'author'</span>: <span class="string">'www.qq.com'</span>,</span><br><span class="line"><span class="string">'author_detail'</span>: &#123;</span><br><span class="line"><span class="string">'name'</span>: <span class="string">'www.qq.com'</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">'tags'</span>: [],</span><br><span class="line"><span class="string">'published'</span>: <span class="string">'2018-04-22 11:32:50'</span>,</span><br><span class="line"><span class="string">'published_parsed'</span>: time.struct_time(tm_year = <span class="number">2018</span>, tm_mon = <span class="number">4</span>, tm_mday = <span class="number">22</span>, tm_hour = <span class="number">11</span>, tm_min = <span class="number">32</span>, tm_sec = <span class="number">50</span>, tm_wday = <span class="number">6</span>, tm_yday = <span class="number">112</span>, tm_isdst = <span class="number">0</span>),</span><br><span class="line"><span class="string">'comments'</span>: <span class="string">''</span>,</span><br><span class="line"><span class="string">'summary'</span>: <span class="string">'......'</span>,</span><br><span class="line"><span class="string">'summary_detail'</span>: &#123;</span><br><span class="line"><span class="string">'type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line"><span class="string">'language'</span>: <span class="keyword">None</span>,</span><br><span class="line"><span class="string">'base'</span>: <span class="string">'http://news.qq.com/newsgn/RSS_newsgn.xml'</span>,</span><br><span class="line"><span class="string">'value'</span>: <span class="string">'......'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>可以看出解析结果是json类型，我们可以从中提取所需信息（contents[‘feed’][‘title’],contents[‘entries’]）,其中contents[‘entries’]是个list类型，里面包含多条内容，我们逐条提取即可。</p><h2 id="二、将提取信息制作成电子书"><a href="#二、将提取信息制作成电子书" class="headerlink" title="二、将提取信息制作成电子书"></a>二、将提取信息制作成电子书</h2><p>这里用到的是Amazon提供的kindle电子书制作工具：<a href="https://www.amazon.com/gp/feature.html?docId=1000765211" target="_blank" rel="noopener">kindlegen</a><br>KindleGen 是一个免费的命令行工具，也是亚马逊唯一官方支持的文件转换工具，可通过它把 HTML、XHTML 或 IDPF 2.0 格式（带有 XML.opf 描述文件的 HTML 内容文件）的源文件创建为 Kindle 电子图书。高级用户可以使用命令行工具将 EPUB/HTML 转换为 Kindle 电子书。 您可以在 Windows、Mac 和 Linux 平台上使用此界面。此工具可用于自动批量转换。<br>1.<a href="http://kindlegen.s3.amazonaws.com/kindlegen_win32_v2_9.zip" target="_blank" rel="noopener">kindlegen下载地址</a><br>2.<a href="https://bookfere.com/post/92.html" target="_blank" rel="noopener">kindlegen用法</a><br>3.<a href="http://www.cnblogs.com/buptzym/p/5249662.html" target="_blank" rel="noopener">制作电子书相关</a><br>4.<a href="https://pan.baidu.com/s/1FY-Uvp-G-0grGDr3IAyANg" target="_blank" rel="noopener">kindlegen官方指南</a><br>这里讲几个关键，要想使用kindlegen生成电子书，需要提供几个必要文件：.html,.opf,.ncx,.jpg等，这些文件作用如下(参考3)：<br><img src="https://images2015.cnblogs.com/blog/287060/201603/287060-20160307103010788-489336141.png" alt="kindlegen所用文件"><br><strong>.html中用到的媒体文件（图片、音频等）必须保存在本地，kindlegen不负责对他们进行渲染下载。</strong><br>下面简单介绍一下这几个文件：<br><strong>.opf</strong><br>.opf是我们用kindlegen生成电子书时需要直接提供的文件，是电子书的资源索引文件，提供元数据，相当于对电子书用到的资源的一个声明:电子书用到的.html,.jpg等都需要在.opf中事先定义好才能用。.opf格式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">xmlns</span>=<span class="string">"http://www.idpf.org/2007/opf"</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">unique-identifier</span>=<span class="string">"BookId"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span> <span class="attr">xmlns:dc</span>=<span class="string">"http://purl.org/dc/elements/1.1/"</span> <span class="attr">xmlns:opf</span>=<span class="string">"http://www.idpf.org/2007/opf"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dc:title</span>&gt;</span>电子书标题<span class="tag">&lt;/<span class="name">dc:title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dc:language</span>&gt;</span>zh-cn<span class="tag">&lt;/<span class="name">dc:language</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- table of contents [mandatory] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">href</span>=<span class="string">"toc.ncx"</span> <span class="attr">media-type</span>=<span class="string">"application/x-dtbncx+xml"</span> <span class="attr">id</span>=<span class="string">"ncx"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">"tochtml"</span> <span class="attr">media-type</span>=<span class="string">"application/xhtml+xml"</span> <span class="attr">href</span>=<span class="string">"toc.html"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">"item0"</span> <span class="attr">media-type</span>=<span class="string">"application/xhtml+xml"</span> <span class="attr">href</span>=<span class="string">"Artical-1277621753.html"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!--下面是图片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">id</span>=<span class="string">"0.368541311142"</span> <span class="attr">media-type</span>=<span class="string">"image/jpg"</span> <span class="attr">href</span>=<span class="string">"Images/-1720404282.jpg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spine</span> <span class="attr">toc</span>=<span class="string">"desertfire"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 下面描述了KG生成电子书后文本的顺序(idref必须与上述资源id对应) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">itemref</span> <span class="attr">idref</span>=<span class="string">"ncx"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">itemref</span> <span class="attr">idref</span>=<span class="string">"tochtml"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">itemref</span> <span class="attr">idref</span>=<span class="string">"item0"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">spine</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">guide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reference</span> <span class="attr">type</span>=<span class="string">"toc"</span> <span class="attr">title</span>=<span class="string">"Table of Contents"</span> <span class="attr">href</span>=<span class="string">"toc.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">reference</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reference</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">title</span>=<span class="string">"Welcome"</span> <span class="attr">href</span>=<span class="string">"toc.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">reference</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">guide</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>熟悉.html的不难理解这个格式，关于更多详细信息，可以参考<a href="http://blog.sina.com.cn/s/blog_5c0175790100bdfv.html" target="_blank" rel="noopener">这里</a>，我们需要修改的有：<code>&lt;dc:title&gt;xxx&lt;/dc:title&gt;、&lt;item id=&quot;xxx&quot; .../&gt;、&lt;item idref=&quot;xxx&quot;/&gt;</code>，三者作用分别是：<br><img src="https://images2015.cnblogs.com/blog/287060/201603/287060-20160307103012038-1762823801.png" alt=".opf需要修改内容"><br><strong>.ncx</strong><br>.ncx是制作电子书目录的文件，这是一个xml文件，该标准由DAISY Consortium发布（参见<a href="http://www.daisy.org）。.ncx文件格式如下：" target="_blank" rel="noopener">http://www.daisy.org）。.ncx文件格式如下：</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ncx</span> <span class="attr">version</span>=<span class="string">"2005-1"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.daisy.org/z3986/2005/ncx/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- The following four metadata items are required for all NCX documents, including those conforming to the relaxed constraints of OPS 2.0 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:uid"</span> <span class="attr">content</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:depth"</span> <span class="attr">content</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"RSS2kindle (by Archiew)"</span> <span class="attr">name</span>=<span class="string">"dtb:generator"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:totalPageCount"</span> <span class="attr">content</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"dtb:maxPageNumber"</span> <span class="attr">content</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"right"</span> <span class="attr">content</span>=<span class="string">"该文档由www.kindle.archiew.top生成。www.kindle.archiew.top为在线免费电子书分享平台，内容完全来自网络，仅供个人交流与学习使用，不得用于任何商业用途。"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">docTitle</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">docTitle</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">docAuthor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>Archiew<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">docAuthor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">navMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">navPoint</span> <span class="attr">id</span>=<span class="string">"navpoint-1"</span> <span class="attr">playOrder</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">navLabel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span>&gt;</span>目录<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">navLabel</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">content</span> <span class="attr">src</span>=<span class="string">"tableOfContents.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">navPoint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">navPoint</span> <span class="attr">id</span>=<span class="string">"navpoint-2"</span> <span class="attr">playOrder</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">navLabel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">navLabel</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">content</span> <span class="attr">src</span>=<span class="string">"xxx"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">navPoint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">navMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ncx</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>关于更多详细信息，可以参考<a href="http://blog.sina.com.cn/s/blog_5c0175790100bdg5.html" target="_blank" rel="noopener">这里</a>，我们需要修改的有：<code>&lt;meta name=&quot;dtb:uid&quot; content=&quot;xxx&quot;/&gt;、&lt;docTitle /&gt;、&lt;navMap /&gt;</code>，三者作用分别是：电子书uid(每本书uid不能一样)、书籍标题、目录<br><strong>.html</strong><br>分为目录html(toc.html)和正文html(chapter.html)<br>目录html用于生成电子书目录，格式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span> <span class="attr">xml:lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>电子书标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>目录标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>Made by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.kindle.archiew.top"</span>&gt;</span>书舟网<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"category"</span>&gt;</span>目录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"chapter"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"章节html链接"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>章节标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>该书籍由网页内容生成，版权归原网站所有，仅供学习交流之用，请在下载后24小时内自行删除！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>书舟网-免费电子书分享平台(www.kindle.archiew.top)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>正文html用于生成电子书正文内容，格式可以随意发挥</p><p>用kindlegen生成电子书过程为，首先根据.opf文件确定电子书需要的所有资源文件(主要是.ncx、目录html、正文html、媒体资源等)以及电子书内容的排列顺序(取决于.opf中<spine>标签下资源排列顺序)，然后将上述内容做整合生成.mobi格式的电子书<br>以上就是用kindlegen生成电子书的详细介绍，但是我们不可能手动地一个个生成所需文件，这时就需要用到<strong>模板引擎</strong>，python下推荐<a href="http://jinja.pocoo.org/" target="_blank" rel="noopener">Jinja2</a> ，有了模板引擎，我们只需提供几个模板文件，然后通过Jinja2将解析出来的RSS内容填充到模板生成所需要的文件。最后用kindlegen命令<code>kindlegen xxx.opf</code>就能生成所需的电子书了。</spine></p><h2 id="三、将电子书推送到kindle"><a href="#三、将电子书推送到kindle" class="headerlink" title="三、将电子书推送到kindle"></a>三、将电子书推送到kindle</h2><p>上面我们生成的电子书，通过邮件发送到kindle邮箱即可完成推送</p><h3 id="注意："><a href="#注意：" class="headerlink" title="*注意："></a>*注意：</h3><p>1、由于各网站生成RSS工具不一样，所以用feedparser解析出来的内容可能不太一样(不会有很大差别)；<br>2、有的RSS只提供内容摘要，如果需要获得全文输出，需要自行爬取全文或者用一些全文RSS输出工具如<a href="https://www.freefullRSS.com/" target="_blank" rel="noopener">Full RSS</a>、<a href="https://feedex.net/" target="_blank" rel="noopener">FeedEx</a><br>3、对于含图片的RSS，由于kindlegen不负责远程渲染媒体文件，所以需要自行爬取图片到本地</p><hr><p>RSS相关：<br><a href="http://ctrlq.org/RSS/" target="_blank" rel="noopener">RSS search Engine</a><br><a href="http://www.feed43.com/" target="_blank" rel="noopener">feed43</a><br><a href="http://www.feeddiy.com/" target="_blank" rel="noopener">Free online RSS generator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简易信息聚合(Really Simple Syndication, RSS)是一种基于XML标准在互联网上被广泛采用的内容包装和投递协议。RSS允许用户以计算机可读的标准格式来获取（订阅）网站内容更新。相对于直接访问网站，使用Rss订阅能更快地&lt;br&gt;获取网站内容更新。RSS具有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来源多样的个性化“聚合”特性。&lt;/li&gt;
&lt;li&gt;信息发布的时效、低成本特性。&lt;/li&gt;
&lt;li&gt;无“垃圾”信息、便利的本地内容管理特性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
      <category term="RSS" scheme="http://blog365.top/tags/RSS/"/>
    
      <category term="kindle" scheme="http://blog365.top/tags/kindle/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Python3(与Python2共存)</title>
    <link href="http://blog365.top/2018/04/15/linux%E5%AE%89%E8%A3%85python3-%E4%B8%8Epython2%E5%85%B1%E5%AD%98/"/>
    <id>http://blog365.top/2018/04/15/linux安装python3-与python2共存/</id>
    <published>2018-04-15T14:30:05.000Z</published>
    <updated>2018-05-16T14:04:42.551Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS默认安装的是Python2.7.x，对于需要Python3的场合，需要自行安装，这里给出在CentOS7.6上安装Python3的步骤。由于系统对默认的Python2.7.x有依赖，所以我们尽量不改变原有版本。</p><p>环境：CentOS7.6，默认Python2.7.5</p><a id="more"></a><hr><h2 id="1、安装依赖环境"><a href="#1、安装依赖环境" class="headerlink" title="1、安装依赖环境"></a>1、安装依赖环境</h2><blockquote><p>sudo yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</p></blockquote><h2 id="2、下载python3"><a href="#2、下载python3" class="headerlink" title="2、下载python3"></a>2、下载python3</h2><blockquote><p>sudo wget <a href="https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz</a></p></blockquote><h2 id="3、为python3创建安装目录"><a href="#3、为python3创建安装目录" class="headerlink" title="3、为python3创建安装目录"></a>3、为python3创建安装目录</h2><blockquote><p>sudo mkdir /usr/local/python3 </p></blockquote><h2 id="4、解压并切换到安装文件中"><a href="#4、解压并切换到安装文件中" class="headerlink" title="4、解压并切换到安装文件中"></a>4、解压并切换到安装文件中</h2><blockquote><p>sudo tar -zxvf Python-3.6.2.tgz<br>sudo cd Python-3.6.2</p></blockquote><h2 id="5、配置并安装"><a href="#5、配置并安装" class="headerlink" title="5、配置并安装"></a>5、配置并安装</h2><blockquote><p>sudo ./configure –prefix=/usr/local/python3<br>sudo make &amp;&amp; make install</p></blockquote><h2 id="6、创建python3、pip3软连接"><a href="#6、创建python3、pip3软连接" class="headerlink" title="6、创建python3、pip3软连接"></a>6、创建python3、pip3软连接</h2><blockquote><p>sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3<br>sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip3</p></blockquote><h2 id="7、将python默认设置为python3"><a href="#7、将python默认设置为python3" class="headerlink" title="7、将python默认设置为python3"></a>7、将python默认设置为python3</h2><blockquote><p>sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python<br>sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip<br>sudo vi /usr/bin/yum 将第一行的”#!/usr/bin/python” 改为 “#!/usr/bin/python2”<br>sudo vi /usr/libexec/urlgrabber-ext-down 将第一行的”#!/usr/bin/python” 改为 “#!/usr/bin/python2”<br>运行yum，不报错即配置完成。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS默认安装的是Python2.7.x，对于需要Python3的场合，需要自行安装，这里给出在CentOS7.6上安装Python3的步骤。由于系统对默认的Python2.7.x有依赖，所以我们尽量不改变原有版本。&lt;/p&gt;
&lt;p&gt;环境：CentOS7.6，默认Python2.7.5&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog365.top/tags/Python/"/>
    
      <category term="Linux" scheme="http://blog365.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>分享一个kindle电子书免费下载网站</title>
    <link href="http://blog365.top/2018/04/01/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AAkindle%E7%94%B5%E5%AD%90%E4%B9%A6%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99/"/>
    <id>http://blog365.top/2018/04/01/分享一个kindle电子书免费下载网站/</id>
    <published>2018-04-01T14:57:34.000Z</published>
    <updated>2018-04-08T06:26:12.572Z</updated>
    
    <content type="html"><![CDATA[<p>自从买了kindle之后，看的书的确多了起来，现在基本养成了每天睡前看半小时书的习惯，古人云：腹有诗书气自华。多读书毕竟是有好处的！Amazon电子书商店有好多书籍可供下载，包括一些免费的电子书还有定期推出的特价电子书。但是里面的书籍毕竟有限，特别是中文书。<br>为了解决找书不便的问题，本人建了一个图书搜索网站：<a href="http://kindle.archiew.top" target="_blank" rel="noopener">书舟网</a>，这是一个很简洁高效的电子书检索下载网站，界面如下：</p><a id="more"></a><hr><p><img src="http://upload-images.jianshu.io/upload_images/2321566-678d87ddf39a7747.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网站首页"><br>里面现有书籍四万余册，而且每天都有更新！<br>如果觉得好用，请点击页面分享按钮，分享给朋友们吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从买了kindle之后，看的书的确多了起来，现在基本养成了每天睡前看半小时书的习惯，古人云：腹有诗书气自华。多读书毕竟是有好处的！Amazon电子书商店有好多书籍可供下载，包括一些免费的电子书还有定期推出的特价电子书。但是里面的书籍毕竟有限，特别是中文书。&lt;br&gt;为了解决找书不便的问题，本人建了一个图书搜索网站：&lt;a href=&quot;http://kindle.archiew.top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书舟网&lt;/a&gt;，这是一个很简洁高效的电子书检索下载网站，界面如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="分享" scheme="http://blog365.top/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="http://blog365.top/2018/04/01/Test/"/>
    <id>http://blog365.top/2018/04/01/Test/</id>
    <published>2018-04-01T13:13:22.000Z</published>
    <updated>2018-04-18T14:43:12.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Test123"><a href="#Test123" class="headerlink" title="Test123"></a>Test123</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Test123&quot;&gt;&lt;a href=&quot;#Test123&quot; class=&quot;headerlink&quot; title=&quot;Test123&quot;&gt;&lt;/a&gt;Test123&lt;/h2&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; m
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://blog365.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>

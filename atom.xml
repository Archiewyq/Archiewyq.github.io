<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Archiew&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/51d9bfd6e3a8e42ee493acb38f2ec057</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.archiew.top/"/>
  <updated>2019-01-13T13:35:05.066Z</updated>
  <id>http://blog.archiew.top/</id>
  
  <author>
    <name>archiew</name>
    <email>archiew.top@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django整合Celery实现异步任务</title>
    <link href="http://blog.archiew.top/2019/01/13/Django%E6%95%B4%E5%90%88Celery%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>http://blog.archiew.top/2019/01/13/Django整合Celery实现异步任务/</id>
    <published>2019-01-13T10:14:16.000Z</published>
    <updated>2019-01-13T13:35:05.066Z</updated>
    
    <content type="html"><![CDATA[<p>由于自制的<a href="http://kindle.archiew.top" target="_blank" rel="noopener">电子书网站</a>需要新增电子书推送的功能，推送的意思实际上就是发送电子书附件到用户指定的邮箱，推送的过程需要消耗一定的时间，同时考虑到自己的服务器上不存储电子书，需要首先将电子书缓存到本地服务器再执行推送，所以服务器端不能直接同步执行此任务。查了一点资料了解到可以通过Celer来实现此项功能，而网上关于Django和Celery整合的讲解并不清楚，所以在这里做一详细的使用说明记录。<br><a id="more"></a><br><a href="http://docs.celeryproject.org/en/master/index.html" target="_blank" rel="noopener">Celery</a>是一个强大的分布式任务队列，它可以让任务的执行完全脱离主程序，甚至可以被分配到其他的主机上运行，一般被用来实现异步任务(asyn task)和定时任务(crontab)，它的架构组成如下图：<br><a href="http://pic.blog.archiew.top/image/Celery架构示意图.png" target="_blank" rel="noopener">Celery架构示意图</a><br>一个完整的Celery任务包含以下4个模块：</p><blockquote><p>Task:任务模块，包含异步任务(Async Task)和定时任务(Celery Beat)；<br> Broker:消息中间件，实际上是个任务调度队列，接收任务模块发过来的消息(即任务)，将其存入队列，Celery本身不提供队列服务，需要借助第三方实现，官方推荐使用RabbitMQ和Redis，实际上Mysql、MongoDB等也是可以的；<br> Worker:任务执行模块，负责实时监控消息队列，获取队列中的任务并执行；<br> Backend:任务执行结果存储模块，用以存储任务的执行结果，以供查询。同消息中间件一样，可以使用RabbitMQ和Redis等。</p></blockquote><p><strong>本次使用的是Celery的异步任务功能，所以下面着重是异步任务的使用说明。</strong></p><p>一个Celery任务的执行步骤为：</p><blockquote><p>创建一个Celery实例——&gt;启动一个异步任务(通常在业务逻辑层触发)——&gt;任务被发往消息中间件并被调度——&gt;任务执行模块获取任务并执行它——&gt;执行结果被存储。</p></blockquote><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><blockquote><p>CentOS Linux release 7.5.1804 (Core)<br> Django1.11<br> Python3.6<br> Celery3.1.26<br> Django-celery3.2.2<br> RabbitMQ3.3.5(在这里Broker和Backend都使用的是RabbitMQ)</p></blockquote><h2 id="配置Celery环境"><a href="#配置Celery环境" class="headerlink" title="配置Celery环境"></a>配置Celery环境</h2><p>修改Django项目的<code>settings.py</code>文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> djcelery</span><br><span class="line"></span><br><span class="line">djcelery.setup_loader() <span class="comment">#加载配置</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://guest@localhost//'</span>             <span class="comment"># RabbitMQ的配置，如使用的是其他，请做相应配置，下同</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'amqp://guest@localhost//'</span></span><br><span class="line">CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span> <span class="comment">#时区设置不对会影响定时任务的执行</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS - (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'djcelery'</span>, <span class="comment">#增加djcelery应用</span></span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="创建celery-py文件并修改init-py"><a href="#创建celery-py文件并修改init-py" class="headerlink" title="创建celery.py文件并修改init.py"></a>创建celery.py文件并修改<strong>init</strong>.py</h2><p>在<code>settings.py</code>文件同目录下(也即Django项目文件目录下)创建<code>celery.py</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import  <span class="comment"># 注意必须放在文件最前面</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> kindle.settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the default Django settings module for the 'celery' program.</span></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'xxx.settings'</span>) <span class="comment"># xxx为Django(注意不是app)项目</span></span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'xxx'</span>) <span class="comment"># xxx同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a string here means the worker doesn't have to serialize</span></span><br><span class="line"><span class="comment"># the configuration object to child processes.</span></span><br><span class="line"><span class="comment"># - namespace='CELERY' means all celery-related configuration keys</span></span><br><span class="line"><span class="comment">#   should have a `CELERY_` prefix.</span></span><br><span class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load task modules from all registered Django app configs.</span></span><br><span class="line">app.autodiscover_tasks(<span class="keyword">lambda</span>: xxx.settings.INSTALLED_APPS) <span class="comment"># xxx同上，这句意思是遍历Django项目下所有app下的tasks(也就是说，对于有多个app的Django项目，每个app可以创建自己的tasks)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(bind=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_task</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Request: &#123;0!r&#125;'</span>.format(self.request))</span><br></pre></td></tr></table></figure></p><p>修改同一目录下的<code>__init__.py</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">__all__ = (<span class="string">'celery_app'</span>,)</span><br></pre></td></tr></table></figure></p><h2 id="创建tasks-py"><a href="#创建tasks-py" class="headerlink" title="创建tasks.py"></a>创建tasks.py</h2><p>在需要tasks的app目录下创建<code>tasks.py</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task, platforms</span><br><span class="line"></span><br><span class="line">platforms.C_FORCE_ROOT = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 编写自己的task</span></span><br><span class="line">    <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure></p><h2 id="同步数据库"><a href="#同步数据库" class="headerlink" title="同步数据库"></a>同步数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h2 id="启动celery-worker进程"><a href="#启动celery-worker进程" class="headerlink" title="启动celery worker进程"></a>启动celery worker进程</h2><p>注意首先还要启动RabbitMQ-server和Django项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py celery worker -c 6 -l debug</span><br></pre></td></tr></table></figure></p><p>启动后通过终端Terminal就可以看到celery的执行效果了。但是一旦断开terminal连接，celery也随之断开，这在实际使用中是不行的，所以还要解决celery后台运行的问题。</p><h2 id="Celery后台运行"><a href="#Celery后台运行" class="headerlink" title="Celery后台运行"></a>Celery后台运行</h2><p>有关Celery后台运行的说明，官方有介绍：<a href="http://docs.celeryproject.org/en/latest/userguide/daemonizing.html" target="_blank" rel="noopener">Daemonization</a>，有多种方法可以实现Celery的后台运行，在这里只使用其中一种方法：<a href="http://docs.celeryproject.org/en/latest/userguide/daemonizing.html#id5" target="_blank" rel="noopener">Generic init-scripts</a><br>首先，创建<code>/etc/init.d/celeryd</code>文件，并写入以下内容：<a href="https://github.com/celery/celery/blob/3.1/extra/generic-init.d/celeryd" target="_blank" rel="noopener">https://github.com/celery/celery/blob/3.1/extra/generic-init.d/celeryd</a><br>然后，创建配置文件<code>/etc/default/celeryd</code>，并写入以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Names of nodes to start</span><br><span class="line">#   most people will only start one node:</span><br><span class="line">CELERYD_NODES=&quot;worker&quot;</span><br><span class="line">#   but you can also start multiple and configure settings</span><br><span class="line">#   for each in CELERYD_OPTS</span><br><span class="line">#CELERYD_NODES=&quot;worker1 worker2 worker3&quot;</span><br><span class="line">#   alternatively, you can specify the number of nodes to start:</span><br><span class="line">#CELERYD_NODES=10</span><br><span class="line"># Absolute or relative path to the &apos;celery&apos; command:</span><br><span class="line">CELERY_BIN=&quot;xxx/env/bin/celery&quot;         # 需要修改为celery的安装bin路径</span><br><span class="line">#CELERY_BIN=&quot;/virtualenvs/def/bin/celery&quot;</span><br><span class="line"># App instance to use</span><br><span class="line"># comment out this line if you don&apos;t use an app</span><br><span class="line"># CELERY_APP=&quot;celery_tasks.main&quot;  # ====================celery 项目的相对路径</span><br><span class="line"># or fully qualified:</span><br><span class="line">CELERY_APP=&quot;xxx&quot;                        # 修改为Django项目名</span><br><span class="line"># Where to chdir at start.</span><br><span class="line">CELERYD_CHDIR=&quot;xxx&quot;                     # 修改为Django项目路径</span><br><span class="line"># Extra command-line arguments to the worker</span><br><span class="line">CELERYD_OPTS=&quot;--time-limit=300 --concurrency=8&quot;</span><br><span class="line"># Configure node-specific settings by appending node name to arguments:</span><br><span class="line">#CELERYD_OPTS=&quot;--time-limit=300 -c 8 -c:worker2 4 -c:worker3 2 -Ofair:worker1&quot;</span><br><span class="line"># Set logging level to DEBUG</span><br><span class="line">#CELERYD_LOG_LEVEL=&quot;DEBUG&quot;</span><br><span class="line"># %n will be replaced with the first part of the nodename.</span><br><span class="line">CELERYD_LOG_FILE=&quot;/home/Projects/launch_file/scripts/celery_worker.log&quot;</span><br><span class="line">CELERYD_PID_FILE=&quot;/home/Projects/launch_file/scripts/%n.pid&quot;</span><br><span class="line"># Workers should run as an unprivileged user.</span><br><span class="line">#   You need to create this user manually (or you can choose</span><br><span class="line">#   a user/group combination that already exists (e.g., nobody).</span><br><span class="line">CELERYD_USER=&quot;root&quot;</span><br><span class="line">CELERYD_GROUP=&quot;root&quot;</span><br><span class="line"># If enabled pid and log directories will be created if missing,</span><br><span class="line"># and owned by the userid/group configured.</span><br><span class="line">CELERY_CREATE_DIRS=1</span><br></pre></td></tr></table></figure></p><p>然后就可以通过<code>/etc/init.d/celeryd {start|stop|restart|status}</code>命令来实现Celery的启动、停止、重启和状态查询了，这里启动后就可以后台运行了。</p><ul><li>为了避免开机时需要手动启动，可以将启动命令添加为开机执行。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yeyingcai/article/details/78647553" target="_blank" rel="noopener">django+django-celery+celery的整合</a><br><a href="http://docs.celeryproject.org/en/latest/userguide/daemonizing.html" target="_blank" rel="noopener">Celery 4.2.0 documentation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于自制的&lt;a href=&quot;http://kindle.archiew.top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电子书网站&lt;/a&gt;需要新增电子书推送的功能，推送的意思实际上就是发送电子书附件到用户指定的邮箱，推送的过程需要消耗一定的时间，同时考虑到自己的服务器上不存储电子书，需要首先将电子书缓存到本地服务器再执行推送，所以服务器端不能直接同步执行此任务。查了一点资料了解到可以通过Celer来实现此项功能，而网上关于Django和Celery整合的讲解并不清楚，所以在这里做一详细的使用说明记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.archiew.top/tags/Python/"/>
    
      <category term="Django" scheme="http://blog.archiew.top/tags/Django/"/>
    
      <category term="Celery" scheme="http://blog.archiew.top/tags/Celery/"/>
    
      <category term="异步任务" scheme="http://blog.archiew.top/tags/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>12306抢票程序</title>
    <link href="http://blog.archiew.top/2019/01/06/12306%E6%8A%A2%E7%A5%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://blog.archiew.top/2019/01/06/12306抢票程序/</id>
    <published>2019-01-06T11:18:51.000Z</published>
    <updated>2019-01-06T11:36:23.764Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在一个公众号(Python知识圈)上看到有人用Python做了一个12306的抢票软件，比较感兴趣，就在他的基础上做了一点改进。<br><a id="more"></a><br>大体思路是这样的：利用自动化工具splinter结合chromedriver，自动检测页面元素并操作，登录验证码部分涉及到验证码的识别，为了简单起见，这部分需要人为输入验证码。<br>为了实现抢票，定义了一个抢票类<code>Buy_Tickets</code>，类成员变量存储用户抢票信息，类包含几个方法：</p><blockquote><p><code>start_buy</code>:实现买票功能<br><code>login</code>:实现用户登录<br><code>check_ticket</code>:实现余票检测<br><code>book_ticket</code>:实现订票<br><code>sendMail</code>:实现邮件通知</p></blockquote><p>支持用户登录，支持设定车次、乘车乘客(多个)、车票类型、乘车日期、车站、接收邮箱和刷票频率。</p><p><a href="https://github.com/Archiewyq/12306" target="_blank" rel="noopener">源码</a><br><a href="http://kindle.archiew.top/book/2kPQNM/" target="_blank" rel="noopener">可执行文件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在一个公众号(Python知识圈)上看到有人用Python做了一个12306的抢票软件，比较感兴趣，就在他的基础上做了一点改进。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.archiew.top/tags/Python/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于微信公众号开发中的token验证问题</title>
    <link href="http://blog.archiew.top/2018/12/29/%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%8D%E5%8A%A1%E5%99%A8token%E9%AA%8C%E8%AF%81%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.archiew.top/2018/12/29/关于微信公众号开发中服务器token验证问题/</id>
    <published>2018-12-29T09:30:02.000Z</published>
    <updated>2018-12-29T09:42:36.278Z</updated>
    
    <content type="html"><![CDATA[<p>微信公众号开发配置基本环境时需要服务器验证token，<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1472017492_58YV5" target="_blank" rel="noopener">官方文档</a>给出了验证token的步骤:<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># filename: handle.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = web.input()</span><br><span class="line">            <span class="keyword">if</span> len(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"hello, this is handle view"</span></span><br><span class="line">            signature = data.signature</span><br><span class="line">            timestamp = data.timestamp</span><br><span class="line">            nonce = data.nonce</span><br><span class="line">            echostr = data.echostr</span><br><span class="line">            token = <span class="string">"xxxx"</span> <span class="comment">#请按照公众平台官网\基本配置中信息填写</span></span><br><span class="line"></span><br><span class="line">            list = [token, timestamp, nonce]</span><br><span class="line">            list.sort()</span><br><span class="line">            sha1 = hashlib.sha1()</span><br><span class="line">            map(sha1.update, list)</span><br><span class="line">            hashcode = sha1.hexdigest()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"handle/GET func: hashcode, signature: "</span>, hashcode, signature</span><br><span class="line">            <span class="keyword">if</span> hashcode == signature:</span><br><span class="line">                <span class="keyword">return</span> echostr</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">except</span> Exception, Argument:</span><br><span class="line">            <span class="keyword">return</span> Argument</span><br></pre></td></tr></table></figure></p><p>这段代码用Python2在服务器端进行token验证，由于我使用的是Python3，依照官方给出的这段验证代码，一直无法验证成功，调试发现：服务器获得的微信发过来的请求参数都没有问题，但是sha1加密后的字符串始终不对，应该是加密部分出了问题（Python2/3中hashlib应该是不兼容的）。查了一下(<a href="https://www.cnblogs.com/zhujincheng/p/10075046.html" target="_blank" rel="noopener">参考</a>)，果然，有两点需要注意：</p><blockquote><p>在py2中不用对字符encode()编码，py3中必须encode()编码否则sha1.hexdigest()答案将不是你想要的。<br> 在py3中 必须对map使用list 或tuple或循环输出才会得到正确答案。</p></blockquote><p>修改Python3的token验证代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">list = [token, timestamp, nonce]</span><br><span class="line">list.sort()</span><br><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">list(map(sha1.update,[x.encode() <span class="keyword">for</span> x <span class="keyword">in</span> lis ]))</span><br><span class="line">hashcode = sha1.hexdigest()</span><br><span class="line"><span class="comment"># print("handle/GET func: hashcode, signature: ", hashcode, signature)</span></span><br><span class="line"><span class="keyword">if</span> hashcode == signature:</span><br><span class="line">    <span class="keyword">return</span> echostr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信公众号开发配置基本环境时需要服务器验证token，&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1472017492_58YV5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;给出了验证token的步骤:&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.archiew.top/tags/Python/"/>
    
      <category term="微信公众号开发" scheme="http://blog.archiew.top/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>网易云音乐歌曲评论可视化分析</title>
    <link href="http://blog.archiew.top/2018/12/16/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%AD%8C%E6%9B%B2%E8%AF%84%E8%AE%BA%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://blog.archiew.top/2018/12/16/网易云音乐歌曲评论可视化分析/</id>
    <published>2018-12-16T13:18:33.000Z</published>
    <updated>2018-12-21T01:47:34.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据爬取"><a href="#1-数据爬取" class="headerlink" title="1. 数据爬取"></a>1. 数据爬取</h1><p>爬虫部分主要是调用官方API，本次用到的API主要有两个：</p><blockquote><p>获取评论:<br><a href="http://music.163.com/api/v1/resource/comments/R_SO_4_{歌曲ID}?limit={每页限制数量}&amp;offset={评论数总偏移}" target="_blank" rel="noopener">http://music.163.com/api/v1/resource/comments/R_SO_4_{歌曲ID}?limit={每页限制数量}&amp;offset={评论数总偏移}</a> </p></blockquote><blockquote><p>获取评论对应用户的信息:<br><a href="https://music.163.com/api/v1/user/detail/{用户ID}" target="_blank" rel="noopener">https://music.163.com/api/v1/user/detail/{用户ID}</a></p></blockquote><p>工具：<br>Python3.6<br>sublime3<br>MySQL(数据存储)<br><del>scrapy(数据清洗)</del><br>pyecharts(可视化工具库)</p><p><strong>* 关于网易云音乐官方API，后期会整理一下做个汇总放在GitHub上。</strong><br><a id="more"></a></p><h2 id="1-1-评论爬取"><a href="#1-1-评论爬取" class="headerlink" title="1.1 评论爬取"></a>1.1 评论爬取</h2><p>实际操作过程中，网易云官方对于API的请求是有限制的，有条件的可以采用更换代理IP来防反爬，本次采用的是单线程爬取，所以IP封的并不太频繁，后面会对代码进行重构，实现<strong>多线程</strong>+<strong>更换IP</strong>来加快爬取速度。</p><p>根据获取评论的API，请求URL有3个可变部分：歌曲ID、每页限制数limit和评论总偏移量offset，通过API分析得知：当<code>offeset=0</code>时，返回json数据中包含有评论总数量<code>total</code>，所以根据API可设计爬虫如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="comment"># python3.6</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ROOT_URL = <span class="string">'http://music.163.com/api/v1/resource/comments/R_SO_4_%s?limit=%s&amp;offset=%s'</span></span><br><span class="line">LIMIT_NUMS = <span class="number">50</span> <span class="comment"># 每页限制爬取数</span></span><br><span class="line">DATABASE = <span class="string">''</span>   <span class="comment"># 数据库名</span></span><br><span class="line">TABLE = <span class="string">''</span>  <span class="comment"># 数据库表名</span></span><br><span class="line"><span class="comment"># 数据表设计如下：</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">id(int)             commentId(varchar) </span></span><br><span class="line"><span class="string">content(text)       likedCount(int) </span></span><br><span class="line"><span class="string">userId(varchar) time(datetime)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">PATTERN = re.compile(<span class="string">r'[\n\t\r\/]'</span>) <span class="comment"># 替换掉评论中的特殊字符以防插入数据库时报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> url:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36'</span>,</span><br><span class="line">            <span class="string">"Host"</span>: <span class="string">"music.163.com"</span>,</span><br><span class="line">&#125;</span><br><span class="line">    print(<span class="string">'Crawling&gt;&gt;&gt; '</span> + url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        req = request.Request(url, headers=headers)</span><br><span class="line">        content = request.urlopen(req).read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        js = json.loads(content)</span><br><span class="line">        total = int(js[<span class="string">'total'</span>])</span><br><span class="line">        datas = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> js[<span class="string">'comments'</span>]:</span><br><span class="line">            data = dict()</span><br><span class="line">            data[<span class="string">'commentId'</span>] = c[<span class="string">'commentId'</span>]</span><br><span class="line">            data[<span class="string">'content'</span>] = PATTERN.sub(<span class="string">''</span>, c[<span class="string">'content'</span>])</span><br><span class="line">            data[<span class="string">'time'</span>] = datetime.fromtimestamp(c[<span class="string">'time'</span>]//<span class="number">1000</span>)</span><br><span class="line">            data[<span class="string">'likedCount'</span>] = c[<span class="string">'likedCount'</span>]</span><br><span class="line">            data[<span class="string">'userId'</span>] = c[<span class="string">'user'</span>][<span class="string">'userId'</span>]</span><br><span class="line">            datas.append(data)</span><br><span class="line">        <span class="keyword">return</span> total, datas</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Down err&gt;&gt;&gt; '</span>, e)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveData</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'****'</span>, passwd=<span class="string">'****'</span>, db=<span class="string">'****'</span>, charset=<span class="string">'utf8mb4'</span>) <span class="comment"># 注意字符集要设为utf8mb4，以支持存储评论中的emoji表情</span></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    sql = <span class="string">'insert into '</span> + TABLE + <span class="string">' (id,commentId,content,likedCount,time,userId) VALUES (%s,%s,%s,%s,%s,%s)'</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(<span class="string">'SELECT max(id) FROM '</span>+TABLE)</span><br><span class="line">            id_ = cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">            cursor.execute(sql, (id_+<span class="number">1</span>,d[<span class="string">'commentId'</span>], d[<span class="string">'content'</span>], d[<span class="string">'likedCount'</span>], d[<span class="string">'time'</span>], d[<span class="string">'userId'</span>]))</span><br><span class="line">            conn.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'mysql err&gt;&gt;&gt; '</span>,d[<span class="string">'commentId'</span>],e)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    songId = input(<span class="string">'歌曲ID：'</span>).strip()</span><br><span class="line">    total,data = getData(ROOT_URL%(songId, LIMIT_NUMS, <span class="number">0</span>))</span><br><span class="line">    saveData(data)</span><br><span class="line">    <span class="keyword">if</span> total:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, total//EVERY_PAGE_NUMS+<span class="number">1</span>):</span><br><span class="line">                _, data = getData(ROOT_URL%(songId, LIMIT_NUMS, i*(LIMIT_NUMS)))</span><br><span class="line">                saveData(data)</span><br></pre></td></tr></table></figure></p><p>以上代码实现了单线程爬取网易云音乐某首歌曲的评论并存储进数据库（在这里其实有个坑！！！不过不影响，后面会讲到）。实际上，API返回的不仅仅包含代码中所提到的信息，具体可自行测试，我们还想要得到评论对应的用户的具体信息，但是这个API返回的用户信息不全面，所以接下来，针对评论对应的用户信息进行抓取。</p><h2 id="1-2-用户信息爬取"><a href="#1-2-用户信息爬取" class="headerlink" title="1.2 用户信息爬取"></a>1.2 用户信息爬取</h2><p>根据获取用户信息的API，请求URL有1个可变部分：用户ID，前一部分已经将每条评论对应的用户ID也存储下来，这里只需要从数据库取用户ID并抓取信息即可，所以根据API可设计爬虫如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="comment"># python3.6</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ROOT_URL = <span class="string">'https://music.163.com/api/v1/user/detail/'</span></span><br><span class="line">DATABASE = <span class="string">'****'</span></span><br><span class="line">TABLE_USERS = <span class="string">'****'</span></span><br><span class="line">TABLE_COMMENTS = <span class="string">'****'</span></span><br><span class="line"><span class="comment"># 数据表设计如下：</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">id(int)             userId(varchar)</span></span><br><span class="line"><span class="string">gender(char)        userName(varchar</span></span><br><span class="line"><span class="string">age(int)            level(int)</span></span><br><span class="line"><span class="string">city(varchar)       sign(text)</span></span><br><span class="line"><span class="string">eventCount(int) followedCount(int)</span></span><br><span class="line"><span class="string">followsCount(int)   recordCount(int)</span></span><br><span class="line"><span class="string">avatar(varchar)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">PATTERN = re.compile(<span class="string">r'[\n\t\r\/]'</span>) <span class="comment"># 替换掉签名中的特殊字符以防插入数据库时报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> url:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    print(<span class="string">'Crawling&gt;&gt;&gt; '</span> + url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        req = request.Request(url, headers=headers)</span><br><span class="line">        content = request.urlopen(req).read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        js = json.loads(content)</span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> js[<span class="string">'code'</span>] == <span class="number">200</span>:</span><br><span class="line">            data[<span class="string">'userId'</span>] = js[<span class="string">'profile'</span>][<span class="string">'userId'</span>]</span><br><span class="line">            data[<span class="string">'userName'</span>] = js[<span class="string">'profile'</span>][<span class="string">'nickname'</span>]</span><br><span class="line">            data[<span class="string">'avatar'</span>] = js[<span class="string">'profile'</span>][<span class="string">'avatarUrl'</span>]</span><br><span class="line">            data[<span class="string">'gender'</span>] = js[<span class="string">'profile'</span>][<span class="string">'gender'</span>]</span><br><span class="line">            <span class="keyword">if</span> int(js[<span class="string">'profile'</span>][<span class="string">'birthday'</span>])&lt;<span class="number">0</span>:</span><br><span class="line">                data[<span class="string">'age'</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                data[<span class="string">'age'</span>] =(<span class="number">2018</span><span class="number">-1970</span>)-(int(js[<span class="string">'profile'</span>][<span class="string">'birthday'</span>])//(<span class="number">1000</span>*<span class="number">365</span>*<span class="number">24</span>*<span class="number">3600</span>))</span><br><span class="line">            <span class="keyword">if</span> int(data[<span class="string">'age'</span>])&lt;<span class="number">0</span>:</span><br><span class="line">                data[<span class="string">'age'</span>] = <span class="number">0</span></span><br><span class="line">            data[<span class="string">'level'</span>] = js[<span class="string">'level'</span>]</span><br><span class="line">            data[<span class="string">'sign'</span>] = PATTERN.sub(<span class="string">' '</span>, js[<span class="string">'profile'</span>][<span class="string">'signature'</span>])</span><br><span class="line">            data[<span class="string">'eventCount'</span>] = js[<span class="string">'profile'</span>][<span class="string">'eventCount'</span>]</span><br><span class="line">            data[<span class="string">'followCount'</span>] = js[<span class="string">'profile'</span>][<span class="string">'follows'</span>]</span><br><span class="line">            data[<span class="string">'fanCount'</span>] = js[<span class="string">'profile'</span>][<span class="string">'followeds'</span>]</span><br><span class="line">            data[<span class="string">'city'</span>] = js[<span class="string">'profile'</span>][<span class="string">'city'</span>]</span><br><span class="line">            data[<span class="string">'recordCount'</span>] = js[<span class="string">'listenSongs'</span>]</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Down err&gt;&gt;&gt; '</span>, e)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveData</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'****'</span>, passwd=<span class="string">'****'</span>, db=DATABASE, charset=<span class="string">'utf8mb4'</span>) <span class="comment"># 注意字符集要设为utf8mb4，以支持存储签名中的emoji表情</span></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    sql = <span class="string">'insert into '</span> + TABLE + <span class="string">' (id,userName,gender,age,level,city,sign,eventCount,followsCount,followedCount,recordCount,avatar,userId) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(<span class="string">'SELECT max(id) FROM '</span>+TABLE_USERS)</span><br><span class="line">        id_ = cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">        cursor.execute(sql, (id_+<span class="number">1</span>,data[<span class="string">'userName'</span>],data[<span class="string">'gender'</span>],data[<span class="string">'age'</span>],data[<span class="string">'level'</span>],data[<span class="string">'city'</span>],data[<span class="string">'sign'</span>],data[<span class="string">'eventCount'</span>],data[<span class="string">'followsCount'</span>],data[<span class="string">'followedCount'</span>],data[<span class="string">'recordCount'</span>],data[<span class="string">'avatar'</span>],data[<span class="string">'userId'</span>]))</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'mysql err&gt;&gt;&gt; '</span>,data[<span class="string">'userId'</span>],e)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        cursor.close()</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getID</span><span class="params">()</span>:</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'****'</span>, passwd=<span class="string">'****'</span>, db=DATABASE, charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    sql = <span class="string">'SELECT userId FROM '</span>+TABLE_COMMENTS</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        res = cursor.fetchall()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'get err&gt;&gt;&gt; '</span>, e)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        cursor.close()</span><br><span class="line">        conn.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    usersID = getID()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> usersID:</span><br><span class="line">        data = getData(ROOT_URL+i[<span class="number">0</span>].strip())</span><br><span class="line">        saveData(data)</span><br></pre></td></tr></table></figure></p><p>以上代码实现了单线程爬取网易云音乐用户信息并存储进数据库。至此，已经完成了歌曲评论和对应用户信息的抓取。接下来，对抓取到的数据进行清洗及可视化分析。<br><img src="http://pic.blog.archiew.top/image/sxj评论数据.png" alt="抓取到的评论数据"><br><img src="http://pic.blog.archiew.top/image/sxj用户信息数据.png" alt="抓取到的用户信息数据"></p><h1 id="2-数据清洗-amp-可视化"><a href="#2-数据清洗-amp-可视化" class="headerlink" title="2. 数据清洗 &amp; 可视化"></a>2. 数据清洗 &amp; 可视化</h1><p>关于数据的清洗，实际上在上一部分抓取数据的过程中已经做了一部分，包括：后台返回的空用户信息、重复数据的去重等。除此之外，还要进行一些清洗：用户年龄错误、用户城市编码转换等。</p><blockquote><p>关于数据的去重，评论部分可以以sommentId为数据库索引，利用数据库来自动去重；用户信息部分以用户ID为数据库索引实现自动去重。</p></blockquote><blockquote><p>API返回的用户年龄一般是时间戳的形式(以毫秒计)、有时候也会返回一个负值或者一个大于当前时间的值，暂时没有找到这两种值代表的含义，故而一律按0来处理。</p></blockquote><blockquote><p>API返回的用户信息中，城市分为province和city两个字段，本此分析中只保存了city字段。实际上字段值是一个城市code码，具体对照在<a href="https://download.csdn.net/download/u011371360/10855469" target="_blank" rel="noopener">这里下载</a>。</p></blockquote><p>在这部分，利用Python的数据处理库pandas进行数据处理，利用可视化库pyecharts进行数据可视化。处理代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="comment"># python3.6</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Bar,Pie,Line,Scatter,Map</span><br><span class="line"></span><br><span class="line">TABLE_COMMENTS = <span class="string">'****'</span></span><br><span class="line">TABLE_USERS = <span class="string">'****'</span></span><br><span class="line">DATABASE = <span class="string">'****'</span></span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'****'</span>, passwd=<span class="string">'****'</span>, db=DATABASE, charset=<span class="string">'utf8mb4'</span>)</span><br><span class="line">sql_users = <span class="string">'SELECT id,gender,age,city FROM '</span>+TABLE_USERS</span><br><span class="line">sql_comments = <span class="string">'SELECT id,time FROM '</span>+TABLE_COMMENTS</span><br><span class="line">comments = pd.read_sql(sql_comments, con=conn)</span><br><span class="line">users = pd.read_sql(sql_users, con=conn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评论时间(按天)分布分析</span></span><br><span class="line">comments_day = comments[<span class="string">'time'</span>].dt.date</span><br><span class="line">data = comments_day.id.groupby(comments_day[<span class="string">'time'</span>]).count()</span><br><span class="line">line = Line(<span class="string">'评论时间(按天)分布'</span>)</span><br><span class="line">line.use_theme(<span class="string">'dark'</span>)</span><br><span class="line">line.add(</span><br><span class="line">    <span class="string">''</span>,</span><br><span class="line">    data.index.values,</span><br><span class="line">    data.values,</span><br><span class="line">    is_fill=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">line.render(<span class="string">r'./评论时间(按天)分布.html'</span>)</span><br><span class="line"><span class="comment"># 评论时间(按小时)分布分析</span></span><br><span class="line">comments_hour = comments[<span class="string">'time'</span>].dt.hour</span><br><span class="line">data = comments_hour.id.groupby(comments_hour[<span class="string">'time'</span>]).count()</span><br><span class="line">line = Line(<span class="string">'评论时间(按小时)分布'</span>)</span><br><span class="line">line.use_theme(<span class="string">'dark'</span>)</span><br><span class="line">line.add(</span><br><span class="line">    <span class="string">''</span>,</span><br><span class="line">    data.index.values,</span><br><span class="line">    data.values,</span><br><span class="line">    is_fill=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">line.render(<span class="string">r'./评论时间(按小时)分布.html'</span>)</span><br><span class="line"><span class="comment"># 评论时间(按周)分布分析</span></span><br><span class="line">comments_week = comments[<span class="string">'time'</span>].dt.dayofweek</span><br><span class="line">data = comments_week.id.groupby(comments_week[<span class="string">'time'</span>]).count()</span><br><span class="line">line = Line(<span class="string">'评论时间(按周)分布'</span>)</span><br><span class="line">line.use_theme(<span class="string">'dark'</span>)</span><br><span class="line">line.add(</span><br><span class="line">    <span class="string">''</span>,</span><br><span class="line">    data.index.values,</span><br><span class="line">    data.values,</span><br><span class="line">    is_fill=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">line.render(<span class="string">r'./评论时间(按周)分布.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户年龄分布分析</span></span><br><span class="line">age = users[users[<span class="string">'age'</span>]&gt;<span class="number">0</span>] <span class="comment"># 清洗掉年龄小于1的数据</span></span><br><span class="line">age = age.id.groupby(age[<span class="string">'age'</span>]).count()    <span class="comment"># 以年龄值对数据分组</span></span><br><span class="line">Bar = Bar(<span class="string">'用户年龄分布'</span>)</span><br><span class="line">Bar.use_theme(<span class="string">'dark'</span>)</span><br><span class="line">Bar.add(</span><br><span class="line">    <span class="string">''</span>,</span><br><span class="line">    age.index.values,</span><br><span class="line">    age.values,</span><br><span class="line">    is_fill=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">Bar.render(<span class="string">r'./用户年龄分布图.html'</span>)   <span class="comment"># 生成渲染的html文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户地区分布分析</span></span><br><span class="line"><span class="comment"># 城市code编码转换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">city_group</span><span class="params">(cityCode)</span>:</span></span><br><span class="line">    city_map = &#123;</span><br><span class="line">        <span class="string">'11'</span>: <span class="string">'北京'</span>,</span><br><span class="line">        <span class="string">'12'</span>: <span class="string">'天津'</span>,</span><br><span class="line">        <span class="string">'31'</span>: <span class="string">'上海'</span>,</span><br><span class="line">        <span class="string">'50'</span>: <span class="string">'重庆'</span>,</span><br><span class="line">        <span class="string">'5e'</span>: <span class="string">'重庆'</span>,</span><br><span class="line">        <span class="string">'81'</span>: <span class="string">'香港'</span>,</span><br><span class="line">        <span class="string">'82'</span>: <span class="string">'澳门'</span>,</span><br><span class="line">        <span class="string">'13'</span>: <span class="string">'河北'</span>,</span><br><span class="line">        <span class="string">'14'</span>: <span class="string">'山西'</span>,</span><br><span class="line">        <span class="string">'15'</span>: <span class="string">'内蒙古'</span>,</span><br><span class="line">        <span class="string">'21'</span>: <span class="string">'辽宁'</span>,</span><br><span class="line">        <span class="string">'22'</span>: <span class="string">'吉林'</span>,</span><br><span class="line">        <span class="string">'23'</span>: <span class="string">'黑龙江'</span>,</span><br><span class="line">        <span class="string">'32'</span>: <span class="string">'江苏'</span>,</span><br><span class="line">        <span class="string">'33'</span>: <span class="string">'浙江'</span>,</span><br><span class="line">        <span class="string">'34'</span>: <span class="string">'安徽'</span>,</span><br><span class="line">        <span class="string">'35'</span>: <span class="string">'福建'</span>,</span><br><span class="line">        <span class="string">'36'</span>: <span class="string">'江西'</span>,</span><br><span class="line">        <span class="string">'37'</span>: <span class="string">'山东'</span>,</span><br><span class="line">        <span class="string">'41'</span>: <span class="string">'河南'</span>,</span><br><span class="line">        <span class="string">'42'</span>: <span class="string">'湖北'</span>,</span><br><span class="line">        <span class="string">'43'</span>: <span class="string">'湖南'</span>,</span><br><span class="line">        <span class="string">'44'</span>: <span class="string">'广东'</span>,</span><br><span class="line">        <span class="string">'45'</span>: <span class="string">'广西'</span>,</span><br><span class="line">        <span class="string">'46'</span>: <span class="string">'海南'</span>,</span><br><span class="line">        <span class="string">'51'</span>: <span class="string">'四川'</span>,</span><br><span class="line">        <span class="string">'52'</span>: <span class="string">'贵州'</span>,</span><br><span class="line">        <span class="string">'53'</span>: <span class="string">'云南'</span>,</span><br><span class="line">        <span class="string">'54'</span>: <span class="string">'西藏'</span>,</span><br><span class="line">        <span class="string">'61'</span>: <span class="string">'陕西'</span>,</span><br><span class="line">        <span class="string">'62'</span>: <span class="string">'甘肃'</span>,</span><br><span class="line">        <span class="string">'63'</span>: <span class="string">'青海'</span>,</span><br><span class="line">        <span class="string">'64'</span>: <span class="string">'宁夏'</span>,</span><br><span class="line">        <span class="string">'65'</span>: <span class="string">'新疆'</span>,</span><br><span class="line">        <span class="string">'71'</span>: <span class="string">'台湾'</span>,</span><br><span class="line">        <span class="string">'10'</span>: <span class="string">'其他'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> city_map[cityCode[:<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">city = users[<span class="string">'city'</span>].apply(city_group)</span><br><span class="line">city = city.id.groupby(city[<span class="string">'city'</span>]).count()</span><br><span class="line">map_ = Map(<span class="string">'用户地区分布图'</span>)</span><br><span class="line">map_.add(</span><br><span class="line">    <span class="string">''</span>,</span><br><span class="line">    city.index.values,</span><br><span class="line">    city.values,</span><br><span class="line">    maptype=<span class="string">'china'</span>,</span><br><span class="line">    is_visualmap=<span class="keyword">True</span>,</span><br><span class="line">    visual_text_color=<span class="string">'#000'</span>,</span><br><span class="line">    is_label_show=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">map_.render(<span class="string">r'./用户地区分布图.html'</span>)</span><br></pre></td></tr></table></figure></p><p>以上，是对抓取到的数据采用可视化库pyecharts进行可视化分析，得到的结果如下：<br><img src="http://pic.blog.archiew.top/image/sxj%E8%AF%84%E8%AE%BA%E6%95%B0%E6%97%B6%E9%97%B4%28%E6%8C%89%E5%A4%A9%29%E5%88%86%E5%B8%83.png" alt="评论数时间-按天分布"><br><img src="http://pic.blog.archiew.top/image/sxj%E8%AF%84%E8%AE%BA%E6%95%B0%E6%97%B6%E9%97%B4%28%E6%8C%89%E5%91%A8%29%E5%88%86%E5%B8%83.png" alt="评论数时间-按周-分布"></p><blockquote><p>评论时间按周分布图可以看出，评论数在一周当中前面较少，后面逐渐增多，这可以解释为往后接近周末，大家有更多时间来听听歌、刷刷歌评，而一旦周末过完，评论量马上下降（周日到周一的下降过渡），大家又回归到工作当中。</p></blockquote><p><img src="http://pic.blog.archiew.top/image/sxj%E8%AF%84%E8%AE%BA%E6%95%B0%E6%97%B6%E9%97%B4%28%E6%8C%89%E5%B0%8F%E6%97%B6%29%E5%88%86%E5%B8%83.png" alt="评论数时间-按小时-分布"></p><blockquote><p>评论时间按小时分布图可以看出，评论数在一天当中有两个小高峰：11点-13点和22点-0点。这可以解释为用户在中午午饭时间和晚上下班(课)在家时间有更多的时间来听歌刷评论，符合用户的日常。至于为什么早上没有出现一个小高峰，大概是早上大家都在抢时间上班(学)，没有多少时间去刷评论。</p></blockquote><p><img src="http://pic.blog.archiew.top/image/sxj用户年龄分布.png" alt="用户年龄分布"></p><blockquote><p>用户年龄分布图可以看出，用户大多集中在14-30岁之间，以20岁左右居多，除去虚假年龄之外，这个年龄分布也符合网易云用户的年龄段。图中可以看出28岁有个高峰，猜测可能是包含了一些异常数据，有兴趣的化可以做进一步分析。</p></blockquote><p><img src="http://pic.blog.archiew.top/image/sxj用户地区分布图.png" alt="用户地区分布"></p><blockquote><p>用户地区分布图可以看出，用户涵盖了全国各大省份，因为中间数据(坑)的缺失，并没有展现出哪个省份特别突出的情况。对别的歌评(完全数据)的可视化分析，可以看出明显的地区分布差异。</p></blockquote><p>** 接下来说说前面提到的<strong>坑</strong>！！！<br>细心观察评论数(按天)分布那张图，发现2017年到2018年间有很大一部分数据缺失，这实际上是因为在数据抓取过程中出现的问题。研究了一下发现，根据获取歌曲评论的API，实际上每首歌最多只能获得2w条左右(去重后)的评论，对于评论数超过2w的歌曲，只能获得前后(日期)各1w条评论，而且这个限制对于网易云官网也是存在的，具体表现为：对一首评论数超过2w的歌，如果一直往后浏览评论，会发现从第500页(网页端网易云每页20条评论)往后，后台返回的内容和第500页完全一样，从后往前同理。这应该是官方后台做了限制，连自家也不放过。。。</p><p>此次分析只是对<strong>某一首歌曲</strong>评论时间、用户年龄/地区分布进行的，实际上抓取到的信息不仅仅在于此，可以做进一步分析（比如利用评论内容进行文本内容分析等），这部分，未来会进一步分析。当然也可以根据自己情况对不同歌曲进行分析。</p><hr><p>2018-12-17</p><h2 id="歌评文本分析"><a href="#歌评文本分析" class="headerlink" title="歌评文本分析"></a>歌评文本分析</h2><p>评论的文本分析做了两部分：情感分析和词云生成。<br>情感分析采用Python的文本分析库snownlp，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="comment"># python3.6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> snownlp <span class="keyword">import</span> SnowNLP</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Bar</span><br><span class="line"></span><br><span class="line">TABLE_COMMENTS = <span class="string">'****'</span></span><br><span class="line">DATABASE = <span class="string">'****'</span></span><br><span class="line">SONGNAME = <span class="string">'****'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getText</span><span class="params">()</span>:</span></span><br><span class="line">conn = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'root'</span>, db=DATABASE, charset=<span class="string">'utf8'</span>)</span><br><span class="line">sql = <span class="string">'SELECT id,content FROM '</span>+TABLE_COMMENTS</span><br><span class="line">text = pd.read_sql(sql%(SONGNAME), con=conn)</span><br><span class="line"><span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSemi</span><span class="params">(text)</span>:</span></span><br><span class="line">text[<span class="string">'content'</span>] = text[<span class="string">'content'</span>].apply(<span class="keyword">lambda</span> x:round(SnowNLP(x).sentiments, <span class="number">2</span>))</span><br><span class="line">semiscore = text.id.groupby(text[<span class="string">'content'</span>]).count()</span><br><span class="line">bar = Bar(<span class="string">'评论情感得分'</span>)</span><br><span class="line">bar.use_theme(<span class="string">'dark'</span>)</span><br><span class="line">bar.add(</span><br><span class="line"><span class="string">''</span>,</span><br><span class="line">y_axis = semiscore.values,</span><br><span class="line">x_axis = semiscore.index.values,</span><br><span class="line">is_fill=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">bar.render(<span class="string">r'情感得分分析.html'</span>)</span><br><span class="line"></span><br><span class="line">text[<span class="string">'content'</span>] = text[<span class="string">'content'</span>].apply(<span class="keyword">lambda</span> x:<span class="number">1</span> <span class="keyword">if</span> x&gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line">semilabel = text.id.groupby(text[<span class="string">'content'</span>]).count()</span><br><span class="line">bar = Bar(<span class="string">'评论情感标签'</span>)</span><br><span class="line">bar.use_theme(<span class="string">'dark'</span>)</span><br><span class="line">bar.add(</span><br><span class="line"><span class="string">''</span>,</span><br><span class="line">y_axis = semilabel.values,</span><br><span class="line">x_axis = semilabel.index.values,</span><br><span class="line">is_fill=<span class="keyword">True</span>,</span><br><span class="line">)</span><br><span class="line">bar.render(<span class="string">r'情感标签分析.html'</span>)</span><br></pre></td></tr></table></figure></p><p>词云生成采用jieba分词库分词，wordcloud生成词云，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWordcloud</span><span class="params">(text)</span>:</span></span><br><span class="line">text = <span class="string">''</span>.join(str(s) <span class="keyword">for</span> s <span class="keyword">in</span> text[<span class="string">'content'</span>] <span class="keyword">if</span> s)</span><br><span class="line">word_list = jieba.cut(text, cut_all=<span class="keyword">False</span>)</span><br><span class="line">stopwords = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">r'./StopWords.txt'</span>, <span class="string">'r'</span>).readlines()]<span class="comment"># 导入停用词</span></span><br><span class="line">clean_list = [seg <span class="keyword">for</span> seg <span class="keyword">in</span> word_list <span class="keyword">if</span> seg <span class="keyword">not</span> <span class="keyword">in</span> stopwords] <span class="comment">#去除停用词</span></span><br><span class="line">clean_text = <span class="string">''</span>.join(clean_list)</span><br><span class="line"><span class="comment"># 生成词云</span></span><br><span class="line">cloud = WordCloud(</span><br><span class="line">    font_path = <span class="string">r'C:/Windows/Fonts/msyh.ttc'</span>,</span><br><span class="line">    background_color = <span class="string">'white'</span>,</span><br><span class="line">    max_words = <span class="number">800</span>,</span><br><span class="line">    max_font_size = <span class="number">64</span></span><br><span class="line">)</span><br><span class="line">word_cloud = cloud.generate(clean_text)</span><br><span class="line"><span class="comment"># 绘制词云</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">plt.imshow(word_cloud)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">text = getText()</span><br><span class="line">getSemi(text)</span><br><span class="line">getWordcloud(text)</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="http://pic.blog.archiew.top/image/sxj评论情感得分.png" alt="评论情感得分"><br><img src="http://pic.blog.archiew.top/image/sxj评论情感标签.png" alt="评论情感标签"><br><img src="http://pic.blog.archiew.top/image/sxj%E8%AF%84%E8%AE%BA%E8%AF%8D%E4%BA%91.png" alt="评论词云"></p><p><a href="https://download.csdn.net/download/u011371360/10857050" target="_blank" rel="noopener">中文停用词下载</a><br><a href="https://github.com/Archiewyq/music_163" target="_blank" rel="noopener">源码</a> 欢迎 <strong>star</strong> (●’◡’●)</p><p><strong>Todo:</strong></p><ul><li style="list-style: none"><input type="checkbox"> <del>对评论内容做进一步分析</del>  2018.12.17</li><li style="list-style: none"><input type="checkbox"> <del>代码重构，增加多线程等</del>  2018.12.19</li><li style="list-style: none"><input type="checkbox"> <del>代码开源在Github上</del>     2018.12.19</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-数据爬取&quot;&gt;&lt;a href=&quot;#1-数据爬取&quot; class=&quot;headerlink&quot; title=&quot;1. 数据爬取&quot;&gt;&lt;/a&gt;1. 数据爬取&lt;/h1&gt;&lt;p&gt;爬虫部分主要是调用官方API，本次用到的API主要有两个：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取评论:&lt;br&gt;&lt;a href=&quot;http://music.163.com/api/v1/resource/comments/R_SO_4_{歌曲ID}?limit={每页限制数量}&amp;amp;offset={评论数总偏移}&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://music.163.com/api/v1/resource/comments/R_SO_4_{歌曲ID}?limit={每页限制数量}&amp;amp;offset={评论数总偏移}&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;获取评论对应用户的信息:&lt;br&gt;&lt;a href=&quot;https://music.163.com/api/v1/user/detail/{用户ID}&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://music.163.com/api/v1/user/detail/{用户ID}&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工具：&lt;br&gt;Python3.6&lt;br&gt;sublime3&lt;br&gt;MySQL(数据存储)&lt;br&gt;&lt;del&gt;scrapy(数据清洗)&lt;/del&gt;&lt;br&gt;pyecharts(可视化工具库)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;* 关于网易云音乐官方API，后期会整理一下做个汇总放在GitHub上。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.archiew.top/tags/Python/"/>
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="爬虫" scheme="http://blog.archiew.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="数据可视化" scheme="http://blog.archiew.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AES加密算法详解</title>
    <link href="http://blog.archiew.top/2018/11/29/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.archiew.top/2018/11/29/AES加密算法详解/</id>
    <published>2018-11-29T12:34:57.000Z</published>
    <updated>2018-12-06T07:33:27.017Z</updated>
    
    <content type="html"><![CDATA[<p>关于AES加密的讲解不再叙述，详细内容可参见《密码编码学与网络安全——原理与实践(第六版)》第5章节。这里从代码实现的角度给出AES加密算法的讲解。<br><a id="more"></a><br>首先，给出AES加密算法的总体结构<br><img src="http://pic.blog.archiew.top/image/AES加密过程.PNG" alt="AES加密过程"><br>AES加密分为两部分：迭代变换和密钥扩展。迭代变换具体来讲是下面这样一个过程：<br><img src="http://pic.blog.archiew.top/image/AES加密-迭代变换.PNG" alt="AES加密-迭代变换"></p><blockquote><p>轮密钥加(AddRoundKey)：明文状态字节与对应轮密钥的异或(Xor)操作；<br>  字节代换(Subsitute Bytes)：明文状态字节的非线性变换，实际上就是所谓的S盒映射；<br>  行移位(ShiftRows)：明文状态字节的简单置换；<br>  列混淆(MixColumns)：一个矩阵乘积(定义在有限域GF(2^8)上的矩阵运算)。</p></blockquote><p>上述步骤中要实现构造S盒，S盒的构造过程如下图：<br><img src="http://pic.blog.archiew.top/image/S盒构造过程.PNG" alt="S盒构造过程"><br><img src="http://pic.blog.archiew.top/image/S盒构造步骤.PNG" alt="S盒构造步骤"><br>注意到上图中需要在GF(2^8)内求逆以及矩阵运算，包括迭代变换过程中的运算操作，并非简单的实数集上的算术运算，实际上涉及到数论和有限域的一些概念，关于这部分知识还是推荐参考《密码编码学与网络安全——原理与实践(第六版)一书。这里仅从运用的角度进行一些简单讲解，下文所提到的运算操作，在不指明的情况下都默认为在有限域GF(2^8)上的运算。<br>有限域可以理解为有限个元素的集合，包含加减乘除运算，并且运算必须满足以下条件：</p><blockquote><p>1、封闭性：若任意两元素a·b∈GF(q)，则有a+b∈GF(q) a·b∈GF(q);<br>  2、结合性：若任意a、b、c∈GF(q)，则有(a+b)+c=a+(b+c)，(a·b)c=a(b·c);<br>  3、交换律：若任意a、b∈GF(q)，则有a+b=b+a，a·b=b·a;<br>  4、加法单位元：GF(q)中存在一个元素0，使得对于GF(q)中的任意元素a+0=0+a=a;<br>  5、加法逆元：对于GF(q)中的任意元素a，GF(q)中一定存在元素-a，使得a+(-a)=(-a)+a=0。</p></blockquote><p>AES算法中涉及到的有限域GF(2^8)是一种特殊的有限域，在该有限域内加减运算等效于模2加法运算(或者说等效于异或运算)，乘法运算等效于多项式(将元素对应的二进制作为多项式对应项的系数)乘法运算，具体原因及讲解参见推荐书籍，这里只说结论。<br>GF(2^8)上的两个元素a,b的乘法运算定义如下：<br>假设，元素a、b对应的多项式分别为<br>$$f(x)=\sum_{i=0}^7{a_ix^i}$$<br>和<br>$$g(x)=\sum_{i=0}^7{b_ix^i}$$<br>，则有限域GF(2^8)上定义的乘法运算为<br>$$h(x)=f(x)*g(x)$$</p><p>(注意在合并同类项时的加减法是有限域GF(2^8)内的运算，即模2加)，结果对应的二进制位是多项式h(x)的各项系数。注意到多项式f(x)和g(x)相乘有可能结果次数会超过7次，对于这种情况，需要将结果模除一个8次既约多项式(既约多项式：不可进行因式分解的多项式，这样的8次既约多项式总共有30多个，AES算法只取其中一个</p><p>$$m(x)=x^8+x^4+x^3+x+1$$<br>)以使得结果次数不超过7<!-- ，模除的概念后面会讲到 -->。这样的定义对于计算机实现显然无从下手，所以有另外的计算机实现的方式。<br>只考虑乘法x*f(x)，则有</p><p>$$x*f(x)=\sum_{i=0}^7{a_ix^{i+1}}$$</p><p>，由上述定义规则<br>$$x*f(x)=(a_7x^8+a_6x^7+a_5x^6+a_4x^5+a_3x^4+a_2x^3+a_1x^2+a_0x) mod m(x)$$，那么就有：<br>$$x*f(x) = \begin{cases} (a_6a_5a_4a_3a_2a_1a_00), &amp; \text{$a_7=0$} \\ (a_6a_5a_4a_3a_2a_1a_00)\oplus(00011011), &amp; \text{$a_7=0$} \end{cases}$$<br>这样对于其他乘法运算，可以组合的来处理，比如：<br>$$f(x)=x^6+x^4+x^2+x+1,g(x)=x^7+x+1,m(x)=x^8+x^4+x^3+x+1$$<br>，计算如下：<br>$$f(x)*g(x)=f(x)*x^7 \oplus f(x)*x \oplus f(x)$$</p><p>，对于像$$x^7*f(x)$$<br>，可以通过迭代地乘x来实现。GF(2^8)上的乘法运算规则如上，具体不再多述，下面给出GF(2^8)上乘法运算的代码实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: gf_math.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"gf_math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;<span class="comment">//GF(2^8)内的元素都是8位的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算f(x)*x^n</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> byte <span class="title">multi_x_n</span><span class="params">(<span class="keyword">const</span> byte a, <span class="keyword">const</span> byte n)</span></span>&#123;</span><br><span class="line">byte temp=a,nn=n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(--nn)&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;<span class="number">0x80</span>)</span><br><span class="line">temp = (temp&lt;&lt;<span class="number">1</span>)^<span class="number">0x1B</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp = temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算f(x)*g(x)</span></span><br><span class="line"><span class="function">byte <span class="title">multi</span><span class="params">(<span class="keyword">const</span> byte a, <span class="keyword">const</span> byte b)</span></span>&#123;</span><br><span class="line">byte s=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">byte temp=b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(temp)&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;<span class="number">0x01</span>)</span><br><span class="line">s ^= multi_x_n(a, i);</span><br><span class="line">temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来是构造S盒过程中用到的另一种运算：有限域GF(2^8)上元素的(乘法)逆：<br>乘法逆的定义是：如果GF(p)(一般域)上的元素a,b满足a*b mod p=1，则称元素a,b互逆，a称作b的乘法逆元(同样地，b也可以称作a的乘法逆元)。 关于乘法逆元的求算，《密码编码学与网络安全——原理与实践(第六版)》中已经有详细讲解，主要是借助欧几里得(求两个整数最大公因子的算法)扩展算法。<br>在给出乘法逆实现代码之前，有必要先了解一下有限域GF(2^8)上的除法运算。GF(2^8)上的两个元素a,b的模除运算定义如下：<br><img src="http://pic.blog.archiew.top/image/有限域模除运算.PNG" alt="有限域模除运算"><br>上述计算过程和实数集上的多项式除法相差不大，注意这里的加减运算还是模2加(异或运算)，下面的代码给出了GF(2^8)上的模除实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: gf_math.c</span></span><br><span class="line"><span class="comment">//计算x对应的二进制最高位1的位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> byte <span class="title">indexof_top1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> temp=x;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>==x)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(temp&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求有限域GF(2^8)上元素a/b。函数返回值为除法的商，指针r中存放除法得到的余数</span></span><br><span class="line"><span class="function">byte <span class="title">div</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> byte b, <span class="keyword">int</span> *r)</span></span>&#123;</span><br><span class="line">byte len=indexof_top1(a)-indexof_top1(b);</span><br><span class="line"><span class="keyword">int</span> temp_a=a;</span><br><span class="line">byte temp_b=b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">*r = temp_a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp_a = temp_a^(temp_b&lt;&lt;len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;len) | div(temp_a, temp_b, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://pic.blog.archiew.top/image/欧几里得扩展算法.PNG" alt="欧几里得扩展算法"><br>以下直接给出求GF(2^8)上元素乘法逆元的代码实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: gf_math.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求元素b在GF(2^8)上的乘法逆元*m(x)取x^8+x^4+x^3+x+1</span></span><br><span class="line"><span class="function">byte <span class="title">extand_gcd</span><span class="params">(byte b)</span></span>&#123;</span><br><span class="line">byte v=<span class="number">1</span>,w=<span class="number">0</span>;</span><br><span class="line">byte v0=<span class="number">0</span>,w0=<span class="number">1</span>;</span><br><span class="line">byte v_=v0,w_=w0;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0x11B</span>;<span class="comment">//m(x)=x^8+x^4+x^3+x+1对应的GF(2^8)上的元素</span></span><br><span class="line">byte r0=b;</span><br><span class="line">byte q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r_=r0;</span><br><span class="line"><span class="keyword">while</span>(r_)&#123;</span><br><span class="line">q = div(r, r0, &amp;r_);</span><br><span class="line">v_ = v^multi(q, v0);  v=v0;v0=v_;</span><br><span class="line">w_ = w^multi(q, w0);  w=w0;w0=w_;</span><br><span class="line">r = r0;</span><br><span class="line">r0 = r_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>S盒构造步骤三：字节到位列向量的转换。等效为矩阵按位的乘法：<br><img src="http://pic.blog.archiew.top/image/字节到位列向量的转换.png" alt="字节到位列向量的转换"></p><h3 id="S盒实现"><a href="#S盒实现" class="headerlink" title="S盒实现"></a>S盒实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: s_box.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"s_box.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"gf_math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br><span class="line">byte S[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取x的二进制的第n位</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> byte <span class="title">getbitn</span><span class="params">(byte x, byte n)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> byte <span class="title">S_box_transform</span><span class="params">(byte x)</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>;</span><br><span class="line">byte temp[<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">byte s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">temp[i] = (getbitn(x, i)^getbitn(x, (i+<span class="number">4</span>)%<span class="number">8</span>)^getbitn(x, (i+<span class="number">5</span>)%<span class="number">8</span>)^getbitn(x, (i+<span class="number">6</span>)%<span class="number">8</span>)^getbitn(x, (i+<span class="number">7</span>)%<span class="number">8</span>)^getbitn(<span class="number">0x63</span>, i))&lt;&lt;i;</span><br><span class="line">s += temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S_box_generator</span><span class="params">(byte *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">s[i] = S_box_transform(extand_gcd(i));<span class="comment">//S盒初始化、求逆和字节转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到的S盒如下：<br><img src="http://pic.blog.archiew.top/image/S盒.png" alt="S盒"></p><p>接着是解密钥扩展。AES算法中输入的密钥长度和明文长度一样，为128bit。在加密过程中，实际上每轮加密使用的密钥都是不一样的，这就需要对输入密钥进行扩展，对于10轮的加密，需要扩展出来128bit*10=16*10字节=40*4个32位字。密钥扩展过程如下图所示：<br><img src="http://pic.blog.archiew.top/image/AES的密钥扩展.png" alt="AES的密钥扩展"><br>密钥扩展过程可以由递推公式表示为：<br>$$w_i = \begin{cases} w_{i-4}\oplus g(w_{i-1}), &amp; \text{i%4=0}\\ w_{i-4}\oplus w_{i-1}, &amp; \text{i%4!=0} \end{cases}$$</p><p>公式中的函数g又是令一个复杂变换，可以描述为：<br><img src="http://pic.blog.archiew.top/image/AES密钥扩展中的g函数.png" alt="AES密钥扩展中的g函数"><br>输入w是一个32位的字(4个字节$$B_0,B_1,B_2,B_3$$)，输入w经过一轮循环移位变换，即将输入字$$[B_0,B_1,B_2,B_3]$$变换成$$[B_1,B_2,B_3,B_0]$$，接着每个字节经过一次S盒替换，最后再将第一个字节同轮常量Rcon异或。<br>AES密钥扩展代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: key.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"key.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span><br><span class="line"></span><br><span class="line">byte Key[<span class="number">44</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//S盒代换</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> byte <span class="title">sub</span><span class="params">(byte x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g_function</span><span class="params">(<span class="keyword">const</span> byte *x, byte *temp, byte n)</span></span>&#123;</span><br><span class="line">byte RC[<span class="number">10</span>]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x1B</span>,<span class="number">0x36</span>&#125;;</span><br><span class="line"></span><br><span class="line">temp[<span class="number">0</span>] = sub(x[<span class="number">1</span>])^RC[n];</span><br><span class="line">temp[<span class="number">1</span>] = sub(x[<span class="number">2</span>]);</span><br><span class="line">temp[<span class="number">2</span>] = sub(x[<span class="number">3</span>]);</span><br><span class="line">temp[<span class="number">3</span>] = sub(x[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//密钥字异或</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">key_xor</span><span class="params">(byte *s, <span class="keyword">const</span> byte *x, <span class="keyword">const</span> byte *y)</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">s[i] = x[i]^y[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//密钥扩展</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyExpansion</span><span class="params">(byte *key, byte w[<span class="number">44</span>][<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">byte temp[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//将初始密钥复制到密钥数组里</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">w[i][j] = key[<span class="number">4</span>*i+j];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;<span class="number">44</span>;i++)&#123;</span><br><span class="line">temp[<span class="number">0</span>] = w[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">temp[<span class="number">1</span>] = w[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">2</span>] = w[i<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">3</span>] = w[i<span class="number">-1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">g_function(&amp;w[i<span class="number">-1</span>][<span class="number">0</span>], temp, i/<span class="number">4</span><span class="number">-1</span>);</span><br><span class="line">key_xor(w[i], w[i<span class="number">-4</span>], temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来是AES加密的主干部分——<strong>迭代变换</strong>：<br>迭代变换分为四个步骤：</p><blockquote><p>字节代换</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: aes.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"aes.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"s_box.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subBytes</span><span class="params">(byte *c, <span class="keyword">const</span> byte *s)</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">c[i] = s[c[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>行位移</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: aes.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftRows</span><span class="params">(byte *c)</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">byte temp[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">temp[i] = c[i];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">j++;</span><br><span class="line">c[i]=(i+i/<span class="number">4</span>)&gt;=<span class="number">4</span>*j?temp[i+i/<span class="number">4</span><span class="number">-4</span>]:temp[i+i/<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>列混淆</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: aes.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mixColumns</span><span class="params">(byte *c)</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">byte temp[<span class="number">16</span>],t;</span><br><span class="line"><span class="keyword">const</span> byte b[]=&#123;<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,</span><br><span class="line">  <span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x01</span>,</span><br><span class="line">          <span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,</span><br><span class="line">  <span class="number">0x03</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x02</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">temp[i] = c[i];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">t ^= multi(temp[<span class="number">4</span>*k+j], b[<span class="number">4</span>*i+k]);</span><br><span class="line">&#125;</span><br><span class="line">c[<span class="number">4</span>*i+j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>轮密钥加</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: aes.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRoundKey</span><span class="params">(byte *c, <span class="keyword">const</span> byte k[<span class="number">44</span>][<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">c[<span class="number">4</span>*i+j] ^= k[j][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后</strong>，AES加密的完整实现代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: aes.c</span></span><br><span class="line"><span class="comment">//下面三个变量在其他文件中声明为外部变量</span></span><br><span class="line">byte S[<span class="number">256</span>];</span><br><span class="line">byte key[<span class="number">16</span>];</span><br><span class="line">byte keys[<span class="number">44</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//明文初始化(按列排成4x4矩阵形式)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_C</span><span class="params">(byte *c)</span></span>&#123;</span><br><span class="line">byte i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">byte temp[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">temp[i] = c[i];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">c[i+<span class="number">4</span>*j] = temp[<span class="number">4</span>*i+j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">byte count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//16字节的明文</span></span><br><span class="line">byte c[]=&#123;<span class="number">0x01</span>,<span class="number">0x23</span>,<span class="number">0x45</span>,<span class="number">0x67</span>,<span class="number">0x89</span>,<span class="number">0xAB</span>,<span class="number">0xCD</span>,<span class="number">0xEF</span>,</span><br><span class="line">          <span class="number">0xFE</span>,<span class="number">0xDC</span>,<span class="number">0xBA</span>,<span class="number">0x98</span>,<span class="number">0x76</span>,<span class="number">0x54</span>,<span class="number">0x32</span>,<span class="number">0x10</span>&#125;;</span><br><span class="line"></span><br><span class="line">init_C(c);</span><br><span class="line">S_box_generator(S);<span class="comment">//S盒生成</span></span><br><span class="line"><span class="comment">//初始密钥初始化</span></span><br><span class="line">key[<span class="number">0</span>]=<span class="number">0x0E</span>; key[<span class="number">1</span>]=<span class="number">0x15</span>; key[<span class="number">2</span>]=<span class="number">0x71</span>; key[<span class="number">3</span>]=<span class="number">0xC9</span>; key[<span class="number">4</span>]=<span class="number">0x47</span>; key[<span class="number">5</span>]=<span class="number">0xD9</span>; key[<span class="number">6</span>]=<span class="number">0xE8</span>; key[<span class="number">7</span>]=<span class="number">0x59</span>;</span><br><span class="line">key[<span class="number">8</span>]=<span class="number">0x0C</span>; key[<span class="number">9</span>]=<span class="number">0xB7</span>; key[<span class="number">10</span>]=<span class="number">0xAD</span>; key[<span class="number">11</span>]=<span class="number">0xD6</span>; key[<span class="number">12</span>]=<span class="number">0xAF</span>; key[<span class="number">13</span>]=<span class="number">0x7F</span>; key[<span class="number">14</span>]=<span class="number">0x67</span>; key[<span class="number">15</span>]=<span class="number">0x98</span>;</span><br><span class="line"></span><br><span class="line">keyExpansion(key, keys);</span><br><span class="line"></span><br><span class="line">addRoundKey(c, keys);<span class="comment">//首先是一次轮密钥加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;<span class="number">10</span>;count++)&#123;</span><br><span class="line">subBytes(c, S);</span><br><span class="line">shiftRows(c);</span><br><span class="line"><span class="keyword">if</span>(count!=<span class="number">9</span>)<span class="comment">//最后一轮迭代不需要列混淆</span></span><br><span class="line">mixColumns(c, b);</span><br><span class="line">addRoundKey(c, keys+<span class="number">4</span>*(count+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，AES加密算法全部实现完成，解密算法可以类似来实现，在此不做探究。</p><p><strong>参考资料</strong><br>1、《密码编码学与网络安全——原理与实践(第六版)》<br>2、<a href="https://blog.csdn.net/u011516178/article/details/81221646" target="_blank" rel="noopener">叶夏沉思的博客——AES128加密-S盒和逆S盒构造推导及代码实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于AES加密的讲解不再叙述，详细内容可参见《密码编码学与网络安全——原理与实践(第六版)》第5章节。这里从代码实现的角度给出AES加密算法的讲解。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="AES加密" scheme="http://blog.archiew.top/tags/AES%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Django实现简单模糊搜索</title>
    <link href="http://blog.archiew.top/2018/11/05/Django%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2/"/>
    <id>http://blog.archiew.top/2018/11/05/Django实现简单模糊搜索/</id>
    <published>2018-11-05T08:09:33.000Z</published>
    <updated>2018-11-05T08:23:34.252Z</updated>
    
    <content type="html"><![CDATA[<p>Django本身提供了丰富的查询过滤操作，除了常规简单操作之外，还提供了复杂条件查询功能——Q对象。通过Q对象我们可以实现组合查找，为了实现模糊查询，利用Python的map/reduce:<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line"><span class="comment">#key是一个关键词组</span></span><br><span class="line">ModelName.objects.filter(reduce(operator.or_, map(<span class="keyword">lambda</span> x:Q(name__icontains=x), key)))</span><br></pre></td></tr></table></figure></p><p>为了实现更精确的模糊搜索，需要对输入的关键词进行分词，中文分词可以利用<em>Jieba分词</em>实现，这部分以后添加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django本身提供了丰富的查询过滤操作，除了常规简单操作之外，还提供了复杂条件查询功能——Q对象。通过Q对象我们可以实现组合查找，为了实现模糊查询，利用Python的map/reduce:&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.archiew.top/tags/Python/"/>
    
      <category term="Django" scheme="http://blog.archiew.top/tags/Django/"/>
    
      <category term="模糊搜索" scheme="http://blog.archiew.top/tags/%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点汇总</title>
    <link href="http://blog.archiew.top/2018/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.archiew.top/2018/10/19/操作系统知识点汇总/</id>
    <published>2018-10-19T02:21:44.000Z</published>
    <updated>2018-11-29T11:53:24.075Z</updated>
    
    <content type="html"><![CDATA[<p>1、系统调用和过程(函数)调用的区别<br>调用形式：过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中；但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用。<br>被调用代码位置不同：过程调用是一种静态调用，调用者和调用代码在同一程序内，经过连接编辑后作为目标代码一部分。系统调用是一种动态调用，系统调用的处理代码在调用程序之外(操作系统中)。<br>提供方式：过程调用往往由编译系统提供，不同编译系统提供的过程可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、数量种类便固定不变。<br>调用实现：程序使用一般机器指令(跳转指令)来调用过程(函数)，是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行，因此，安全性好。<br><a id="more"></a></p><p>2、系统调用控制程序的过程<br>取系统调用号，校验合法性；根据系统调用号定位核心函数地址；根据通用寄存器内容，从用户栈取入口参数；核心函数执行，结果返回。</p><p>3、用户态向内核态转换的情况<br>一个是程序请求操作系统服务程序；二是程序运行时产生的中断调用。</p><p>4、Linux的中断处理</p><blockquote><p>快中断 &amp; 慢中断<br>1)处理慢中断前需保存所有寄存器的内容，而快中断处理最初保存现场时，仅要保存那些被常规C 函数修改的寄存器；<br>2)在慢中断处理时，通常不屏蔽其他中断信号，而快中断处理时会屏蔽所有其他中断；<br>3)慢中断处理完毕后，通常不立即返回被中断的进程，而是进入调度程序重新进行调度，调度结果未必是被中断的进程运行(是抢先式调度)。而快中断处理完毕后，通常恢复现场返回被中断的进程继续执行(是非抢先式调度)。<br>底半处理<br>这种一部分工作由核心代码在关中断状态下处理，另外一部分工作由中断服务程序在开中断状态下来处理的方式称为底半处理(bottom half handling)，Linux 用底半处理机制来实现中断事件的快速处理。</p></blockquote><p>5、进程上下文<br>操作系统中把进程物理实体和支持进程运行的环境合称为进程上下文（process context）。在操作系统中，进程上下文包括三个组成部分：</p><blockquote><p>用户级上下文（user -level context）：由用户进程的程序块、用户数据块（含共享数据块）和用户堆栈组成的进程地址空间。<br>系统级上下文（system -level context）：包括进程的标识信息、现场信息和控制信息，进程环境块，以及系统堆栈等组成的进程地址空间。<br>寄存器上下文（register context）：由程序状态字寄存器、各类控制寄存器、地址寄存器、通用寄存器、用户栈指针等组成。<br><img src="http://pic.blog.archiew.top/image/用户进程在虚拟内存中的组.png" alt="用户进程在虚拟内存中的组"></p></blockquote><p>6、进程队列及其管理<br><img src="http://pic.blog.archiew.top/image/操作系统的队列管理和状态.png" alt="操作系统的队列管理和状态"></p><p>7、进程切换与模式切换<br><em>中断是激活操作系统的唯一方法。</em><br>内核在四种情况下允许发生上下文切换：<br>(1) 当进程进入等待态时；<br>(2) 当进程完成其系统调用返回用户态但不是最有资格获得CPU 时；<br>(3) 当内核完成中断处理，进程返回用户态但不是最有资格获得CPU 时；<br>(4) 当进程执行结束时。<br>用户态到核心态或者核心态到用户态的转变是CPU 模式的改变，而不是进程上下文切换。<br>当中断发生的时候，暂时中断正在执行的用户进程，把进程从用户状态切换到内核状态，去执行操作系统例行程序以获得服务，这就是一次模式切换，注意，此时仍在该进程的上下文中执行，仅仅模式变了。内核在被中断了的进程的上下文中对这个中断事件作处理，即使该中断事件可能不是此进程引起的。<br>模式切换的步骤如下：</p><blockquote><p>保存被中断进程的处理器现场信息。<br>根据中断号置程序计数器。<br>把用户状态切换到内核状态，以便执行中断处理程序。</p></blockquote><p>8、进程阻塞步骤</p><blockquote><p>停止进程执行，保存现场信息到PCB<br>修改进程控制块的相关内容，如进程状态由运行改为等待<br>把修改状态后的进程控制块加入相应的等待进程队列<br>转入进程调度程序调度其他进程</p></blockquote><p>9、进程唤醒步骤</p><blockquote><p>从相应的等待进程队列取出进程控制块<br>修改进程控制块相关信息，如进程状态由等待修改为运行<br>把修改后的进程控制块加入到就绪进程队列</p></blockquote><p>10、进程创建和停止</p><blockquote><p>创建进程的系统调用sys_fork( )和sys_clone 都通过调用do_fork( )函数来完成进程的创建。在do_fork( )函数中，首先分配进程控制块task_struct 的内存和进程所需的堆栈，并检测系统是否可以增加新的进程；然后，拷贝当前进程的内容，并对一些数据成员进行初始化；再为进程的运行做准备；最后，返回生成的新进程的进程标识号（pid）。如果进程是根据sys_clone( )产生的，那么，它的进程标识号就是当前进程的进程标识号，并且对于进程控制块中的一些成员指针并不进行复制，而仅仅把这些成员指针的计数count 增加1。这样，父子进程可以有效地共享资源。</p></blockquote><blockquote><p>进程终止的系统调用sys_exit( )通过调用do_exit( )函数实现。函数do_exit( )首先释放进程占用的大部分资源，然后进入TASK_ZOMBIE 状态，调用exit_notify( )通知父子进程，调用schedule( )重新调度。</p></blockquote><p>11、单线程进程存在的问题</p><blockquote><p>进程时空的开销大，频繁的进程调度将耗费大量处理器时间，要为每个进程分配存储空间限制了操作系统中进程的总数。<br>进程通信的代价大，每次通信均要涉及通信进程之间或通信进程与操作系统之间的信息传递。<br>进程之间的并发性粒度较粗，并发度不高，过多的进程切换和通信延迟使得细粒度的并发得不偿失。<br>不适合并行计算和分布并行计算的要求，对于多处理器和分布式的计算环境来说，进程之间大量频繁的通信和切换，会大大降低并行度。<br>不适合客户/服务器计算的要求。对于C/S 结构来说，那些需要频繁输入输出并同时大量计算的服务器进程（如数据库服务器、事务监督程序）很难体现效率。</p></blockquote><p>12、进程模型<br><img src="http://pic.blog.archiew.top/image/单线程进程模型.PNG" alt="单线程进程模型"><br><img src="http://pic.blog.archiew.top/image/多线程进程模型.PNG" alt="多线程进程模型"></p><p>13、多线程进程中术语概念</p><blockquote><p>进程的定义：进程是操作系统中进行保护和资源分配的基本单位。<br>线程是操作系统进程中能够独立执行的实体（控制流），是处理器调度和分派的基本单位。（并发性、共享性、动态性、结构性）<br><img src="http://pic.blog.archiew.top/image/线程的内存布局.PNG" alt="线程的内存布局"><br><img src="http://pic.blog.archiew.top/image/线程的实现方式.png" alt="线程的实现方式"><br><em>内核级线程KLT(Kernel Level Threads)</em><br>在多处理器上，内核能够同时调度同一进程中多个线程并行执行；<br>若进程中的一个线程被阻塞了，内核能调度同一进程的其他线程占有处理器运行，也可以运行其他进程中的线程。<br>由于内核线程仅有很小的数据结构和堆栈，KLT 的切换比较快，内核自身也可以用多线程技术实现，从而，<br>能提高系统的执行速度和效率</p></blockquote><blockquote><p>KLT 的主要缺点是：应用程序线程在用户态运行，而线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要用户态-内核态-用户态的模式切换，系统开销较大。<br><img src="http://pic.blog.archiew.top/image/CPU调度层次.png" alt="CPU调度层次"></p></blockquote><p>14、作业调度算法</p><blockquote><p>先来先服务FCFS（First Come，First Served）算法<br>最短作业优先SJF（Shortest Job First ）算法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、系统调用和过程(函数)调用的区别&lt;br&gt;调用形式：过程（函数）使用一般调用指令，其转向地址是固定不变的，包含在跳转语句中；但系统调用中不包含处理程序入口，而仅仅提供功能号，按功能号调用。&lt;br&gt;被调用代码位置不同：过程调用是一种静态调用，调用者和调用代码在同一程序内，经过连接编辑后作为目标代码一部分。系统调用是一种动态调用，系统调用的处理代码在调用程序之外(操作系统中)。&lt;br&gt;提供方式：过程调用往往由编译系统提供，不同编译系统提供的过程可以不同；系统调用由操作系统提供，一旦操作系统设计好，系统调用的功能、数量种类便固定不变。&lt;br&gt;调用实现：程序使用一般机器指令(跳转指令)来调用过程(函数)，是在用户态运行的；程序执行系统调用，是通过中断机构来实现，需要从用户态转变到核心态，在管理状态执行，因此，安全性好。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="http://blog.archiew.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>秋招汇总</title>
    <link href="http://blog.archiew.top/2018/09/29/%E7%A7%8B%E6%8B%9B%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.archiew.top/2018/09/29/秋招汇总/</id>
    <published>2018-09-29T01:07:58.000Z</published>
    <updated>2018-10-09T14:05:30.228Z</updated>
    
    <content type="html"><![CDATA[<p>各公司秋招汇总：<br><a id="more"></a></p><h3 id="招银网络科技-软件开发工程师"><a href="#招银网络科技-软件开发工程师" class="headerlink" title="招银网络科技(软件开发工程师)"></a>招银网络科技(软件开发工程师)</h3><p>20180929 面试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍，简单介绍项目内容；</span><br><span class="line">2、数据库索引的优缺点；</span><br><span class="line">    优：加快索引速度，加速表之间的连接，减少磁盘I/O;</span><br><span class="line">缺：创建维护索引费时间，索引要占物理空间，更新添加删除操作数据时需要同时维护索引降低了数据维护速度。</span><br><span class="line">3、循环队列实现(讲思路)；</span><br><span class="line">数组实现：</span><br><span class="line">#define MAX_SIZE10</span><br><span class="line">typedef struct Node&#123;</span><br><span class="line">int arr[MAX_SIZE];</span><br><span class="line">int front;</span><br><span class="line">int rear;</span><br><span class="line">&#125;node;</span><br><span class="line">node *init()&#123;</span><br><span class="line">node *p=(node *)malloc(sizeof(node));</span><br><span class="line">p-&gt;front=p-&gt;rear=0;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">int push(node *p, int x)&#123;</span><br><span class="line">if((p-&gt;rear+1)%MAX_SIZE==p-&gt;front)</span><br><span class="line">return 0;</span><br><span class="line">p-&gt;arr[p-&gt;rear]=x;</span><br><span class="line">p-&gt;rear=(p-&gt;rear+1)%MAX_SIZE;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int pop(node *p)&#123;</span><br><span class="line">int s;</span><br><span class="line">if(p-&gt;rear==p-&gt;front)</span><br><span class="line">return 0;</span><br><span class="line">s=p-&gt;arr[p-&gt;front];</span><br><span class="line">p-&gt;front=(p-&gt;front+1)%MAX_SIZE;</span><br><span class="line"></span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">int len(node *p)&#123;</span><br><span class="line">return (p-&gt;rear-p-&gt;front+MAX_SIZE)%MAX_SIZE+1;</span><br><span class="line">&#125;</span><br><span class="line">3、内存分配方式；[内存分配方式与分配算法](https://blog.csdn.net/jasonlee_lijiaqi/article/details/79559793)</span><br><span class="line">连续分配：固定分区分配、动态分区分配(首次适应法、循环首次适应法、最佳适应法、快速适应法)、可重定位分区分配</span><br><span class="line">离散分配：分页存储、虚拟存储器</span><br><span class="line">4、static关键字作用；[C语言中static详细分析](https://www.cnblogs.com/JMatrix/p/8194009.html)</span><br><span class="line">static修饰的变量存在于程序的整个生命周期</span><br><span class="line">static修饰的变量只能被其作用域内的变量或函数访问</span><br><span class="line">static修饰的变量如果没有被初始化，编译器会自动赋值为0，由于其存在于全局存储区，所以只会被初始化一次</span><br><span class="line">static修饰的函数作用域是本源文件，类似于C++的private函数，static函数解决了不同文件中函数同名问题，因为一个源文件中的static函数对外不可见。</span><br><span class="line">   const关键字的作用：</span><br><span class="line">    修饰的变量内容不能被改变</span><br><span class="line">5、sizeof作用。</span><br><span class="line">运算符，求变量/类型的所占空间大小</span><br></pre></td></tr></table></figure></p><h3 id="乐鑫-嵌入式软件开发-物联网"><a href="#乐鑫-嵌入式软件开发-物联网" class="headerlink" title="乐鑫(嵌入式软件开发-物联网)"></a>乐鑫(嵌入式软件开发-物联网)</h3><p>20180927 笔试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、串口和TCP进行通信，出现数据传输丢失的原因及应对方法。</span><br><span class="line">2、单链表的反转。</span><br><span class="line">3、设计安全传输方案。</span><br><span class="line">4、英文技术文档(节选)，翻译/概述大意，文档内容大致为一个设备的SPI接口定义。</span><br><span class="line">5、算法设计。</span><br></pre></td></tr></table></figure></p><h3 id="寒武纪-嵌入式软件开发工程师"><a href="#寒武纪-嵌入式软件开发工程师" class="headerlink" title="寒武纪(嵌入式软件开发工程师)"></a>寒武纪(嵌入式软件开发工程师)</h3><p>20181008 面试(1面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍，项目讲解；</span><br><span class="line">2、开漏、推挽输出模式的区别；</span><br><span class="line">3、STM32的中断分成两个优先级(主优先级、子优先级)的作用；</span><br><span class="line">4、模拟I2C时，输入输出模式的切换；</span><br><span class="line">5、双向IO；</span><br><span class="line">6、I2C读操作流程</span><br><span class="line">7、。。。后面忘了。</span><br></pre></td></tr></table></figure></p><h3 id="比特大陆-嵌入式开发工程师"><a href="#比特大陆-嵌入式开发工程师" class="headerlink" title="比特大陆(嵌入式开发工程师)"></a>比特大陆(嵌入式开发工程师)</h3><p>20181009 面试(1面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍、项目讲解；</span><br><span class="line">2、SPI、I2C的区别；</span><br><span class="line">3、嵌入式中多进程的设计实现；</span><br><span class="line">4、对Linux内核的了解；</span><br><span class="line">5、进程上下文和终端上下文的不同(没答上来)；</span><br><span class="line">6、。。。后面忘了。</span><br></pre></td></tr></table></figure></p><p>20181009 面试(2面 HR面)<br>20181009 面试(3面 远程技术面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍、项目讲解；</span><br><span class="line">2、Python来实现文本文件中每行特定字符串的匹配；答：读文件+正则表达式匹配；</span><br><span class="line">3、段错误时怎么调试；</span><br><span class="line">4、对map文件的了解；</span><br><span class="line">5、对信号量的理解；</span><br><span class="line">6、协同开发，Git的掌握；</span><br><span class="line">7、。。。后面忘了</span><br></pre></td></tr></table></figure></p><h3 id="努比亚-驱动-协议开发工程师"><a href="#努比亚-驱动-协议开发工程师" class="headerlink" title="努比亚(驱动/协议开发工程师)"></a>努比亚(驱动/协议开发工程师)</h3><p>20181009 面试(技术面)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、自我介绍、项目讲解；</span><br><span class="line">2、HTTP协议中GET和POST的区别；</span><br><span class="line">3、字符串中查找子串(手撕代码，还好不难);</span><br><span class="line">4、I2C、SPI、UART的了解，I3C了解过没(没)，猜一下(没猜对)；</span><br><span class="line">6、。。。忘了。</span><br><span class="line">7、对公司的了解；</span><br><span class="line">8、闲扯了一下行业相关。。。</span><br><span class="line">** 面试体验不错</span><br></pre></td></tr></table></figure></p><p>20181009 面试(HR面)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各公司秋招汇总：&lt;br&gt;
    
    </summary>
    
    
      <category term="秋招" scheme="http://blog.archiew.top/tags/%E7%A7%8B%E6%8B%9B/"/>
    
      <category term="工作" scheme="http://blog.archiew.top/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="总结" scheme="http://blog.archiew.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="学习" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>μC/OS-II中的任务</title>
    <link href="http://blog.archiew.top/2018/09/13/%CE%BCC-OS-II%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1/"/>
    <id>http://blog.archiew.top/2018/09/13/μC-OS-II中的任务/</id>
    <published>2018-09-13T06:55:04.000Z</published>
    <updated>2018-09-13T07:58:16.631Z</updated>
    
    <content type="html"><![CDATA[<p>μC/OS-II<br>操作系统内核一项主要的工作就是对任务进行管理和调度。与之相关的内容主要包括以下几点：</p><blockquote><p>任务的基本概念，用户任务和系统任务；<br>  任务代码、任务控制块和任务堆栈；<br>  任务优先权及表示任务优先权的参数——优先级别；<br>  任务就绪表结构及其操作；<br>  任务切换及调度；<br>  任务的创建、删除、挂起、恢复和查询；<br>  μC/OS-II的初始化和启动。</p></blockquote><a id="more"></a><h2 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h2><p>从代码角度看，μC/OS-II的任务就是一个个函数，从任务的存储结构来看，μC/OS-II的任务又下图所示的三部分组成：任务程序代码(函数)、任务堆栈和任务控制块。<br><img src="http://pic.blog.archiew.top/image/μCOS-II的任务组成.png" alt="μC/OS-II的任务组成"><br><strong> * μC/OS-II中所有的任务都属于线程。</strong><br>μC/OS-II用任务控制块链表对任务进行管理，如图所示：<br><img src="http://pic.blog.archiew.top/image/任务链表.png" alt="任务链表"><br>μC/OS-II的任务分两种：系统任务和用户任务。用户任务是为了解决应用问题而编写的而系统任务是为应用程序提供某种服务或为系统本身服务的。目前在μC/OS-II中，最多可以含有64个任务(汉系统任务和用户任务)。<br>μC/OS-II是为单核CPU设计的，某一时刻只能有一个任务占用CPU处在运行状态，其他任务只能处在其他状态，μC/OS-II系统中的任务状态如下图所示<br><img src="http://pic.blog.archiew.top/image/μCOS-II系统中任务的五种状态.png" alt="μCOS-II系统中任务的五种状态"><br>各任务状态之间的切换如下图所示<br><img src="http://pic.blog.archiew.top/image/任务状态切换.png" alt="任务状态切换"><br>一个典型的用户任务代码结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//可以被中断的用户代码</span></span><br><span class="line">...</span><br><span class="line">OS_ENTER_CRITICAL();<span class="comment">//进入临界段(关中断)</span></span><br><span class="line"><span class="comment">//不可被中断的用户代码</span></span><br><span class="line">...</span><br><span class="line">OS_EXIT_CRITICAL();<span class="comment">//退出临界段(开中断)</span></span><br><span class="line"><span class="comment">//可以被中断的用户代码</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用户应用程序的一般结构可参见下述代码段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask1</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask2</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTask3</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">OSInit();<span class="comment">//初始化μC/OS-II</span></span><br><span class="line">...</span><br><span class="line">OSTaskCreate(MyTask1, ...);<span class="comment">//创建用户任务1</span></span><br><span class="line">OSTaskCreate(MyTask2, ...);<span class="comment">//创建用户任务2</span></span><br><span class="line">OSTaskCreate(MyTask3, ...);<span class="comment">//创建用户任务3</span></span><br><span class="line">...</span><br><span class="line">OSStart();<span class="comment">//启动μC/OS-II</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>考虑到没有用户任务执行的时候CPU不能停下来，所以μC/OS-II中必须有系统任务。μC/OS-II预定义了两个系统任务：空闲任务和统计任务。其中空闲任务是每个应用程序必须使用的，而统计任务则可以根据情况选择是否需要。<br>空闲任务就是为了防止CPU某时刻没有用户任务可执行而处于空闲状态，μC/OS-II提供了一个名为<em>OSTaskIdle()</em>的系统任务，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTaskIdle</span><span class="params">(<span class="keyword">void</span> *pdata)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OS_CRITICAL_METHOD == 3</span></span><br><span class="line">OS_CPU_SR cpu_sr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">pdata=pdata;<span class="comment">//防止某些编译器报错</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">OS_ENTER_CRITICAL();<span class="comment">//关中断</span></span><br><span class="line">OSdleCtr++;</span><br><span class="line">OS_EXIT_CRITICAL();<span class="comment">//开中断</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;μC/OS-II&lt;br&gt;操作系统内核一项主要的工作就是对任务进行管理和调度。与之相关的内容主要包括以下几点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任务的基本概念，用户任务和系统任务；&lt;br&gt;  任务代码、任务控制块和任务堆栈；&lt;br&gt;  任务优先权及表示任务优先权的参数——优先级别；&lt;br&gt;  任务就绪表结构及其操作；&lt;br&gt;  任务切换及调度；&lt;br&gt;  任务的创建、删除、挂起、恢复和查询；&lt;br&gt;  μC/OS-II的初始化和启动。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="μC/OS-II" scheme="http://blog.archiew.top/tags/%CE%BCC-OS-II/"/>
    
  </entry>
  
  <entry>
    <title>μC/OS-II中的数据结构</title>
    <link href="http://blog.archiew.top/2018/09/13/%CE%BCC-OS-II%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.archiew.top/2018/09/13/μC-OS-II中的数据结构/</id>
    <published>2018-09-13T02:55:58.000Z</published>
    <updated>2018-09-13T07:50:17.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、程序控制块-代码控制块"><a href="#1、程序控制块-代码控制块" class="headerlink" title="1、程序控制块(代码控制块)"></a>1、程序控制块(代码控制块)</h2><p>从代码上来看，程序控制块就是一个结构体，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcb</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *code_name;<span class="comment">//代码名称</span></span><br><span class="line"><span class="keyword">int</span> p;<span class="comment">//重要性级别</span></span><br><span class="line"><span class="keyword">int</span> v_name;<span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">void</span> (*fun)(<span class="keyword">void</span>);<span class="comment">//指向管理代码的指针</span></span><br><span class="line">&#125;TCB;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>上述实例只是最简单的关于程序控制块的说明，实际上操作系统中的程序控制块要远比例子复杂：一方面是需要记录的信息更多；另一方面它们的结构也更复杂。下图是一个稍微复杂的具有量机结构的程序控制块。<br><img src="http://pic.blog.archiew.top/image/%E5%85%B7%E6%9C%89%E4%B8%A4%E7%BA%A7%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E5%8F%AF%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.png" alt="具有两级控制块的可管理代码的结构"></p><h2 id="2、控制块的组织——链表"><a href="#2、控制块的组织——链表" class="headerlink" title="2、控制块的组织——链表"></a>2、控制块的组织——链表</h2><p>如果被管理的代码数量不大且其控制块又比较小的时候，通常会采用数组来作为程序控制块注册表。在操作系统中，需要被管理的代码数量通常比较大且其控制块又较大，可以通过链表来管理程序控制块，如下图所示<br><img src="http://pic.blog.archiew.top/image/用链表来组织的程序控制块.png" alt="用链表来组织的程序控制块"><br>值得注意的是，链表的查询是比较耗时的，因为必须从链表表头沿指针逐个查询，所以为了提高查询效率，系统常常为链表配一个数组，而这个数组的各个元素则存储了指向各个链表成员的指针，这样可以通过数组来实现链表元素的快速随机查询。<br>链表和数组相配合的结构如下图所示<br><img src="http://pic.blog.archiew.top/image/链表和数组的配合.png" alt="链表和数组的配合"></p><h2 id="3、位图"><a href="#3、位图" class="headerlink" title="3、位图"></a>3、位图</h2><p>操作系统中常常涉及到资源的使用情况记录，最简单的需要记录一个资源的占用(使用)状态(占用中or空闲)，记录的方式有很多，最简单的就是使用一种叫做<strong>位图</strong>的表格，这种表格就是将二进制数拆开使用，每一位二进制数代表一个资源的占用状态(eg. 0代表空闲 1代表占用中)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、程序控制块-代码控制块&quot;&gt;&lt;a href=&quot;#1、程序控制块-代码控制块&quot; class=&quot;headerlink&quot; title=&quot;1、程序控制块(代码控制块)&quot;&gt;&lt;/a&gt;1、程序控制块(代码控制块)&lt;/h2&gt;&lt;p&gt;从代码上来看，程序控制块就是一个结构体，例如：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tcb&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *code_name;	&lt;span class=&quot;comment&quot;&gt;//代码名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p;			&lt;span class=&quot;comment&quot;&gt;//重要性级别&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; v_name;		&lt;span class=&quot;comment&quot;&gt;//版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*fun)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);	&lt;span class=&quot;comment&quot;&gt;//指向管理代码的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;TCB;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="μC/OS-II" scheme="http://blog.archiew.top/tags/%CE%BCC-OS-II/"/>
    
  </entry>
  
  <entry>
    <title>CAN总线详解</title>
    <link href="http://blog.archiew.top/2018/08/03/CAN%E6%80%BB%E7%BA%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.archiew.top/2018/08/03/CAN总线详解/</id>
    <published>2018-08-03T01:34:29.000Z</published>
    <updated>2018-08-03T02:44:52.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>控制器局域网总线(CAN，Controller Area Network)是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议由德国的 Robert Bosch公司开发，用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb/s、同时具有11位的寻址以及检错能力。</p><a id="more"></a><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p>1、具有实时性强、传输距离较远、抗电磁干扰能力强、成本低等优点;<br>2、采用双线串行通信方式，检错能力强，可在高噪声干扰环境中工作;<br>3、具有优先权和仲裁功能，多个控制模块通过CAN 控制器挂到CAN-bus 上，形成多主机局部网络;<br>4、可根据报文的ID决定接收或屏蔽该报文;<br>5、可靠的错误处理和检错机制;<br>6、发送的信息遭到破坏后，可自动重发;<br>7、节点在错误严重的情况下具有自动退出总线的功能;<br>8、报文不包含源地址或目标地址，仅用标志符来指示功能信息、优先级信息；<br>9、32个消息对象，每个消息对象有独立的标识符掩码；<br>10、可编程FIFO模式；<br>11、可屏蔽中断；<br>12、时间触发的CAN应用支持禁用自动重传模式；<br>13、可编程的回环自测模式；</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>CAN总线使用串行数据传输方式，可以1Mb/s的速率在40m的双绞线上运行，也可以使用光缆连接，而且在这种总线上总线协议支持多主控制器。CAN与I2C总线的许多细节很类似，但也有一些明显的区别。<br>当CAN总线上的一个节点(站)发送数据时，它以<strong>报文</strong>形式<strong>广播</strong>给网络中所有节点。对每个节点来说，无论数据是否是发给自己的，都对其进行接收。每组报文开头的11位字符为标识符，定义了报文的优先级，这种报文格式称为<strong>面向内容</strong>的编址方案。在同一系统中标识符是唯一的，不可能有两个站发送具有相同标识符的报文。当几个站同时竞争总线读取时，这种配置十分重要。<br>当一个站要向其它站发送数据时，该站的CPU将要发送的数据和自己的标识符传送给本站的CAN芯片，并处于准备状态;当它收到总线分配时，转为发送报文状态。CAN芯片将数据根据协议组织成一定的报文格式发出，这时网上的其它站处于接收状态。每个处于接收状态的站对接收到的报文进行检测，判断这些报文是否是发给自己的，以确定是否接收它。<br>由于CAN总线是一种面向内容的编址方案，因此很容易建立高水准的控制系统并灵活地进行配置。我们可以很容易地在CAN总线中加进一些新站而无需在硬件或软件上进行修改。当所提供的新站是纯数据接收设备时，数据传输协议不要求独立的部分有物理目的地址。它允许分布过程同步化，即总线上控制器需要测量数据时，可由网上获得，而无须每个控制器都有自己独立的传感器。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>CAN总线在组网和通信功能上的优点以及其高性价比据定了它在许多领域有广阔的应用前景和发展潜力。这些应用有些共同之处：CAN实际就是在现场起一个总线拓扑的计算机局域网的作用。不管在什么场合，它负担的是任一节点之间的实时通信，但是它具备结构简单、高速、抗干扰、可靠、价位低等优势。CAN总线最初是为汽车的电子控制系统而设计的，目前在欧洲生产的汽车中CAN的应用已非常普遍，不仅如此，这项技术已推广到火车、轮船等交通工具中。</p><blockquote><p>1、汽车制造中的应用<br>应用CAN总线，可以减少车身布线，进一步节省了成本，由于采用总线技术，模块之间的信号传递仅需要两条信号线。布线局部化，车上除掉总线外其他所有横贯车身的线都不再需要了，节省了布线成本。CAN总线系统数据稳定可靠，CAN总线具有线间干扰小、抗干扰能力强的特点。CAN总线专为汽车量身定做，充分考虑到了汽车上恶劣工作环境，比如点火线圈点火时产生的强大的反充电压，电涡流缓冲器切断时产生的浪涌电流及汽车发动机仓100℃左右的高温。<br>2、大型仪器设备中的应用<br>大型仪器设备是一种参照一定步骤对多种信息采集、处理、控制、输出等操作的复杂系统。过去这类仪器设备的电子系统往往是在结构和成本方面占据相当大的部分，而且可靠性不高。采用CAN总线技术后，在这方面有了明显改观。<br>Can总线是针对测控领域设计的，所以一次传输的报文量很小，一次报文量最大能够承载的数据上限为8字节，这种小数据量的传输一方面能够使得低优先级事务的传输，另一方面也非常符合测控需求。针对can总线技术的诸多优点，非常适合应用于大型仪器系统模块化之间的互相通信，采用<strong>模块化组网</strong>的方式构建大型仪器系统。<br>3、工业控制中的应用<br>随着计算机技术、通信技术和控制技术的发展,传统的工业控制领域正经历着一场前所未有的变革,而工业控制的网络化,更拓展了工业控制领域的发展空间,带来新的发展机遇。在广泛的工业领域，CAN总线可作为现场设备级的通信总线，而且与其他的总线相比，具有很高的可靠性和性能价格比。这将是CAN技术开发应用的一个主要的方向。<br>4、智能家庭和生活小区管理中的应用<br>小区智能化是一个综合性系统工程，要从其功能、性能、成本、扩充能力及现代相关技术的应用等多方面来考虑。基于这样的需求，采用CAN技术所设计的家庭智能管理系统比较适合用于多表远传、防盗、防火、防可燃气体泄漏、紧急救援、家电控制等方面。<br>5、机器人网络互联中的应用<br>制造车间底层设备自动化，近几年仍是我国开展新技术研究和新技术应用工程及产品开发的主要领域，其市场需求不断增大且越发活跃，竞争也日益激烈。伴随着工业机器人的产业化，目前机器人系统的应用大多要求采用机器人生产方式，这就要求多台机器人能通过网络进行互联。随之而来的是，在实际生产过程中，这种连网的多机器人系统的调度、维护工作也变得尤为重要。制造车间底层电气装置联网是近几年内技术发展的重点。其电器装置包括有：运动控制器、基于微处理器的传感器、专用设备控制器等底层设备;在这些装置所构成的网络上另有车间级管理机、监控机或生产单元控制器等非底层装置。结合实际情况和要求，将机器人控制器视为运动控制器。</p></blockquote><h3 id="CAN使用"><a href="#CAN使用" class="headerlink" title="CAN使用"></a>CAN使用</h3><p><strong>软件初始化</strong></p><blockquote><p>置位CAN Control Register的Init位。Init位置位后，CAN节点收发停止，CAN输出CAN_TX状态为<strong>隐性</strong>(高电平)。<br>初始化CAN Controller，CPU需要设置Bit Timing Register和消息对象，未用到的消息对象应该将对应MsgVa位设为不合法。<br><strong>只有当CAN Control Register的Init和CCE位置位后，Bit Timing Register和BRP Extension Register的配置功能才能被使能</strong><br>复位Init位结束软件初始化。之后位流处理器BSP通过等待11个连续隐性位(=总线空闲)来使其自身与数据传输同步，然后才能参与总线活动并开始消息传输。<br>消息对象的初始化独立于Init，可以在运行中完成，但消息对象应全部配置为特定标识符或在BSP启动消息传输之前设置为无效。<br>要在正常操作期间更改消息对象的配置，CPU必须通过将MsgVal设置为无效来启动。 配置完成后，MsgVal再次设置为有效。</p></blockquote><p><strong>CAN消息传输</strong></p><blockquote><p>一旦CAN初始化完成并且Init位复位，CAN Core就会同步自身到CAN总线并开始消息传输<br>接收到的消息被存放在适当的消息对象中(前提是接收到的消息通过了消息处理器的接收过滤)，保存下的消息包含仲裁位、DLC(数据长度)、数据字节。如果使用标识符掩码，则可以在消息对象中覆盖被屏蔽为“不关心”的仲裁位。<br>CPU可以通过接口寄存器随时读写每条消息，消息处理程序可以在并发访问时保证数据一致性。<br>要发送的消息由CPU更新。如果是永久消息对象(对于消息，存在配置期间设置的仲裁和控制位)，仅更新数据字节，然后设置具有NewDat位的TxRqst位以开始传输。 如果将多个传输消息分配给同一消息对象（当消息对象的数量不足时），则必须在请求传输此消息之前配置整个消息对象。<br>多个消息可以同时发起发送请求，然后根据内当部优先级传输。消息可以随时更新位无效状态甚至是当请求发送仍在挂起。 在其挂起的传输开始之前更新消息时，旧数据将会被丢弃。<br>根据消息对象的配置，可以通过接收具有匹配标识符的<strong>远程帧</strong>来自主地请求消息的传输。</p></blockquote><h4 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h4><p><a href="http://embed.21ic.com/hardware/can/201611/42974.html" target="_blank" rel="noopener">CAN总线原理全解析</a><br><a href="https://download.csdn.net/download/guanjishi/1860808" target="_blank" rel="noopener">Bosch_CAN_User’s_Guide.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;控制器局域网总线(CAN，Controller Area Network)是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议由德国的 Robert Bosch公司开发，用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb/s、同时具有11位的寻址以及检错能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="CAN总线" scheme="http://blog.archiew.top/tags/CAN%E6%80%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记3-优化：随机梯度下降</title>
    <link href="http://blog.archiew.top/2018/07/31/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E4%BC%98%E5%8C%96%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>http://blog.archiew.top/2018/07/31/CS231n用于视觉识别的卷积神经网络-学习笔记3-优化：随机梯度下降/</id>
    <published>2018-07-31T02:24:28.000Z</published>
    <updated>2018-08-01T10:33:41.368Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/optimization-1/" target="_blank" rel="noopener">http://cs231n.github.io/optimization-1/</a><br>翻译：<a href="http://blog.archiew.top">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入</a><br><a href="#vis">可视化损失函数</a><br><a href="#optimization">优化</a><br><a href="#opt1">　策略 #1:随机搜索</a><br><a href="#opt2">　策略 #2:随机局部搜索</a><br><a href="#opt3">　策略 #3:跟随梯度</a><br><a href="#gradcompute">梯度计算</a><br><a href="#numerically">　有限差分数值计算梯度</a><br><a href="#analysis">　微积分分析</a><br><a href="#gd">梯度下降</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a><span id="intro">引入</span></h3><p>前两讲中我们介绍了图片分类问题的两个关键任务：</p><ol><li>从图片像素到分类得分的映射：(参数化)<strong>得分函数</strong>(e.g. 线性函数)</li><li>衡量训练数据诱导得分和分类真值一致性质量的<strong>损失函数</strong>，我们了解到有很多方法和版本9)<br>具体讲，回想线性函数公式\(f(x_i,W)=Wx_i\)和SVM公式$$L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + 1) \right] + \alpha R(W)$$我们看到参数\(W\)的设置对样例\(x_i\)的预测与它们真值标签\(y_i\)相一致，这将会产生低的损失值\(L\)。接下来我们将要介绍最后一个关键部分：<strong>优化</strong>。优化指的是找出一组参数\(W\)使损失函数最小化。<br><strong>伏笔</strong> 一旦我们理解了这三个核心部分如何相互作用，我们将回到第一部分(参数化函数映射)将其扩展为一个比线性映射更加复杂的函数：首先是全神经网络，其次是卷积神经网络。损失函数和优化过程将保持相对不变。</li></ol><h3 id="可视化损失函数"><a href="#可视化损失函数" class="headerlink" title="可视化损失函数"></a><span id="vis">可视化损失函数</span></h3><p>本节中我们将会看到损失函数通常被定义为高维空间(e.g. 在CIFAR-10中，线性分类器权重矩阵大小为[10X3073]，共30730个参数)，这使得它们难以可视化。但是，我们仍可以通过沿着光线(1维)或平面(2维)切割高维空间来获得某种程度的直观。比如，我们可以产生一个随机权重矩阵\(W\)(对应于空间中的单个点)，然后沿光线行进并记录损失函数值。也就是说，我们可以产生一个随机方向\(W_1\)并通过求不同\(a\)对应的\(L(W+aW_1)\)的值来计算该方向上的损失(值)。该过程产生一个简单的图，该图以\(a\)的值为x轴以损失函数值为y轴。我们也可以通过计算以\(a\)和\(b\)为变量的损失\(L(W+aW_1+bW_2)\)的值来获得二维图，在图中，\(a\)和\(b\)对应于x轴和y轴，损失函数值可被可视化为颜色。<br><img src="http://cs231n.github.io/assets/svm_one.jpg" alt="多类SVM(未正则化)的损失函数可视化图(左、中：单一样例；右：100个样例。样例来自CIFAR-10。左：只有变量\\(a\\)的一维损失；中、右：二维损失分割，蓝=低损失 红=高损失)。注意损失函数的分段性结构。多样例损失取平均值，因此右图的碗状是许多分段线性的平均值"></p><p>上述损失函数的分段线性结构可以通过数学公式来解释。对单一样例，我们有：$$L_i = \sum_{j\neq y_i} \left[ \max(0, w_j^Tx_i - w_{y_i}^Tx_i + 1) \right]$$表达式明显地表明每个样例的损失数据是线性函数\(W\)的求和。此外，有时候\(W\)的每行(i.e. \(w_j\))在它前面都有一个正号(对应于一个例子的错误类)，有时候是负号(对应于该样例的正确类)。为使其更明确，考虑一个简单的包含三个一维点和三个分类的数据集。全SVM损失(未正则化)变成：<br>$$<br>L_0 =  \max(0, w_1^Tx_0 - w_0^Tx_0 + 1) + \max(0, w_2^Tx_0 - w_0^Tx_0 + 1) \\<br>L_1 =  \max(0, w_0^Tx_1 - w_1^Tx_1 + 1) + \max(0, w_2^Tx_1 - w_1^Tx_1 + 1) \\<br>L_2 =  \max(0, w_0^Tx_2 - w_2^Tx_2 + 1) + \max(0, w_1^Tx_2 - w_2^Tx_2 + 1) \\<br>L   =  (L_0 + L_1 + L_2)/3<br>$$<br>因为样例是一维的，数据\(x_i\)和权重\(w_j\)是数值。上述术语是\(w_0\)的线性函数，并且都被钳制在0。我们可以可视化如下：<br><img src="http://cs231n.github.io/assets/svmbowl.png" alt="数据损失的一维展示。x轴是单权值y轴是损失值。数据损失是多个项的总和，每个想都独立于特定权重或阈值为0的线性函数。完整的SVM数据损失是此形状的30,730-维版本"></p><p>顺便说一句，你可能已经从它的碗状外观猜到了，SVM成本函数是<a href="http://en.wikipedia.org/wiki/Convex_function" target="_blank" rel="noopener">凸函数</a>的一个例子。有大量的文献致力于研究最小化这种类型的函数，您也可以参加斯坦福关于此话题的课程(<a href="http://stanford.edu/~boyd/cvxbook/" target="_blank" rel="noopener">凸优化</a>)。一旦我们扩展得分函数\(f\)到神经网络，我们目标函数将会变为非凸的，并且上面的可视化不会呈现碗状特征，而是蜿蜒复杂的形状。</p><p>不可微分的损失函数。作为技术说明，你还可以在损失函数中看到kinks(转折点，因为最大化操作)，因为kinks处梯度未定义，所以使得损失函数不可微分。然而，子梯度依旧存在并且通常用于取代它。本节将会交替使用术语<strong>子梯度</strong>和<strong>梯度</strong></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><span id="optimization">优化</span></h3><p>重申一下，损失函数可以让我们量化任何特定权重集\(W\)的质量。优化的目标是找到最小化损失函数的\(W\)。我们现在要开发一种方法优化损失函数。对之前有经验的同学，本节课可能看起来很奇怪因为我们将使用的样例(SVM损失)是一个凸问题，但是请记住我们的目的是最终优化不能轻易使用凸优化文献中开发的任何工具的神经网络。</p><h4 id="策略-1-一个很糟糕的解决方案-随机搜索"><a href="#策略-1-一个很糟糕的解决方案-随机搜索" class="headerlink" title="　策略 #1:一个很糟糕的解决方案:随机搜索"></a><span id="opt1">　策略 #1:一个很糟糕的解决方案:随机搜索</span></h4><p>由于检查给定参数集\(W\)的好坏是如此简单，因此可能想到的第一个(非常糟糕的)想法是简单地尝试许多不同的随机权重值并跟踪最佳效果，此过程看起来像下面这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume X_train is the data where each column is an example (e.g. 3073 x 50,000)</span></span><br><span class="line"><span class="comment"># assume Y_train are the labels (e.g. 1D array of 50,000)</span></span><br><span class="line"><span class="comment"># assume the function L evaluates the loss function</span></span><br><span class="line"></span><br><span class="line">bestloss = float(<span class="string">"inf"</span>) <span class="comment"># Python assigns the highest possible float value</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">  W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.0001</span> <span class="comment"># generate random parameters</span></span><br><span class="line">  loss = L(X_train, Y_train, W) <span class="comment"># get the loss over the entire training set</span></span><br><span class="line">  <span class="keyword">if</span> loss &lt; bestloss: <span class="comment"># keep track of the best solution</span></span><br><span class="line">    bestloss = loss</span><br><span class="line">    bestW = W</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'in attempt %d the loss was %f, best %f'</span> % (num, loss, bestloss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints:</span></span><br><span class="line"><span class="comment"># in attempt 0 the loss was 9.401632, best 9.401632</span></span><br><span class="line"><span class="comment"># in attempt 1 the loss was 8.959668, best 8.959668</span></span><br><span class="line"><span class="comment"># in attempt 2 the loss was 9.044034, best 8.959668</span></span><br><span class="line"><span class="comment"># in attempt 3 the loss was 9.278948, best 8.959668</span></span><br><span class="line"><span class="comment"># in attempt 4 the loss was 8.857370, best 8.857370</span></span><br><span class="line"><span class="comment"># in attempt 5 the loss was 8.943151, best 8.857370</span></span><br><span class="line"><span class="comment"># in attempt 6 the loss was 8.605604, best 8.605604</span></span><br><span class="line"><span class="comment"># ... (trunctated: continues for 1000 lines)</span></span><br></pre></td></tr></table></figure></p><p>上面的代码中，我们尝试了一些随机权重向量\(W\)，并且其中一些效果要优于其他的。我们可以通过这种搜索来找到最佳的权重\(W\)并且在测试集上尝试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assume X_test is [3073 x 10000], Y_test [10000 x 1]</span></span><br><span class="line">scores = Wbest.dot(Xte_cols) <span class="comment"># 10 x 10000, the class scores for all test examples</span></span><br><span class="line"><span class="comment"># find the index with max score in each column (the predicted class)</span></span><br><span class="line">Yte_predict = np.argmax(scores, axis = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># and calculate accuracy (fraction of predictions that are correct)</span></span><br><span class="line">np.mean(Yte_predict == Yte)</span><br><span class="line"><span class="comment"># returns 0.1555</span></span><br></pre></td></tr></table></figure></p><p>利用最佳\(W\)，给出了大约15.5%的准确度。考虑到完全随机猜测有10%的准确度，对一个“脑死亡”随机搜索方法来讲，这不是最糟糕的！</p><p><strong>核心理念：迭代求精</strong> 当然了，事实证明，我们可以做的更好核心理念是找到一组最佳的权重\(W\)是很困难的或者说是不可能的问题(特别是当\(W\)包含了整个复杂神经网络的权重)，但是将一组特定权重\(W\)精炼的更好的问题是不太困难的。换句话说，我们的方法是从一组随机\(W\)开始，然后迭代细化，使其每次都稍微好一点。</p><blockquote><p>我们的策略是从一组随机权重\(W\)开始，然后在整个过程中迭代细化来找到最小损失。</p></blockquote><p><strong>Blindfolded hiker analogy</strong> 一个形象的比喻就是，想象自己带着眼罩在小山上徒步并试图达到底部。在CIFAR-10的例子中，因为\(W\)是10x3073，所以“小山”是30730维的。“小山”上的每一点我们都实现了特定损失(地形高度)。</p><h4 id="策略-2-随机局部搜索"><a href="#策略-2-随机局部搜索" class="headerlink" title="　策略 #2:随机局部搜索"></a><span id="opt2">　策略 #2:随机局部搜索</span></h4><p>第一种策略是沿一个随机方向扩展，具体讲，我们以一个随机\(W\)开始，产生随机扰动\(δW\)，如果扰动处损失更低，我们就更新一次。此过程编码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># generate random starting W</span></span><br><span class="line">bestloss = float(<span class="string">"inf"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">  step_size = <span class="number">0.0001</span></span><br><span class="line">  Wtry = W + np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * step_size</span><br><span class="line">  loss = L(Xtr_cols, Ytr, Wtry)</span><br><span class="line">  <span class="keyword">if</span> loss &lt; bestloss:</span><br><span class="line">    W = Wtry</span><br><span class="line">    bestloss = loss</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'iter %d loss is %f'</span> % (i, bestloss)</span><br></pre></td></tr></table></figure></p><p>使用和之前相同数量(1000)的损失函数评估，该方法实现了测试集上21.4%的预测分类准确度。有所改善，单仍耗费大量资源。</p><h4 id="策略-3-跟随梯度"><a href="#策略-3-跟随梯度" class="headerlink" title="　策略 #3:跟随梯度"></a><span id="opt3">　策略 #3:跟随梯度</span></h4><p>在先前讲解中，我们尝试在权重空间寻找一个方向来改善我们的权重向量(得到低损失值)。事实表明，我们没有必要随机搜索一个好的方向：我们可以计算出我们应该改变我们的权重向量的最佳方向，这在数学上保证是最陡下降的方向（至少在极限时为步长变为零）。该方向将与损失函数的<strong>梯度</strong>相关。在我们的徒步比喻中，这种方法大致相当于感知脚下山坡倾斜并沿着感觉最陡的方向走下去。<br>在一维函数中，斜率是函数在您感兴趣点处的瞬时变化率。梯度不是数值而是采用数值向量的函数的斜率的推广。除此之外，梯度是输入空间中每一维斜率矢量(通常称为<strong>导数</strong>)。关于其输入的一维函数导数表达式如下：<br>$$\frac{df(x)}{dx} = \lim_{h\ \to 0} \frac{f(x + h) - f(x)}{h}$$<br>当感兴趣的函数采用数值矢量而不是数值表示时，我们将导数称为<strong>偏导数</strong>，梯度只是每一维的偏导数的矢量。</p><h3 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a><span id="gradcompute">梯度计算</span></h3><p>有两种方法来计算梯度：一种是缓慢近似但简单的<strong>数值梯度</strong>，另一种时快速精确但更容易出错的<strong>解析梯度</strong>。下面我们将分别介绍两者。</p><h4 id="有限差分数值计算梯度"><a href="#有限差分数值计算梯度" class="headerlink" title="　有限差分数值计算梯度"></a><span id="numerically">　有限差分数值计算梯度</span></h4><p>上面的公式允许我们计算数值梯度。这是一个泛型函数，输入函数f，矢量x来评估梯度，并返回函数f在x处的梯度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_numerical_gradient</span><span class="params">(f, x)</span>:</span></span><br><span class="line">  <span class="string">""" </span></span><br><span class="line"><span class="string">  a naive implementation of numerical gradient of f at x </span></span><br><span class="line"><span class="string">  - f should be a function that takes a single argument</span></span><br><span class="line"><span class="string">  - x is the point (numpy array) to evaluate the gradient at</span></span><br><span class="line"><span class="string">  """</span> </span><br><span class="line"></span><br><span class="line">  fx = f(x) <span class="comment"># evaluate function value at original point</span></span><br><span class="line">  grad = np.zeros(x.shape)</span><br><span class="line">  h = <span class="number">0.00001</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># iterate over all indexes in x</span></span><br><span class="line">  it = np.nditer(x, flags=[<span class="string">'multi_index'</span>], op_flags=[<span class="string">'readwrite'</span>])</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># evaluate function at x+h</span></span><br><span class="line">    ix = it.multi_index</span><br><span class="line">    old_value = x[ix]</span><br><span class="line">    x[ix] = old_value + h <span class="comment"># increment by h</span></span><br><span class="line">    fxh = f(x) <span class="comment"># evalute f(x + h)</span></span><br><span class="line">    x[ix] = old_value <span class="comment"># restore to previous value (very important!)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute the partial derivative</span></span><br><span class="line">    grad[ix] = (fxh - fx) / h <span class="comment"># the slope</span></span><br><span class="line">    it.iternext() <span class="comment"># step to next dimension</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> grad</span><br></pre></td></tr></table></figure></p><p>按照上面给出的梯度公式，上面代码逐个迭代所有维度，h沿着改为度进行微小改变并通过查看函数值改变多少来计算损失函数沿该维度的偏导数，最后变量grad记录了完整的梯度。</p><p><strong>实际考虑</strong> 注意，在数学上，梯度定义为当h趋近于于0时的极限，但是实际操作中使用非常小的值(示例中是0.00001)就够了。理想地，我们希望使用不会导致数值问题的最小步长。此外在实际中，使用<strong>居中差异公式</strong>\([f(x+h)-f(x-h)]/2h\)计算梯度通常会更好。详情请见<a href="http://en.wikipedia.org/wiki/Numerical_differentiation" target="_blank" rel="noopener">wiki</a></p><p>利用上述公式我们可以计算任何函数任意点处的梯度。接下来我们计算CIFAR-10中损失函数在权重空间随机点处的梯度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># to use the generic code above we want a function that takes a single argument</span></span><br><span class="line"><span class="comment"># (the weights in our case) so we close over X_train and Y_train</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CIFAR10_loss_fun</span><span class="params">(W)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> L(X_train, Y_train, W)</span><br><span class="line"></span><br><span class="line">W = np.random.rand(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># random weight vector</span></span><br><span class="line">df = eval_numerical_gradient(CIFAR10_loss_fun, W) <span class="comment"># get the gradient</span></span><br></pre></td></tr></table></figure></p><p>梯度表明了每一维损失函数的斜率，我们可以以此来更新:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">loss_original = CIFAR10_loss_fun(W) <span class="comment"># the original loss</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'original loss: %f'</span> % (loss_original, )</span><br><span class="line"></span><br><span class="line"><span class="comment"># lets see the effect of multiple step sizes</span></span><br><span class="line"><span class="keyword">for</span> step_size_log <span class="keyword">in</span> [<span class="number">-10</span>, <span class="number">-9</span>, <span class="number">-8</span>, <span class="number">-7</span>, <span class="number">-6</span>, <span class="number">-5</span>,<span class="number">-4</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>]:</span><br><span class="line">  step_size = <span class="number">10</span> ** step_size_log</span><br><span class="line">  W_new = W - step_size * df <span class="comment"># new position in the weight space</span></span><br><span class="line">  loss_new = CIFAR10_loss_fun(W_new)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'for step size %f new loss: %f'</span> % (step_size, loss_new)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prints:</span></span><br><span class="line"><span class="comment"># original loss: 2.200718</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-10 new loss: 2.200652</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-09 new loss: 2.200057</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-08 new loss: 2.194116</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-07 new loss: 2.135493</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-06 new loss: 1.647802</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-05 new loss: 2.844355</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-04 new loss: 25.558142</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-03 new loss: 254.086573</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-02 new loss: 2539.370888</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-01 new loss: 25392.214036</span></span><br></pre></td></tr></table></figure></p><p><strong>以负梯度方向更新</strong> 上面的代码中注意到为了计算<code>W_new</code>，我们在梯度<code>df</code>的负方向上进行更新，因为我们希望损失函数减少而不是增加。</p><p><strong>步长影响</strong> 梯度告诉我们函数最陡增长率的方向，但并没有告诉我们应该沿该方向走多远。我们将在后续课程中看到，步长(也叫<em>学习率</em>)的选择将成为训练神经网络超参设置中最重要(最头疼)的一部分。在我们的“遮眼下山”比喻中，我们感知脚下山坡向某个方向倾斜，但步长是不确定的。如果我们小心地移动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/optimization-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/optimization-1/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分类&quot;&gt;&lt;a href=&quot;#线性分类&quot; class=&quot;headerlink&quot; title=&quot;线性分类&quot;&gt;&lt;/a&gt;线性分类&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#vis&quot;&gt;可视化损失函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#optimization&quot;&gt;优化&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#opt1&quot;&gt;　策略 #1:随机搜索&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#opt2&quot;&gt;　策略 #2:随机局部搜索&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#opt3&quot;&gt;　策略 #3:跟随梯度&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#gradcompute&quot;&gt;梯度计算&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#numerically&quot;&gt;　有限差分数值计算梯度&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#analysis&quot;&gt;　微积分分析&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#gd&quot;&gt;梯度下降&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="视觉识别" scheme="http://blog.archiew.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog.archiew.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="随机梯度下降" scheme="http://blog.archiew.top/tags/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>2019大疆嵌入式软件开发招聘</title>
    <link href="http://blog.archiew.top/2018/07/08/2019%E5%A4%A7%E7%96%86%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8B%9B%E8%81%98/"/>
    <id>http://blog.archiew.top/2018/07/08/2019大疆嵌入式软件开发招聘/</id>
    <published>2018-07-08T13:10:23.000Z</published>
    <updated>2018-08-30T12:53:38.940Z</updated>
    
    <content type="html"><![CDATA[<p>刚做完大疆的2019年嵌入式软开笔试题(B卷)，作以下纪录：<br>题型：单选（2’x10=20’）、多选（3’x5=15’）、填空（4’x4=16’）、简答（6’x3=18’）、编程（ 11’+20’ = 31’）<br>时间：20180708   19:30 — 21:00（90分钟）</p><a id="more"></a><hr><h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><blockquote><p>DDR特性<br>sizeof struct 和 sizeof union<br>sizeof __attribute__(packed)编译优化<br>sizeof二维数组<br>函数指针数组 int (*int a[10])(int)<br>const char *p和char * const p<br>cache<br>assert()在debug模式及release模式<br>中断context保存位置</p></blockquote><h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><blockquote><p>sizeof offsetof<br>实时嵌入式操作系统<br>关键区域保护措施(关中断？关抢占？上锁？)</p></blockquote><h3 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h3><blockquote><p>sizeof<br>memset<br>进程间通讯方式</p></blockquote><h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><blockquote><p>for(;;)函数调用次数<br>mmap和fread读文件的比较<br>实时/非实时操作系统概念、选用、优劣</p></blockquote><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><blockquote><p>删除双向链表最后N个节点(考虑N&gt;节点总数)<br>单向链表倒置</p></blockquote><p>20180720 笔试通过</p><blockquote><p>20180728 下午3点    一面(电话面)<br>首先让做自我介绍，blabla~<br>就简历上所填项目自行选择一个做详细说明，根据项目内容问几个问题<br>对方选择另外感兴趣项目，就细节进行提问，问到了断电时内存写入处理，文件传输校验，CAN总线协议(如何保证传输不出错)…blabla~<br>就自己了解的一种嵌入式操作系统进行说明。</p></blockquote><blockquote><p>20180731 晚上9点    一面(电话面，突击)<br>上来还是自我介绍，blabla~<br>问做的项目，针对项目于内容发问，对我主要是CAN总线提问<br>就简历内容发问，我简历提到用过Python，对方直接问用来做什么，答的是爬虫和网站，然后就爬虫问是否只是调用三方库实现，答的是有用库的有自己实现的，blabla~</p></blockquote><p>20180801 一面通过</p><blockquote><p>20180805 下午2:36-3:00    二面(电话面)<br>简历上的项目一个个问，以及其中细节<br>说一下对大疆的了解<br>如果项目组对多个方案不能达成一致，作为决策者，你如何决策</p></blockquote><blockquote><p>20180807 晚上7:00-7:20    二面(加面)<br>项目讲述及相关问题提问<br>对大疆的认识<br>。。。</p></blockquote><p>20180807 二面通过 收到终面邀请</p><blockquote><p>20180817 上午11:50-12:20    终面(现场)<br>自我介绍<br>挑一个熟悉的项目讲一下，项目细节<br>对大疆的认识<br>未来的职业规划</p></blockquote><p>等待结果中~~~<br>20180830 收到Thanks Letter，通知被淘汰。。。</p><p>第一份求职之路失败告终！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚做完大疆的2019年嵌入式软开笔试题(B卷)，作以下纪录：&lt;br&gt;题型：单选（2’x10=20’）、多选（3’x5=15’）、填空（4’x4=16’）、简答（6’x3=18’）、编程（ 11’+20’ = 31’）&lt;br&gt;时间：20180708   19:30 — 21:00（90分钟）&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="大疆" scheme="http://blog.archiew.top/tags/%E5%A4%A7%E7%96%86/"/>
    
  </entry>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记2</title>
    <link href="http://blog.archiew.top/2018/07/06/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://blog.archiew.top/2018/07/06/CS231n用于视觉识别的卷积神经网络-学习笔记2/</id>
    <published>2018-07-06T00:59:46.000Z</published>
    <updated>2018-07-31T03:19:19.133Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/linear-classify/" target="_blank" rel="noopener">http://cs231n.github.io/linear-classify/</a><br>翻译：<a href="http://blog.archiew.top">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入线性分类</a><br><a href="#score">线性得分函数</a><br><a href="#interpret">解释线性分类器</a><br><a href="#loss">损失函数</a><br><a href="#svm">　多类SVM</a><br><a href="#softmax">　Softmax分类器</a><br><a href="#svmvssoftmax">　SVM与Softmax</a><br><a href="#demo">线性分类器Web交互式演示</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="线性分类-1"><a href="#线性分类-1" class="headerlink" title="线性分类"></a><span id="intro">线性分类</span></h3><p>上一讲中，我们介绍了图像分类的问题，即从一组固定的类别中为图像分配单个标签的任务。更重要的是，我们描述了<strong>k-最近邻（kNN）</strong>分类器，它通过将图像与训练集中的（带注释的）图像进行比较来标记图像。正如我们所看到的，kNN有许多缺点：</p><blockquote><ul><li>分类器需要存储所有训练数据以供接下来与测试数据作比较。因为数据集大小很容易达到千兆字节，所以这会导致空间效率低下。</li><li>对测试图像的分类很耗费资源因为它需要与训练集中的所有图像进行比较。</li></ul></blockquote><p><strong>预览</strong> 接下来我们要开发出来一种更加高效的方法去进行图像分类，最终自然地扩展到整个神经网络和卷积神经网络。该方法涉及两个主要部分：将原始数据映射为分类得分的<strong>score function(得分函数)</strong>，量化预测分数和真值标签之间差异的<strong>lose function(损失函数)</strong>。我们将这个问题看作优化问题：最小化关于得分函数参数的损失函数。</p><h3 id="线性得分函数"><a href="#线性得分函数" class="headerlink" title="线性得分函数"></a><span id="score">线性得分函数</span></h3><p>首先定义得分函数，该函数将图像像素值映射为每个分类的置信度分数。接下来通过一个具体例子来说明。假定图像训练集\(x_i\in{R^D}\)，与之对应的标签集为\(y_i\)，其中\(i=1…N\),\(y_i\in{1…K}\)。也就是说，我们有\(N\)个样本(每个样本维度\(D\))和\(K\)个独立标签分类。例如，对于CIFAR-10，我们的训练集有\(N=50,000\)个图片，每个图片有\(D=32X32X3=3072\)个像素，独立分类数\(K=10\)。我们现在定义原始像素映射到分类得分的得分函数：$$f:R^D→R^K$$<br><strong>线性分类器(Linear classifier)</strong> 在这里，我们从最简单的线性映射开始：$$f(x_i,W,b)=Wx_i+b$$在上述等式中，假定图片\(x_i\)已经被平铺成一个单一列向量[Dx1]。矩阵\(W\)(大小：[KxD])和向量\(b\)(大小：[Kx1])是函数的<strong>参数</strong>。在CIFAR-10中，\(x_i\)是第i个被平铺成[3072x1]的图片，\(W\)是[10x3072],\(b\)是[10x1]，也就是我们输入3072个像素值，并获得代表分类得分的10个数据输出。参数\(W\)被称作<strong>权重</strong>，\(b\)被称作<strong>偏差向量</strong>因为它影响输出得分但并不与真实数据\(x_i\)交互。<br>注意：</p><blockquote><ul><li>单一矩阵相乘\(Wx_i\)有效地并行评估10个独立分类器，\(W\)中的每行都是一个分类器</li><li>输入数据\((x_i,y_i)\)是给定的，我们控制参数\(W,b\)的设置。目标是计算全部训练集中图片分类得分并与真值分类标签相匹配。直观上我们希望正确分类能够得到比错误分类更高的分数</li><li>这种方法的一个优势是训练集用来学习参数\(W,b\)，一旦学习完成，就可以完全抛弃训练集只保留学习到的参数。因为新的测试图片可以通过此函数进行简单的前向传递并且基于得分进行分类</li><li>最后，注意到对测试图片的分类仅涉及到一次矩阵乘法和加法，这将比之前的比较测试图片与训练图片差异快得多。</li></ul></blockquote><blockquote><p>卷积神经网络将图像像素映射为上述提到的得分，但是映射\(f\)将会更复杂并且包含更多的参数</p></blockquote><h3 id="解释线性分类器"><a href="#解释线性分类器" class="headerlink" title="解释线性分类器"></a><span id="interpret">解释线性分类器</span></h3><p>注意到线性分类器计算图像3个通道所有像素值的加权和作为分类得分。根据我们设置的权重值的精度，映射函数能够反映出对图片某些位置某种颜色的倾向。例如，设想图像中有许多蓝色像素点(可能被看作是‘水’)可能被分类为‘船’。我们可能希望‘船’分类器在图片蓝色通道上有许多正权重值(蓝色的存在会增加船分类的得分)，而在红/蓝通道上有负权重值(红/蓝的存在会降低船分类的得分)。<br><img src="http://cs231n.github.io/assets/imagemap.jpg" alt="图像映射为分类得分的例子。为方便可视化展示，我们假定图像仅含4个黑白像素，并且给定了3个分类标签：猫(red),狗(green),船(blue)。注意：这里的颜色并不代表图像颜色通道，仅作区分不同类用。将图像像素平铺成一列，执行矩阵乘法加法得到每个分类的得分。注意：上图中给出的权重值是随机的，因此得分结果并不准确，实际上我们希望得分结果中猫分类得分应该是最高的。"></p><p><strong>将图像类比为高维点</strong> 因为图片被平铺为高维列向量，因此我们可以将图片对应到高维空间内的一个点(eg.CIFAR-10中的每个图片都可对应为3072维空间中的一个点)。类似地，整个数据集就对应该空间中的一组(含标签)点集。<br>因为我们定义分类得分为图像像素加权和，所以每个分类得分是整个空间的线性函数。我们无法可视化3072维空间但是设想将其压缩为2维，然后尝试可视化分类器的操作过程。<br><img src="http://cs231n.github.io/assets/pixelspace.jpeg" alt="图像空间的可视化表示，每个图片都是对应空间的一个点。以汽车分类器(red)为例，红线上点表示对应于汽车分类器的得分为0的图像。红色箭头表示汽车分类器得分增加的方向，所以红线右侧的点有正值(呈线性增加)得分，左侧的点有负值(呈线性减小)得分。"></p><p>\(W\)中的每行对应一个分类的分类器。这些数的几何解释是，当我们改变\(W\)的每一行，像素空间对应线将会旋转不同方向。另一方面偏差\(b\)允许我们的分类器翻转这条线？？？尤其要注意的是没有偏差的话，对输入\(x_i=0\)将会输出0分，无论权重值为多少，因此所有线将会穿过原点。（这段没太懂）</p><p><strong>将线性分类器解释为模板匹配</strong> 权重\(W\)的另一种解释是每行对应一个分类模板(或者称作‘原型’)。对一个图片，每个分类的得分是通过比较每个模板和图片的内积(或点积)获得。用专业术语说，线性分类器在做模板匹配，而模板是在不断学习的。其实我们还是在做最近邻工作，只不过这里使用内积来代替L1或L2距离。<br><img src="http://cs231n.github.io/assets/templates.jpg" alt="学习CIFAR-10结束时的权重示例。注意：如我们所期望的那样，船模板包含了许多蓝色像素。因此对于一幅海洋中的船图片该模板做内积将会给出高分"></p><p>除此之外，注意到上图中马的模板似乎包含了一个‘双头’马，这是因为数据集中包含了面向左侧和面向右侧两种含马的训练图片，线性分类器将这两个模型合并到一个模板图中。类似地，汽车模板似乎合并了多个模型(不同角度不同颜色)到一个模板中。最终的模板呈现红色，表明数据集中含有大量红色汽车图片。那么实际上这个线性分类器在正确识别不同颜色汽车方面还有所欠缺，随后我们在神经网络中会做这部分工作。神经网能够通过隐藏层中的中间神经元来检测特殊的汽车类型(eg.向左的绿色汽车，向前的蓝色汽车)，后层神经元可以将这些结合起来得到更精确的汽车分类得分。<br><strong>偏差技巧</strong> 为简化，这里有个小技巧，我们可以将参数\(W,b\)合为一个。常用方法是将两个参数集结合成一个单一矩阵，具体要通过扩展向量\(x_i\)的维度(增加一列)，多余出来的量默认用1来填充。这样，之前的得分函数就会变成下面这样单一矩阵乘法：$$f(x_i,W)=Wx_i$$还以CIFAR-10为例，\(x_i\)将由[3072x1]变为[3073x1]，\(W\)由[10x072]变为[10x3073]。\(W\)中多出来的列对应于偏差\(b_i\)。下面的图可能会便于理解：<br><img src="http://cs231n.github.io/assets/wb.jpeg" alt="偏差简化技巧示意图"></p><p><strong>图片预处理</strong> 上面例子中我们使用图像原始像素([0…255])，在机器学习中，更为常见的是规范化我们的输入。尤其重要的是通过减去每个特征的均值来<strong>中心化数据</strong>。对于图像而言就是要计算训练图片的均值，然后用每个图像去减去它得到像素范围在[-127,127]的图像。更进一步的常用方法是将每个图像像素值缩放至[-1,1]。零均值中心可能更重要，但我们打算放到理解了梯度下降之后再来讲。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a><span id="loss">损失函数</span></h3><p>上面章节定义了从像素值到分类得分的映射函数，通过一系列权重\(W\)使其参数化。我们希望通过调整权重值来达到预测分类得分和训练数据分类标签结果一致。<br>上面对猫的图片分类中，由于我们提供了随意的权重值，导致猫的分类得分远小于其他两个分类得分。我们将用一个<strong>损失函数</strong>(或叫<strong>成本函数</strong>，<strong>目标</strong>)来衡量得分结果与图片分类真值的差异。直观来讲，好的分类结果对应低的损失值，与之对应，坏的分类结果对应高的损失值。</p><h3 id="多类SVM损失"><a href="#多类SVM损失" class="headerlink" title="　多类SVM损失"></a><span id="svm">　多类SVM损失</span></h3><p>定义损失函数细节的方法有多种，我们先以常用的损失函数<strong>多类支持向量机(SVM)</strong>损失为例。通过固定余量Δ设置SVM损失使得SVM对于正确分类有较高的得分(相对于错误分类得分)。值得注意的是，正如我们上面所做的那样，有时候对拟人损失函数有所帮助：SVM希望在某种程度上产生更低的损失。<br>更精确一点。回想一下，对于第i个样本，给定图片\(x_i\)和标签\(y_i\)确定正确分类的索引。分数函数通过图片像素计算分类得分\(f(x_i,W)\)，我们简写作\(s\)。比如：第j个分类的得分就表示为第j个元素：\(s_j=f(x_i,W)_j\)。第i个样本的多类SVM损失可公式化表示如下：<br>$$L_i=\sum_{j≠y_i}{max(0,s_j-s_{y_i}+Δ)}$$</p><p><strong>例子</strong> 下面以一个例子来说明它是如何工作的。假定有三个分类及其得分\(s=[13,-7,11]\)，并且第一个分类是正确的分类(\(y_i=0\),\(y_i\):分类索引值)。另外假定Δ(超参数，接下来将讲到)为10。上述公式是对所有不正确的分类求和(\(j≠y_i\))，所以得到：<br>$$L_i=max(0,-7-13+10)+max(0,11-13+10)$$<br>很显然max(0,-7-13+10)结果为0，这是因为正确分类得分(13)高于错误分类得分至少10(固定Δ值)分。实际上是20分，远大于10分，但是SVM只关注两者差异至少是10分(差异高于10分的一律设置为0)。max(0,11-13+10)结果为8。也就是说，即使正确分类得分比不正确分类得分高(13&gt;11)，但差异不超过固定余量10。实际上差异是2，所以损失结果输出为8(为满足余量值所需的差异值大小)。总的来说，SVM损失函数期望正确分类得分\(y_i\)高于不正确分类得分至少Δ。如果不是，就需要累积损失。<br>注意到我们用的这个模块用了线性得分函数(\(f(x_i;W)=Wx_i\))，所以我们可以将损失函数等效为：<br>$$L_i=\sum_{j≠y_i}max(0,w_j^Tx_i-w_{y_j}^Tx_i+Δ)$$<br>其中，\(w_j\)是\(W\)的第j行转置成列。但是如果我们用更复杂的得分函数，情况就不一定了。<br>上述max(0,-)函数经常被称作<strong>hinge loss</strong>。有时会听到人们会用平方hinge loss SVM(L2-SVM)来代替，对应于\(max(0,-)^2\)，这会加强对偏离余量值的‘惩罚’。未平方版本更标准，但在某些数据集上，平方hinge loss会表现更好，这取决于交叉验证阶段的操作。</p><blockquote><p>损失函数量化了对训练集预测结果的不满</p></blockquote><p><img src="http://cs231n.github.io/assets/margin.jpg" alt="多类支持向量机工作原理。多类SVM&#39;期望&#39;正确分类得分高于不正确分类得分至少一个余量值，如果一个错误分类得分落在红色区域，那么将会有累积损失，否则损失将会是0。我们的目标是找到同时满足训练数据中所有示例的约束的权重，并给出尽可能低的总损失"></p><p><strong>正则化</strong> 上面提出的损失函数存在一个bug。假定我们有一个数据集和一个满足所有样本的参数集\(W\)(即所有得分满足上述规则，\(L_i=0\))。问题是\(W\)集可能不是唯一的：可能存在许多\(W\)的相似集满足样本。有一个简单方法验证：如果参数集\(W\)满足所有样本，那么参数集\(λW\)(λ&gt;1)也将给出0损失，因为这个操作是对所有参数的统一拉伸，因它们的绝对差值也是如此。比如，如果正确分类得分和临近不正确分类得分差值是15，对所有\(W\)中元素乘2将会得到新的差值30。<br>换句话讲，我们希望对权重集\(W\)进行某种程度上的编码来消除这种歧义性。我们可以用<strong>regularization penalty R(W)(正则化惩罚)</strong>来扩展损失函数。最常用的正则化惩罚是L2范数，它通过对所有参数的元素二次惩罚来阻止大权重：$$R(W)=\sum_{k}\sum_{l}W_{k,l}^2$$<br>上面表达式，我们对\(W\)的元素平方求和。注意到正则化函数不是与数据(图像)的函数——它仅仅是基于权重的函数。正则化惩罚完善了多类SVM，包含两部分：数据损失(所有样本数据的平均损失\(L_i\))、正则化损失。也即，完整的多类SVM表示如下：<br>$$L = \underbrace{ \frac{1}{N} \sum_i L_i }<em>\text{data loss} + \underbrace{ \lambda R(W) }</em>\text{regularization loss} $$<br>或者以完整形式扩展：<br>\(L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + \Delta) \right] + \lambda \sum_k\sum_l W_{k,l}^2\)<br>其中，N是训练样本的数量。将正则化惩罚加上去，用超参量λ作为权重。这个超参量通常取决于交叉验证。<br>除了上述提到的原因之外，正则化惩罚还有许多理想的属性，我们将会在随后讲到。例如，事实证明，加入L2惩罚会使得SVM中具有更吸引力的最大边缘属性。(<a href="http://cs229.stanford.edu/notes/cs229-notes3.pdf" target="_blank" rel="noopener">CS229</a>中将会详细讲到)<br>最吸引人的特性是惩罚大权重会改善(分类器)泛化性能，因为这意味着输入维度对最终得分没有影响。例如，假定我们有输入向量：\(x=[1,1,1,1]\)和两个权重向量：\(w_1=[1,0,0,0]\),\(w_2=[0.25,0.25,0.25,0.25]\)。那么\(w_1^Tx=w_2^Tx=1\)，两个权重向量会产生相等的点积，但是对\(w_1\)的L2惩罚是1.0而对\(w_2\)的L2惩罚仅为0.25。所以，根据L2惩罚，权重向量\(w_2\)表现更好因为它实现了跟你更低的正则化损失。直观上是因为权重\(w_2\)更小且更弥散。L2惩罚更偏向于小且弥散的权重向量，’the final classifier is encouraged to take into account all input dimensions to small amounts rather than a few input dimensions and very strongly’。后面我们将看到，这个影响能够改善分类器在测试集上的泛化性能并拥有较低的过拟合。<br>注意到偏差不像权重值那样的影响强度。因此通常知识调整权重而不是偏差。然而，在实际操作中，这经常会产生一些细微的影响。最后，注意到因为正则化惩罚，我们无法在所有样例中实现0.0的精确损失。<br><strong>代码</strong> 这里给出了损失函数(未正则化)的Python实现(未矢量和半矢量形式)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i</span><span class="params">(x, y, W)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  unvectorized version. Compute the multiclass svm loss for a single example (x,y)</span></span><br><span class="line"><span class="string">  - x is a column vector representing an image (e.g. 3073 x 1 in CIFAR-10)</span></span><br><span class="line"><span class="string">    with an appended bias dimension in the 3073-rd position (i.e. bias trick)</span></span><br><span class="line"><span class="string">  - y is an integer giving index of correct class (e.g. between 0 and 9 in CIFAR-10)</span></span><br><span class="line"><span class="string">  - W is the weight matrix (e.g. 10 x 3073 in CIFAR-10)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  delta = <span class="number">1.0</span> <span class="comment"># see notes about delta later in this section</span></span><br><span class="line">  scores = W.dot(x) <span class="comment"># scores becomes of size 10 x 1, the scores for each class</span></span><br><span class="line">  correct_class_score = scores[y]</span><br><span class="line">  D = W.shape[<span class="number">0</span>] <span class="comment"># number of classes, e.g. 10</span></span><br><span class="line">  loss_i = <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> xrange(D): <span class="comment"># iterate over all wrong classes</span></span><br><span class="line">    <span class="keyword">if</span> j == y:</span><br><span class="line">      <span class="comment"># skip for the true class to only loop over incorrect classes</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># accumulate loss for the i-th example</span></span><br><span class="line">    loss_i += max(<span class="number">0</span>, scores[j] - correct_class_score + delta)</span><br><span class="line">  <span class="keyword">return</span> loss_i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i_vectorized</span><span class="params">(x, y, W)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  A faster half-vectorized implementation. half-vectorized</span></span><br><span class="line"><span class="string">  refers to the fact that for a single example the implementation contains</span></span><br><span class="line"><span class="string">  no for loops, but there is still one loop over the examples (outside this function)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  delta = <span class="number">1.0</span></span><br><span class="line">  scores = W.dot(x)</span><br><span class="line">  <span class="comment"># compute the margins for all classes in one vector operation</span></span><br><span class="line">  margins = np.maximum(<span class="number">0</span>, scores - scores[y] + delta)</span><br><span class="line">  <span class="comment"># on y-th position scores[y] - scores[y] canceled and gave delta. We want</span></span><br><span class="line">  <span class="comment"># to ignore the y-th position and only consider margin on max wrong class</span></span><br><span class="line">  margins[y] = <span class="number">0</span></span><br><span class="line">  loss_i = np.sum(margins)</span><br><span class="line">  <span class="keyword">return</span> loss_i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L</span><span class="params">(X, y, W)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  fully-vectorized implementation :</span></span><br><span class="line"><span class="string">  - X holds all the training examples as columns (e.g. 3073 x 50,000 in CIFAR-10)</span></span><br><span class="line"><span class="string">  - y is array of integers specifying correct class (e.g. 50,000-D array)</span></span><br><span class="line"><span class="string">  - W are weights (e.g. 10 x 3073)</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="comment"># evaluate loss over all examples in X without using any for loops</span></span><br><span class="line">  <span class="comment"># left as exercise to reader in the assignment</span></span><br></pre></td></tr></table></figure></p><p>本节的内容是SVM损失采用一种特定的方法来测量训练数据的预测与真值标签的一致性。 此外，对训练集进行良好预测相当于最大限度地减少损失。</p><blockquote><p>我们需要做的就是提出一种找到满足最小损失的方法</p></blockquote><h4 id="实际考虑因素"><a href="#实际考虑因素" class="headerlink" title="实际考虑因素"></a>实际考虑因素</h4><p><strong>设置Δ</strong> 应该设为什么？需不需要进行交叉验证？实际上，超参量Δ在所有例子中可以被安全地设置为1.权重\(W\)的大小直接影响到最后的得分(和他们的差异)：因为我们缩小了\(W\)的值，得分之间的差异将会更低，另一方面我们放大了权重值，这会使得分之间的差异变大。因此，得分边界的确切值(e.g. Δ=1 or Δ=100)是没有意义的，因为权重可以随意缩放差异值。因此，唯一的权衡是允许权重值增长程度(通过正则化强度λ)。<br><strong>和二进制支持向量机的关系</strong> 二进制支持向量机下第i个样例的损失表示如下：$$L_i=Cmax(0,1-y_iw^Tx_i)+R(W)$$其中\(C\)是超参量，\(y_i \in {-1,1}\)。可以把二进制支持向量机理解为我们之前提出的多类SVM的一种特例：如果只有两个分类，多类SVM就成了二进制SVM。上述公式中的\(C\)和我们之前公式中的\(λ\)控制着相同的权衡，并且是倒数关系\(C \propto \frac{1}{\lambda}\)。<br><strong>原始优化</strong> 如果你以前了解SVM知识，你可能听说过内核，双重，SMO算法等。在这个课程中（神经网络）我们将一直使用无约束原始形式的优化目标。这些目标中的许多在技术上是不可微分的(例如，max(x，y)函数，因为当x=y时它具有扭结)，但实际上这不是问题，并且通常使用子梯度。<br><strong>其他多类SVM公式化</strong> 值得注意的是，本节提出的多类SVM是多个多类SVM公式化中的一个。另一个常用的公式是<em>One-Vs-All</em>(OVA)SVM，它为每个分类单独训练二进制SVM。还有不太常用的<em>All-vs-All</em>(AVA)策略。我们的公式遵从<a href="https://www.elen.ucl.ac.be/Proceedings/esann/esannpdf/es1999-461.pdf" target="_blank" rel="noopener">Weston and Watkins 1999 (pdf) </a>版本，这是一个比OVA更强大的版本(从某种意义上说，你可以构建多版本数据集，其中这个版本可以实现零数据损失，但OVA不能。如果感兴趣，请参阅论文)。最后是<em>结构化SVM</em>，它可以最大化正确分类得分与得分次高间的差距。理解这些公式之间的差异超出本课程范围。本节提出的版本是实际操作安全的，但最简单的OVA策略也可能同样有效</p><h3 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="　Softmax分类器"></a><span id="softmax">　Softmax分类器</span></h3><p>SVM是两个常用的分类器之一，另一个是<strong>Softmax classifier</strong>。如果你之前听过二进制Logistic Regression分类器，Softmax分类器是它在多类上的推广。不同于SVM将输出\(f(x_i,W)\)作为每个分类的得分，Softmax分类器给出一个更直观的输出(标准化类概率)，和稍后将讲到的概率解释。在Softmax分类器中，函数映射\(f(x_i;W)=Wx_i\)不变，但我们现在将这些分类得分解释为每个分类的非标准化对数概率，并用具有以下形式的交叉熵损失替换hinge损失：$$L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right) \hspace{0.5in} \text{or equivalently} \hspace{0.5in} L_i = -f_{y_i} + \log\sum_j e^{f_j}$$用\(f_j\)表示分类得分向量\(f\)的第j个元素。像之前一样，数据集的全部损失是所有训练样例\(L_i\)的平均值，有一个正则化术语\(R(W)\)。函数\(f_j(z) = \frac{e^{z_j}}{\sum_k e^{z_k}}\)被称作<strong>softmax function</strong>:它将任意真值得分向量压缩到值为0到1之间且和为1的向量。如果是第一次接触，softmax函数中涉及到的全交叉熵损失看起来很可怕，实际上相对容易激励。<br><strong>信息论观点</strong> “真实”分布\(p\)和预测分布\(q\)之间的交叉熵定义为：$$H(p,q) = - \sum_x p(x) \log q(x)$$Softmax分类器最小化两者之间的交叉熵(\(q = e^{f_{y_i}}  / \sum_j e^{f_j}\))，which in this interpretation is the distribution where all probability mass is on the correct class (i.e. \(p=[0,…1,…,0]\)contains a single 1 at the\(y_i\)-th position.)。此外，因为交叉熵可以被写作\(H(p,q) = H(p) + D_{KL}(p||q)\)，Δ函数\(p\)的熵为0，等同于两个分布之间KL差异(一种距离测量)的最小化。换句话说，交叉熵客观上_希望_预测分布能够在正确答案上有全部的质量。<br><strong>概率解释</strong> 下式：$$P(y_i \mid x_i; W) = \frac{e^{f_{y_i}}}{\sum_j e^{f_j} }$$可以解释为给定图像\(x_i\)和参数化\(W\)的正确标签\(y_i\)分配的（标准化）概率？？？Softmax分类器将输出向量\(f\)中的得分解释为未标准化的对数概率。指数化这些量给出的概率，并且执行除法归一化，使概率和为1。在这个概率解释中，我们因此最小化正确分类的负对数似然(这可以被解释为执行<strong>最大似然估计</strong>，MLE)。这种观点有个良好的特性，使得我们能够解释来自高斯先验超权重矩阵的完全损失函数中的正则化项\(R(W)\)，而不是我们正在执行的最大后验(MAP)估计。我们提到这些解释来帮助你的直觉，但推导的细节超出本课程范围。<br><strong>实际问题：数字稳定性</strong> 在实际编写用于计算Softmax函数的代码时，中间项\(e^{f_{y_i}}\)和\(\sum_j e^{f_j}\)会由于指数(运算)而变得非常大。划分大数值可能不稳定，因此使用归一化技巧很重要。请注意：如果我们将分子分母同乘一个常量C，并分别相加，我们得到下述表达式：\(\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}} = \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}\) \(C\)的值可以自由选择，这不会对结果造成影响，我们可以借助这个值来改善计算数值的稳定性。常用的选择是将其设为\(logC=-max_jf_j\)。代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) <span class="comment">#假设有3个分类获得较大的得分</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment">#坏:数值计算问题，潜在爆炸性计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#改善:左移f值，使得最大数字为0:</span></span><br><span class="line">f -= np.max(f) <span class="comment">#f变为[-666, -333, 0]</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># 安全计算，给出正确值</span></span><br></pre></td></tr></table></figure></p><p><strong>命名约定</strong>  确切来讲，SVM分类器使用hinge loss，或者有时候称作<strong>max-margin(最大边界) loss</strong>。Softmax分类器使用<strong>cross-entropy(交叉熵) loss</strong>。Softmax分类器名字来源于softmax函数，该函数用于将原始类分数压缩为归一化的正值，以便可以应用交叉熵损失。在实际中，需要注意的是：技术上谈论softmax损失是没有意义的，因为softmax只有压缩作用，但是它是一种相当常用的简写。</p><h3 id="SVM-vs-Softmax"><a href="#SVM-vs-Softmax" class="headerlink" title="　SVM vs. Softmax "></a><span id="svmvssoftmax">　SVM vs. Softmax </span></h3><p><img src="http://cs231n.github.io/assets/svmvssoftmax.png" alt="SVM和Softmax分类器比较"></p><p><strong>Softmax分类器提供了每个分类的可能性</strong> 与计算所有类别的未校准且不易解释的SVM不同，Softmax分类器允许我们计算所有分类的“概率”。例如：给定一个图片，SVM分类器可能给出标签为“猫，狗，船”的得分[12.5,0.6,-23.0]。Softmax分类器则将计算这三个分类的概率为[0.9,0.09,0.01]。然而，我们将概率加引号是因为这些概率的峰值或者扩散程度如何将直接取决于正则化强度\(λ\)-您负责作为系统的输入。例如：假定三个分类的非标准化对数概率输出为[1,-2,0]。Softmax函数计算如下：<br>$$[1, -2, 0] \rightarrow [e^1, e^{-2}, e^0] = [2.71, 0.14, 1] \rightarrow [0.7, 0.04, 0.26]$$<br>这一步是做了指数化和归一化。如果正则强度\(λ\)太高，权重\(W\)将会做更多惩罚以此来获得更小的权重。例如，假定权重变为原来一半([0.5,-1,0])，Softmax计算如下：<br>$$[0.5, -1, 0] \rightarrow [e^{0.5}, e^{-1}, e^0] = [1.65, 0.37, 1] \rightarrow [0.55, 0.12, 0.33]$$<br>现在概率更加分散。此外，由于非常强的正则化强度λ，权重朝向微小数量的极限，输出概率几乎是均匀的。因此，由Softmax分类器计算的概率更好地被认为是置信度，其中类似于SVM，分数的排序是可解释的，但绝对数字（或它们的差异）在技术上不是。</p><p><strong>实际上，SVM和Softmax通常具有可比性</strong> SVM和Softmax之间的性能差异通常很小，并且，不同的人对哪种分类器更好持有不同的观点。和Softmax分类器相比，SVM更local objective，这可以被当作是bug或者特性。考虑这样一个例子：分类得分为[10,-2,3]并且第一个分类是正确的分类。SVM(eg. \(Δ=1\))认为正确分类得分和其他分类得分差距已经超过边界值，因此计算的损失值为0。SVM不关心单个得分的细节：如果得分为[10,-100,-100]或者[10,9,9]，尽管边界值1是满足的，但是SVM是无关紧要的，因此损失值是0。然而对于Softmax分类器，情况是不一样的，得分[10,9,9]相比于[10,-100,-100]会积累更多的损失值。换句话说，Softmax分类器从不完全满意它产生的分数：正确的类总是有更高的概率，不正确的类总是更低的概率，并且损失总是会变得更好。然而SVM是一旦边际得到满足就会满意，并且它不会对超出次约束的精确得分进行微观管理。这可以直观地理解为一个特性：例如，一个汽车分类器可能将大部分“努力”用于将汽车从卡车上分离出来，不应受到青蛙分类(已经被分配非常低的得分并且可能聚集在数据云的完全不同的一侧)的影响</p><h3 id="Interactive-web-demo"><a href="#Interactive-web-demo" class="headerlink" title="　Interactive web demo "></a><span id="demo">　Interactive web demo </span></h3><p>演示地址：<a href="http://vision.stanford.edu/teaching/cs231n-demos/linear-classify/" target="_blank" rel="noopener">http://vision.stanford.edu/teaching/cs231n-demos/linear-classify/</a><br><img src="http://cs231n.github.io/assets/classifydemo.jpeg" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title=" 总结 "></a><span id="summary"> 总结 </span></h3><p>总结：</p><blockquote><p>定义从图像像素到分类得分的<strong>得分函数</strong>(本节中是依赖于权重W和偏差b的线性函数)<br>  不同于kNN分类器，这种<strong>参数法</strong>的优势在于一旦我们学习到这些参数值，就可以抛弃训练数据。除此之外，对测试图片的预测会很快因为它只需要一次矩阵乘法而不是去和每个训练样本比较<br>  引入<strong>偏差技巧</strong>，允许我们将偏差向量合并到权重矩阵中<br>  定义<strong>损失函数</strong>(我们为线性分类器引入了两个通用的损失函数：<strong>SVM</strong>和<strong>Softmax</strong>)来衡量训练集中给定参数和真值标签之间的兼容性。我们还发现这种方式定义的损失函数是对训练数据做出良好的预测相当于损失很小。</p></blockquote><p>我们现在看到了一种方法来获取图像数据集，并根据一组参数将每个图像映射到类别得分，我们看到了两个可用于衡量预测质量的损失函数示例。但是，我们如何有效地确定产生最佳（最低）损失的参数？这个过程是优化，它是下一节的主题。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/linear-classify/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/linear-classify/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分类&quot;&gt;&lt;a href=&quot;#线性分类&quot; class=&quot;headerlink&quot; title=&quot;线性分类&quot;&gt;&lt;/a&gt;线性分类&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入线性分类&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#score&quot;&gt;线性得分函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#interpret&quot;&gt;解释线性分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#loss&quot;&gt;损失函数&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#svm&quot;&gt;　多类SVM&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#softmax&quot;&gt;　Softmax分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#svmvssoftmax&quot;&gt;　SVM与Softmax&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#demo&quot;&gt;线性分类器Web交互式演示&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="视觉识别" scheme="http://blog.archiew.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog.archiew.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="线性分类" scheme="http://blog.archiew.top/tags/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>CS231n用于视觉识别的卷积神经网络-学习笔记1</title>
    <link href="http://blog.archiew.top/2018/07/05/CS231n%E7%94%A8%E4%BA%8E%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://blog.archiew.top/2018/07/05/CS231n用于视觉识别的卷积神经网络-学习笔记1/</id>
    <published>2018-07-05T01:24:20.000Z</published>
    <updated>2018-07-06T01:46:09.267Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://cs231n.github.io/classification/" target="_blank" rel="noopener">http://cs231n.github.io/classification/</a><br>翻译：<a href="http://blog.archiew.top">Archiew</a>  　<strong>转载需注明出处</strong></p><h2 id="图片分类问题-amp-数据驱动方法引入"><a href="#图片分类问题-amp-数据驱动方法引入" class="headerlink" title="图片分类问题&amp;数据驱动方法引入"></a>图片分类问题&amp;数据驱动方法引入</h2><p><span id="title"><a href="#title">目录</a></span><br><a href="#intro">引入图片分类、数据驱动方法，数据流</a><br><a href="#nnc">最近邻分类器</a><br><a href="#knn">　K-最近邻分类器</a><br><a href="#val">验证集、交叉验证和超参调整</a><br><a href="#procon">最近邻优缺点</a><br><a href="#summary">总结</a></p><a id="more"></a><hr><h3 id="引入图片分类、数据驱动方法，数据流"><a href="#引入图片分类、数据驱动方法，数据流" class="headerlink" title="引入图片分类、数据驱动方法，数据流"></a><span id="intro">引入图片分类、数据驱动方法，数据流</span></h3><p><strong>图片分类问题</strong> 就是从一组固定的类别标签中为输入图像分配一个标签。看似简单问题，却包含了计算机视觉的核心问题，有很大的实际应用价值。同时，后面将要讲到的其他计算机视觉任务(eg.目标检测、分割)都可以被简化为图片的分类。<br><strong>例子</strong> 在下面的图像中，图像分类模型接收单个图像并为其分配给4个可能的分类标签{cat,dog,hat,mug}。正如图片所示，我们需要明确：在计算机看来，这幅图片只是一个3维的数据集合——本例中图片表示为248x400x3(248:宽度 400:高度 3:通道数RGB)，所以计算机实际上对这副图片的认识是297600个数字——每个数字都是一个0(黑)~255(白)的整数，图片分类任务就是将这写数据转换成一个分类标签，比如：cat。<br><img src="http://cs231n.github.io/assets/classify.png" alt="图片分类任务"></p><p><strong>挑战</strong> 对人类来说，视觉识别概念相对容易，但对于计算机来说却是一个不小的算法挑战，具体表现为：</p><blockquote><ul><li>视角变化(Viewpoint variation)</li><li>尺度变化(Scale variation)</li><li>变形(Deformation)</li><li>遮挡(Occlusion)</li><li>照明变化(Illumination conditions)</li><li>背景杂乱(Background clutter)</li><li>内在变化(Intra-class variation)</li></ul></blockquote><p><img src="http://cs231n.github.io/assets/challenges.jpeg" alt="视觉识别需要面临的挑战"></p><p>好的图片分类模型需要对这些变化的向量积不变，同时要保证对图片内在变化的敏感性。<br><strong>数据驱动方法</strong> 不像写一个数据排序算法那样明确，识别单个物体的算法并不是很明显，因此我们不会尝试直接在代码中写一个对指定物体的识别算法，而是采用人类学习方式，通过为计算机提供大量的学习数据，然后开发学习算法，从这些提供数据中学习每个分类的‘特征’。这种方法被称为‘数据驱动’，因为它依赖于积累的训练数据集标记图像。以下是这种数据集的实示例：<br><img src="http://cs231n.github.io/assets/trainset.jpg" alt="用于计算机学习的图片数据集"></p><p><strong>图片分类流</strong> 以上，我们了解了图片分类的任务过程，可以总结为如下流程：</p><blockquote><ul><li>Input输入：包含N个图片的数据集(每个图片对应k个分类标签中的一个)，我们将其称为<strong>训练集</strong></li><li>Learning学习：图片分类任务是利用上述训练集学习每类图片的‘特征’，我们将其称为<strong>训练分类器</strong>或者<strong>学习模型</strong></li><li>Evalution评估：最后我们通过预测一组新的数据集分类来评估分类器的性能，直观上我们希望预测的标签与图片真实标签(称为<strong>真值</strong>)相匹配。</li></ul></blockquote><h3 id="最近邻分类器"><a href="#最近邻分类器" class="headerlink" title="最近邻分类器"></a><span id="nnc">最近邻分类器</span></h3><p>我们将第一种分类方法成为‘最邻近分类器’(Nearest Neighbor Classifier)。这个分类器和卷积神经网络不相关，并且在实际中几乎用不到，但是它给了我们一个解决图片分类问题的基本思路。<br><strong>图片分类数据集：CIFAR-10</strong> 一个图片分类常用数据集：<a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10 dataset</a>。这个数据集包含了60,000个32x32像素的小图片，每个图片都有一个标签分类(共10个分类：airplane,automobile,bird,etc)，这60,000个图片被分为两部分：50,000个训练集和10,000个测试集。下图随机展示了数据集中的部分图片<br><img src="http://cs231n.github.io/assets/nn.jpg" alt="CIFAR-10 dataset"><br>左：CIFAR-10 dataset示例图片。右：第一列展示了一些测试图片，后边各列展示了根据像素差异显示训练集中的前10个最近邻居。<br>上图可以看出右边的预测分类仅有3/10的匹配率。<br>最简单的分类器模型就是对32x32x3数据逐像素点比较差异并求和，换句话说，给定两个图片我们用两个向量\(I_1,I_2\)表示，那么合理的差异比较选择是<strong>L1 distance</strong>$$d_1(I_1,I_2)=\sum_{p}|I_1^p-I_2^p|$$<br>下图是这个过程的可视化：<br><img src="http://cs231n.github.io/assets/nneg.jpeg" alt="L1 distance比较两个图片差异。如果结果为0说明两个图片一样，如果结果很大说明两图差异比较大"></p><p>下面会给出这一分类器的代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载数据集:training data/labels、test data/labels</span></span><br><span class="line">Xtr, Ytr, Xte, Yte = load_CIFAR10(<span class="string">'data/cifar10/'</span>)</span><br><span class="line"><span class="comment">#将三维数据平铺成一维</span></span><br><span class="line">Xtr_rows = Xtr.reshape(Xtr.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment">#Xtr_rows变为50000 x 3072</span></span><br><span class="line">Xte_rows = Xte.reshape(Xte.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment">#Xte_rows变为10000 x 3072</span></span><br><span class="line"></span><br><span class="line">nn = NearestNeighbor() <span class="comment">#创建一个最近邻分类器</span></span><br><span class="line">nn.train(Xtr_rows, Ytr) <span class="comment">#在训练集(含标签)上训练分类器</span></span><br><span class="line">Yte_predict = nn.predict(Xte_rows) <span class="comment">#在测试集上预测标签</span></span><br><span class="line"><span class="comment">#打印预测分类准确度(取平均值)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'accuracy: %f'</span> % ( np.mean(Yte_predict == Yte) )</span><br></pre></td></tr></table></figure></p><p>准确度accuracy，经常作为一个评估标准来评价预测结果正确性。上面的代码中关键的是训练函数train(X,y)和预测函数predict(X)，最重要的是分类器本身的实现，下面的代码实现了一个具有L1 distane的简单的最近邻分类器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearestNeighbor</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">    <span class="string">""" X是NxD的训练集(其中每行代表一个数据样本). y是大小为N的一维数据 """</span></span><br><span class="line">    <span class="comment"># the nearest neighbor classifier simply remembers all the training data</span></span><br><span class="line">    self.Xtr = X</span><br><span class="line">    self.ytr = y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    <span class="string">""" X是NxD的测试集(每行代表一个我们需要预测标签的样本数据) """</span></span><br><span class="line">    num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 确保输入输出数据类型匹配</span></span><br><span class="line">    Ypred = np.zeros(num_test, dtype = self.ytr.dtype)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有测试集样本数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</span><br><span class="line">      <span class="comment"># 根据L1 distance找出和第i个测试图像最近邻的训练图片</span></span><br><span class="line">      distances = np.sum(np.abs(self.Xtr - X[i,:]), axis = <span class="number">1</span>)</span><br><span class="line">      min_index = np.argmin(distances) <span class="comment"># 获取最小差异图像的索引值</span></span><br><span class="line">      Ypred[i] = self.ytr[min_index] <span class="comment"># 预测最近邻样本的标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure></p><p>上述代码实现了在CIFAR-10上38.6%的准确度，相对于人类近94%或者最先进(state-of-the-art)的卷积神经网络近95%(<a href="http://www.kaggle.com/c/cifar-10/leaderboard" target="_blank" rel="noopener">最新排行</a>)的准确度来说，这个结果可谓悲观。<br><strong>距离的选择</strong> 除上述L1 distance之外，还有许多其他计算向量之间距离的方法，另一个常用的计算方法是‘L2 distance’，计算公式如下所示：<br>$$d_2(I_1-I_2)=\sqrt{\sum_p(I_1^p-I_2^p)^2}$$<br>换句话说，L1 distance计算的是像素差，而L2 distance计算的是像素差的平方和的开方，我们用一行代码来替换上述计算距离的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distances = np.sqrt(np.square(self.Xtr-X[i,:]), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>上述代码中的<code>np.sqrt</code>在实际操作中一般被略去，因为开方函数是一个单调函数。也就是说，它仅仅改变了距离的绝对尺度但保留了距离排序，因此是无关紧要的。用这种方法计算距离得到了35.4%的预测准确度(略低于用L1 distance的结果)</p><p><strong>L1 VS L2</strong> 考虑这两者之间的差异会很有趣。实际上在涉及到两向量差异时L2 distance比L1 distance更<em>unforgiving</em>，也就是说相对于大的差异来说L2 distance更偏向于中等大小的差异。L1和L2 distance(等效于一对图片差异的L1/L2范数???)时<a href="http://planetmath.org/vectorpnorm" target="_blank" rel="noopener">p范数</a>中最常用的特殊情况。</p><h4 id="K-最近邻分类器"><a href="#K-最近邻分类器" class="headerlink" title="　K-最近邻分类器"></a><span id="knn">　K-最近邻分类器</span></h4><p>注意到上述预测只是利用了给定图片最近邻图像的标签。实际上更为常用且表现更好的方法是使用我们称之为‘k-Nearest Neighbor Classifier’(K-最近邻分类器)的分类器。其原理很简单：我们在训练集中寻找与测试图片近邻的top k个图片而不是之前的金庸一个最近邻图片来做标签预测。实际上，当k=1时就是上述最近邻分类器。直观上k值越大，分类器对于异常值平滑效果越好。<br><img src="http://cs231n.github.io/assets/knn.jpeg" alt="最近邻分类器和5-最近邻分类器的比较"></p><p>虽然k-最近邻分类器优于最近分类器，但是还有一个k值的选择问题。</p><h3 id="验证集、交叉验证和超参调整"><a href="#验证集、交叉验证和超参调整" class="headerlink" title="验证集、交叉验证和超参调整"></a><span id="knc">验证集、交叉验证和超参调整</span></h3><p>k-最近邻分类器需要设定k值，如何确定最优k值？此外，还有不同的距离计算方法，如上所示的L1范式和L2范式，甚至我们未曾考虑的点积计算等。这些多样选择我们称之为<strong>超参数</strong>，在许多机器学习算法的设计中这是很常见的。通常情况下，超参数值的确定并不明显。<br>你可能想到通过尝试多个参数值来寻找出最优值。这确实是个好想法，并且我们也确实打算这样做，但是我们必须对此持谨慎的态度！实际上，我们<strong>不能使用测试集来调整超参数</strong>。在设计机器学习算法时我们必须时刻将测试集视为一个宝贵的资源，理想情况下我们只会在最后阶段运用它。否则会出现在测试集上表现良好的超参数值在部署模型到新预测图片时性能显著下降的问题。这个问题我们称之为对测试集的<strong>overfit(过拟合)</strong>。只在最后阶段使用测试集会是衡量我们的分类器模型<strong>泛化</strong>的一个好的代理。</p><blockquote><p>测试集上的评估只能使用一次，在最后阶段</p></blockquote><p>幸运的是，有一个好方法来调整超参数而不触碰到测试集。具体做法为：将一个训练集分割为两部分，一个训练集和一个较小样本的<strong>验证集</strong>。以CIFAR-10为例，我们可以将样本数据集分为：包含49,000个图片的训练集和包含1,000个图片的验证集，验证集本质上是作为伪测试集用来调整超参数的。<br>下面给出了具体在CIFAR-10上的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们已经得到了Xtr_rows, Ytr, Xte_rows, Yte</span></span><br><span class="line"><span class="comment"># Xtr_rows：50,000 x 3072 </span></span><br><span class="line">Xval_rows = Xtr_rows[:<span class="number">1000</span>, :] <span class="comment"># 取前1000样本做验证集</span></span><br><span class="line">Yval = Ytr[:<span class="number">1000</span>]</span><br><span class="line">Xtr_rows = Xtr_rows[<span class="number">1000</span>:, :] <span class="comment"># 取后49000样本做训练集</span></span><br><span class="line">Ytr = Ytr[<span class="number">1000</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找在出验证集上的最优超参数</span></span><br><span class="line">validation_accuracies = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]:</span><br><span class="line">  <span class="comment"># 选用一系列k值并在验证集上进行评估</span></span><br><span class="line">  nn = NearestNeighbor()</span><br><span class="line">  nn.train(Xtr_rows, Ytr)</span><br><span class="line">  <span class="comment"># here we assume a modified NearestNeighbor class that can take a k as input</span></span><br><span class="line">  Yval_predict = nn.predict(Xval_rows, k = k)</span><br><span class="line">  acc = np.mean(Yval_predict == Yval)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'accuracy: %f'</span> % (acc,)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 跟踪在验证集上的表现</span></span><br><span class="line">  validation_accuracies.append((k, acc))</span><br></pre></td></tr></table></figure></p><p>最后，我们可以绘制出每次验证集上的准确度图并找出最优k值，再将此k值带入分类器并在测试集上做最终评估。</p><blockquote><p>将你的训练集分割成训练集和验证集，使用验证集调整超参数，最后在测试集上做一次评估并输出分类器性能</p></blockquote><p><strong>交叉验证</strong> 如果训练集规模很小，更多的是用一种复杂的技术来调整超参数，我们称之为<strong>cross-validation(交叉验证)</strong>。还以先前例子为例，这次我们不是随意地将训练集的前1000个样本作验证集剩下的做训练集，我们可以通过迭代不同的验证集并平衡其性能以获得一种更好且噪声更小的估计k的特定值。例如，在5-折交叉验证中，我们将训练集分割成5等份，用其中的4个作为训练集剩1个做验证集，得到一个评估性能，然后迭代地分别取不同的小份做验证集，这样可以得到5个评估性能值(准确度)，最后取平均值。<br><img src="http://cs231n.github.io/assets/cvplot.png" alt="5-折交叉验证的例子，每个待选k值对应5个准确度指标，取它们的平均值绘图并找出最大值，最大值对应的k值即是我们要寻找的最优超参数k"></p><p><strong>实践</strong> 实际操作时人们会更倾向于避免交叉验证而使用单一验证，因为交叉验证会消耗大量的计算资源。人们一般会使用训练集的50%-90%作为训练剩下的做验证，而这取决于多个因素：如果超参数数量很多，你可能更倾向于分割出更大的验证集；而如果验证集中的样本数量很少(几百个)，最好是用交叉验证。常用的折数一般为3-折，5-折，10-折。<br><img src="http://cs231n.github.io/assets/crossval.jpeg" alt="常用的数据分割"></p><h3 id="最近邻优缺点"><a href="#最近邻优缺点" class="headerlink" title="最近邻优缺点"></a><span id="procon">最近邻优缺点</span></h3><p>考量最邻近分类器的优缺点是有必要的。很明显，一个优势是它很简单且易于理解，除此之外分类器无需花费时间去训练，但是我们的时间花费在了预测上，因为预测需要比较测试图片和每一个训练样本的差异。这是backwards(倒退的)，因为实际上我们更关注的是预测时的时间效率。实际上随后讲到的深度神经网络将这个权衡移到了另一个极端：在训练时花费大量资源(运算、时间)，而在训练结束它会非常快地对测试图片进行分类预测。这种操作模式在实际运用中更可取。<br>另外，对于最近邻分类器的计算复杂度是另一个活跃的研究点，并且有一些<strong>近似最近邻(ANN)</strong>算法和库可以加速数据集中最近邻的查找(eg. <a href="http://www.cs.ubc.ca/research/flann/" target="_blank" rel="noopener">FLANN</a>)。这些算法允许人们在查找期间利用空间/时间复杂度来权衡最近邻查找的正确性，并且通常依赖于涉及构建kdtree或运行k均值算法的预处理/索引阶段。<br>最近邻分类器在某些情况下会是一个很好的选择(尤其是低维度数据)，但是在实际运用中很少去用作分类设置，其中一个问题是图片是高维物体(包含了大量像素数据)，而且高维空间的距离可能非常违反直观感觉。下图说明了我们上面开发的基于像素的L2相似度与感知相似度非常不同的点：<br><img src="http://cs231n.github.io/assets/samenorm.png" alt=""></p><p><em>在高维数据(尤其是图片)上基于像素的距离可能非常不直观。原图(左)和其他三幅图片在L2像素距离上有很大差异。很明显，像素距离和感知或语义相似并不一致。</em><br>下面给出了更多可视化图片方便理解使用图片见的像素差异并不能很好地胜任分类问题。运用可视化技术(<a href="http://homepage.tudelft.nl/19j49/t-SNE.html" target="_blank" rel="noopener">t-SNE</a>)将CIFAR-10中的图片展示在二维面上，一边保留他们的(局部)成对距离。在可视化过程中距离最近的图片被认为是最相近的(根据上述L2像素距离来讲)。<br><img src="http://cs231n.github.io/assets/pixels_embed_cifar10_big.jpg" alt=""></p><p>实际上，上述图片相近的图片更多的是在背景色彩上具有相似性而不是语义上的相似性。理想情况下我们希望所有图片会形成10个聚类，因此相同类的图像彼此相邻近而忽视无关特征和变化(如背景)。但是要获得这种属性，我们必须超越原始像素。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><span id="summary">总结</span></h3><blockquote><ul><li>引入图片分类问题。给定一个带有单个分类标签的图片集，需要预测新的测试集中图片的分类并计算预测准确度。</li><li>引入了简单分类器<strong>最近邻分类器(Nearest Neighbor classifier)</strong>。认识到与分类器相关的多个超参数(k,distance计算类型等)，并且它们的选择并不明显</li><li>认识到设置超参数的正确方法是分割训练集为两部分：训练集和伪测试集(<strong>验证集</strong>)，尝试多个不同的超参数值并且选出在验证集上表现最好的那个值</li><li>如果缺少训练集，我们讨论了一个<strong>交叉验证(cross-validation)</strong>，这会帮助我们减少估计最优超参数值的噪声</li><li>一旦寻找到最优超参数值，我们将其固定下来并在真实测试集上做单次评估</li><li>认识到最近邻分类器在CIFAR-10上可以获得约40%的准确度，实现起来会很简单但是需要存储所有训练集并且在测试集上评估会很耗时</li><li>最后，我们认识到在原始像素上计算L1和L2距离并不能胜任分类工作，因为这种距离更多地和图片背景、色彩分布相关而不是图片的语义内容。</li></ul></blockquote><p>下一讲，着手处理本节中的挑战并且最终达到90%的准确度，让我们在完成学习之后完全抛弃训练集们，并且实现在1ms之内预测图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://cs231n.github.io/classification/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cs231n.github.io/classification/&lt;/a&gt;&lt;br&gt;翻译：&lt;a href=&quot;http://blog.archiew.top&quot;&gt;Archiew&lt;/a&gt;  　&lt;strong&gt;转载需注明出处&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片分类问题-amp-数据驱动方法引入&quot;&gt;&lt;a href=&quot;#图片分类问题-amp-数据驱动方法引入&quot; class=&quot;headerlink&quot; title=&quot;图片分类问题&amp;amp;数据驱动方法引入&quot;&gt;&lt;/a&gt;图片分类问题&amp;amp;数据驱动方法引入&lt;/h2&gt;&lt;p&gt;&lt;span id=&quot;title&quot;&gt;&lt;a href=&quot;#title&quot;&gt;目录&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;a href=&quot;#intro&quot;&gt;引入图片分类、数据驱动方法，数据流&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#nnc&quot;&gt;最近邻分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#knn&quot;&gt;　K-最近邻分类器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#val&quot;&gt;验证集、交叉验证和超参调整&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#procon&quot;&gt;最近邻优缺点&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#summary&quot;&gt;总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="视觉识别" scheme="http://blog.archiew.top/tags/%E8%A7%86%E8%A7%89%E8%AF%86%E5%88%AB/"/>
    
      <category term="卷积神经网络" scheme="http://blog.archiew.top/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="图像分类" scheme="http://blog.archiew.top/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式C语言面试题</title>
    <link href="http://blog.archiew.top/2018/07/04/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.archiew.top/2018/07/04/嵌入式C语言面试题/</id>
    <published>2018-07-04T12:44:30.000Z</published>
    <updated>2018-07-05T11:22:08.984Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些嵌入式软件开发中C语言面试问题</p><a id="more"></a><hr><h3 id="1、预处理指令-define"><a href="#1、预处理指令-define" class="headerlink" title="1、预处理指令#define"></a>1、预处理指令#define</h3><p>有几点需要注意：首先是语法(无分号结束,字母大写,括号使用…)；其次明白预处理器会将表达式计算出来代入需要用的地方，所以尽量用表达式来清晰定义其作用而不是直接给出一常量值；还有就是要注意常量值可能的溢出问题(用UL后缀解决)<br>给出几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//用#define声明一个常数来表示一年中有多少秒（忽略闰年）</span><br><span class="line">#define SEC_PER_YEAR(60*60*24*365)UL</span><br><span class="line"></span><br><span class="line">//用#define声明一个返回两个参数较小值的宏</span><br><span class="line">#define MIN(X,Y)(A)&gt;=(B)?(B):(A)</span><br><span class="line"></span><br><span class="line">//考虑</span><br><span class="line">#define PTR int *</span><br><span class="line">PTR a, b;//等价于int *a, b;</span><br><span class="line">int *a, *b;</span><br></pre></td></tr></table></figure></p><h3 id="2、关键字static的作用"><a href="#2、关键字static的作用" class="headerlink" title="2、关键字static的作用"></a>2、关键字static的作用</h3><p>C语言中static主要有三个作用：<br>函数体内，被static修饰的变量在函数内保持值不变；<br>模块内(函数外)，被static修饰的变量成为一个本地全局变量，在模块内可被调用，模块外不可；<br>模块内，被static修饰的函数可被模块内函数调用。</p><h3 id="3、关键字const的作用"><a href="#3、关键字const的作用" class="headerlink" title="3、关键字const的作用"></a>3、关键字const的作用</h3><p>const一般用来修饰那些‘只读’的变量，防止变量被修改<br>const int a;   //常整数<br>int const a;   //同上<br>int <em>const a;  //指向整数的常指针<br>const int </em>a;  //指向常整数的指针<br>int const *a cons;  //指向常整数的常指针</p><h3 id="4、关键字volatile的作用"><a href="#4、关键字volatile的作用" class="headerlink" title="4、关键字volatile的作用"></a>4、关键字volatile的作用</h3><p>volatile用来修饰可能会被意想不到改变的变量，编译器会忽略对被volatile修饰的变量进行优化，每次取变量值都会去地址处取。（编译器优化的变量值会被‘缓存’到寄存器，这样不用每次都去变量地址处取值）<br>volatile典型应用在三个地方：<br>中断服务程序中<br>硬件寄存器<br>多线程应用中<br>eg. #define REG_N    <em>(volatile unsigned int </em>)0x80000000</p><h3 id="5、中断服务函数ISR"><a href="#5、中断服务函数ISR" class="headerlink" title="5、中断服务函数ISR"></a>5、中断服务函数ISR</h3><p>有几点需要注意：<br>没有返回值<br>尽量避免浮点运算<br>尽量避免IO操作</p><h3 id="6、强制类型转换"><a href="#6、强制类型转换" class="headerlink" title="6、强制类型转换"></a>6、强制类型转换</h3><ul><li>无符号数operate有符号数=无符号数<br>eg. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo(void)&#123;</span><br><span class="line">unsigned int a=6;</span><br><span class="line">int b=-20;</span><br><span class="line">(a+b&gt;6)?puts(&quot;&gt;6&quot;):puts(&quot;&lt;=6&quot;)//a+b会强制转换为无符号数：-20转换为无符号数应该是一个很大的值，so...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些嵌入式软件开发中C语言面试问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深度学习目标检测模型概述</title>
    <link href="http://blog.archiew.top/2018/06/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.archiew.top/2018/06/26/深度学习目标检测模型概述/</id>
    <published>2018-06-26T01:04:46.000Z</published>
    <updated>2018-06-26T02:04:26.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、R-CNN"><a href="#1、R-CNN" class="headerlink" title="1、R-CNN"></a>1、R-CNN</h2><p>R-CNN(Region-based Convolutional Neural Network)分三个步骤：</p><ul><li>利用’选择性搜索(Selective Search)’算法生成约2k个region proposal，以获取可能出现的目标；</li><li>对每个region proposal运行CNN；</li><li>上述得到的CNN进行如下操作：<br>  a.输入到支持向量机(SVM),以对上述区域进行分类<br>  b.输入到一个线性回归器，以收缩目标周围边界框(假如目标存在)<br>R-CNN模型图如下所示：<br><a href="">R-CNN</a></li></ul><h2 id="2、Fast-R-CNN"><a href="#2、Fast-R-CNN" class="headerlink" title="2、Fast R-CNN"></a>2、Fast R-CNN</h2><p>Fast R-CNN相较于R-CNN主要是在检测速度方面进行了提升，而提升手段如下：</p><ul><li>在推荐区域之前，先对图像进行特征提取，这样做的好处是使整个图像只使用一个CNN(之前需要对2k个推荐区域分别运行CNN)</li><li>将R-CNN中的SVM替换为softmax，softmax直接输出类概率，而使用SVM需要训练多个SVM对每个目标类进行分类<br>相较R-CNN而言Fast R-CNN在速度上提升了许多，然而Fast R-CNN仍存在未解决的瓶颈问题：用于生成region proposal的选择搜索算法。</li></ul><h2 id="3、Faster-R-CNN"><a href="#3、Faster-R-CNN" class="headerlink" title="3、Faster R-CNN"></a>3、Faster R-CNN</h2><p>Faster R-CNN在Fast R-CNN的基础上通过引入region proposal网络(RPN)来代替选择搜索算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、R-CNN&quot;&gt;&lt;a href=&quot;#1、R-CNN&quot; class=&quot;headerlink&quot; title=&quot;1、R-CNN&quot;&gt;&lt;/a&gt;1、R-CNN&lt;/h2&gt;&lt;p&gt;R-CNN(Region-based Convolutional Neural Network)分三
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://blog.archiew.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://blog.archiew.top/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="R-CNN" scheme="http://blog.archiew.top/tags/R-CNN/"/>
    
      <category term="Fast R-CNN" scheme="http://blog.archiew.top/tags/Fast-R-CNN/"/>
    
      <category term="Faster R-CNN" scheme="http://blog.archiew.top/tags/Faster-R-CNN/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 cuda-9.2安装</title>
    <link href="http://blog.archiew.top/2018/06/19/Ubuntu16-04-4-cuda-9-2%E5%AE%89%E8%A3%85/"/>
    <id>http://blog.archiew.top/2018/06/19/Ubuntu16-04-4-cuda-9-2安装/</id>
    <published>2018-06-19T13:08:41.000Z</published>
    <updated>2018-07-05T11:22:50.523Z</updated>
    
    <content type="html"><![CDATA[<p>系统：win7 64位<br>显卡：NVIDIA GT740</p><h2 id="1-Ubuntu16-04-4双系统安装"><a href="#1-Ubuntu16-04-4双系统安装" class="headerlink" title="1 Ubuntu16.04.4双系统安装"></a>1 Ubuntu16.04.4双系统安装</h2><blockquote><p>工具：<br>   EasyBCD 2.3<br>   <a href="http://cdimage.ubuntu.com/netboot/16.04/?_ga=2.212435411.69853237.1529413894-897926102.1529413894" target="_blank" rel="noopener">ubuntu-16.04.4-desktop-amd64.iso</a></p></blockquote><a id="more"></a><hr><h3 id="1-1-准备磁盘空间"><a href="#1-1-准备磁盘空间" class="headerlink" title="1.1 准备磁盘空间"></a>1.1 准备磁盘空间</h3><p>在win7下<code>win+R</code>运行diskmgmt.msc打开磁盘管理，选择一个可用空间较大的磁盘右键压缩磁盘，得到一个空的分区（100G左右）</p><h3 id="1-2-配置引导"><a href="#1-2-配置引导" class="headerlink" title="1.2 配置引导"></a>1.2 配置引导</h3><p>将ubuntu-16.04.2-desktop-amd64.iso中的initrd.lz、vmlinuz.efi 解压出来与iso一同放在C盘或D盘根目录（必须根目录）下。打开EasyBCD，添加新条目-&gt;NeoGrub-&gt;安装-&gt;配置，配置文件内容如下：<br>注意：上面的文件放在C盘根目录则为 hd0,0 ，D盘则为hd0,4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># NeoSmart NeoGrub Bootloader Configuration File  </span><br><span class="line">#  </span><br><span class="line"># This is the NeoGrub configuration file, and should be located at C:\NST\menu.lst  </span><br><span class="line"># Please see the EasyBCD Documentation for information on how to create/modify entries:  </span><br><span class="line"># http://neosmart.net/wiki/display/EBCD/  </span><br><span class="line">  </span><br><span class="line">title Install Ubuntu   </span><br><span class="line">root (hd0,4)   </span><br><span class="line">kernel (hd0,4)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-16.04.2-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8   </span><br><span class="line">initrd (hd0,4)/initrd.lz</span><br></pre></td></tr></table></figure></p><p>然后，在EasyBCD中编辑引导菜单，可以看到NeoGrub引导加载器，勾选等待用户选择，保存。</p><h3 id="1-3-进入引导"><a href="#1-3-进入引导" class="headerlink" title="1.3 进入引导"></a>1.3 进入引导</h3><p>配置完后重启，选择NeoGrub引导加载器，上述配置无误即可进入Ubuntu界面</p><h3 id="1-4-开始安装"><a href="#1-4-开始安装" class="headerlink" title="1.4 开始安装"></a>1.4 开始安装</h3><p>在Ubuntu界面使用<code>ctrl+alt+T</code>打开终端，输入命令<code>sudo umount -l /isodevice</code>卸载分区，然后点击桌面的安装程序进行安装，依次进行如下设置：</p><blockquote><p>系统语言设为English(可选)<br>   勾选‘安装Ubuntu时下载更新’<br>   安装类型选择‘其他选项’<br>   系统分区：<br>      交换空间swap：逻辑分区、空间起始位置 16384MB(一般设为机器内存大小左右)<br>      /              ：逻辑分区、空间起始位置、用于Ext4 30720MB(存放安装程序)<br>      /home          : 逻辑分区、空间起始位置、用于Ext4 剩下空闲空间扣除250MB<br>      /boot          ：主分区、空间起始位置、用于Ext4 250MB<br>      注意最下面‘安装启动引导器的设备’选择刚才分配的/boot所在分区<br>   默认设置…</p></blockquote><h3 id="1-5-添加启动项"><a href="#1-5-添加启动项" class="headerlink" title="1.5 添加启动项"></a>1.5 添加启动项</h3><p>上述安装完成重启进入win7，打开EasyBCD，添加Ubuntu启动项，删除NeoGrub引导项<br>添加新条目-&gt;Linux/BSD-&gt;类型选’GRUB2’-&gt;驱动器选’Linux-2xx MiB’-&gt;添加条目<br>切换到编辑引导菜单，删除NeoGrub引导项。   </p><h2 id="2-cuda-9-2安装"><a href="#2-cuda-9-2安装" class="headerlink" title="2 cuda-9.2安装"></a>2 cuda-9.2安装</h2><p>ubuntu 16.04默认安装了第三方开源的驱动程序nouveau，安装nvidia显卡驱动首先需要禁用nouveau，不然会碰到冲突的问题，导致无法安装nvidia显卡驱动。<br>编辑文件blacklist.conf<br>`sudo vim /etc/modprobe.d/blacklist.conf’<br>在文件最后部分插入以下两行内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure></p><p>更新系统<code>sudo update-initramfs -u</code><br>重启，验证nouveau是否禁用<br><code>lsmod | grep nouveau</code><br>没有信息显示说明nouveau已禁用<br>按<code>ctrl+alt+f1</code>进入tty1<br><code>sudo service lightdm stop</code>关闭X server<br><code>sudo ./cuda_xxx.run</code> 运行事先下载好的cuda安装包<br>全都按默认配置<br><code>sudo service lightdm start</code><br>设置环境变量文件.bashrc或profile<br><code>export PATH=/usr/local/cuda-9.2/bin:$PATH</code><br><code>export LD_LIBRARY_PATH=/usr/local/cuda-9.2/lib64:#LD_LIBRARY_PATH</code><br>更新环境变量<br><code>souce /etc/profile</code><br>安装完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统：win7 64位&lt;br&gt;显卡：NVIDIA GT740&lt;/p&gt;
&lt;h2 id=&quot;1-Ubuntu16-04-4双系统安装&quot;&gt;&lt;a href=&quot;#1-Ubuntu16-04-4双系统安装&quot; class=&quot;headerlink&quot; title=&quot;1 Ubuntu16.04.4双系统安装&quot;&gt;&lt;/a&gt;1 Ubuntu16.04.4双系统安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;工具：&lt;br&gt;   EasyBCD 2.3&lt;br&gt;   &lt;a href=&quot;http://cdimage.ubuntu.com/netboot/16.04/?_ga=2.212435411.69853237.1529413894-897926102.1529413894&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ubuntu-16.04.4-desktop-amd64.iso&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://blog.archiew.top/tags/Ubuntu/"/>
    
      <category term="cuda" scheme="http://blog.archiew.top/tags/cuda/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式基础知识汇总</title>
    <link href="http://blog.archiew.top/2018/06/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.archiew.top/2018/06/19/嵌入式基础知识汇总/</id>
    <published>2018-06-19T01:04:51.000Z</published>
    <updated>2018-07-05T11:22:43.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-各数据类型所占字节大小"><a href="#1-各数据类型所占字节大小" class="headerlink" title="1.各数据类型所占字节大小"></a>1.各数据类型所占字节大小</h3><p><em>对于不同的处理器，所占空间大小取决于编译器的类型</em></p><a id="more"></a><hr><blockquote><p>16位编译器<br>char      : 1Byte<br>char*      : 2Byte        //也即指针变量<br>short int : 2Byte<br>int          : 2Byte<br>float      : 4Byte<br>double      : 8Byte<br>long      : 4Byte<br>long long : 8Byte</p></blockquote><blockquote><p>32位编译器<br>char       : 1Byte<br>char*      : 4Byte<br>int       : 4Byte<br>short int : 2Byte<br>float       : 4Byte<br>double      : 8Byte<br>long       : 4Byte<br>long long : 8Byte</p></blockquote><blockquote><p>64位编译器<br>char       : 1Byte<br>char*      : 8Byte<br>int          : 4Byte<br>short int : 2Byte<br>float      : 4Byte<br>double       : 8Byte<br>long       : 8Byte<br>long long : 8Byte</p></blockquote><h3 id="2-机器大小端问题"><a href="#2-机器大小端问题" class="headerlink" title="2.机器大小端问题"></a>2.机器大小端问题</h3><p>关于大小端：</p><blockquote><p>大端存储：高字节存低地址，即高位先存;(合乎阅读习惯)<br>   小端存储：低字节存低地址，即低位先存。</p></blockquote><p>例如：变量0x11223344,大小端存储如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址大端小端</span><br><span class="line">0x6ff7101144</span><br><span class="line">0x6ff7112233</span><br><span class="line">0x6ff7123322</span><br><span class="line">0x6ff7134411</span><br></pre></td></tr></table></figure></p><p>判断机器大小端方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">// 利用指针</span><br><span class="line">void test()&#123;</span><br><span class="line">int a=0x11223344;</span><br><span class="line">char *p=(char*)&amp;a;//取变量a的低地址</span><br><span class="line"></span><br><span class="line">if(0x11==*p)</span><br><span class="line">printf(&quot;大端\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;小端\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">// 利用联合体</span><br><span class="line">void test()&#123;</span><br><span class="line">union t&#123;</span><br><span class="line">int i;</span><br><span class="line">char c;</span><br><span class="line">&#125;t1;</span><br><span class="line"></span><br><span class="line">t1.i=1;</span><br><span class="line">if(1==t1.c)</span><br><span class="line">printf(&quot;小端\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;大端\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-结构体"><a href="#3-结构体" class="headerlink" title="3.结构体"></a>3.结构体</h3><p>描述下面宏XXX的作用</p><blockquote><p>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</p></blockquote><p>   #define XXX(ptr, type, member) ({ \<br>   const typeof( ((type <em>)0)-&gt;member ) </em><strong>mptr = (ptr); \<br>   (type <em>)( (char </em>)</strong>mptr - offsetof(type,member) );})</p><p>假设存在结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct s&#123;</span><br><span class="line">type1 A;</span><br><span class="line">type2 B;</span><br><span class="line">type3 C;</span><br><span class="line">&#125;s1;</span><br></pre></td></tr></table></figure></p><p>变量类型用typex代替是避免考虑内存中字节对齐的问题，现在s1在内存中的分布应该是这样的(假设的数据长度)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址变量</span><br><span class="line">0x80000A</span><br><span class="line">0x80004 B</span><br><span class="line">0x8000a C</span><br></pre></td></tr></table></figure></p><p>上面的宏运算涉及到的三个参数分别为：<br>ptr: 指向结构体成员的指针，比如type2<em> p=&amp;B<br>type: 结构体类型，比如struct s<br>member: 结构体成员名字，比如B<br>那么先看宏offsetof，((TYPE </em>)0)先将零类型转换为TYPE类型指针，((TYPE <em>)0)-&gt;MEMBER将访问TYPE结构体中的数据成员MEMBER，然后&amp;((TYPE </em>)0)-&gt;MEMBER取数据成员的地址，其实时取到了MEMBER成员相对于其所在结构体的偏移，最后(size_t)&amp;((TYPE <em>)0)-&gt;MEMBER实现结果类型转换<br>再看宏XXX，const typeof(((type </em>)0)-&gt;member)<em> <strong>mptr=(ptr);将结构体成员指针赋值指针变量</strong>mprt，(type</em>)((char*)__mptr-offsetof(type,member));是用结构体数据成员的指针减去该成员在结构体中的偏移量，得到结构体的基指针，最后强制转换成结构体指针类型<br>综上所述，该宏定义实现了根据结构体某成员变量获取该结构体基地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-各数据类型所占字节大小&quot;&gt;&lt;a href=&quot;#1-各数据类型所占字节大小&quot; class=&quot;headerlink&quot; title=&quot;1.各数据类型所占字节大小&quot;&gt;&lt;/a&gt;1.各数据类型所占字节大小&lt;/h3&gt;&lt;p&gt;&lt;em&gt;对于不同的处理器，所占空间大小取决于编译器的类型&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://blog.archiew.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="嵌入式" scheme="http://blog.archiew.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04.4 安装OpenCV3.2.0</title>
    <link href="http://blog.archiew.top/2018/06/15/Ubuntu16-04-4-%E5%AE%89%E8%A3%85OpenCV3-2/"/>
    <id>http://blog.archiew.top/2018/06/15/Ubuntu16-04-4-安装OpenCV3-2/</id>
    <published>2018-06-15T08:27:52.000Z</published>
    <updated>2018-07-05T11:22:35.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h2><ul><li>GCC ≥4.4.x</li><li>CMake ≥2.8.7</li><li>Cit</li><li>GTK ≥2.x,including headers (libgtk2.0-dev)</li><li>pkg-config</li><li>Python ≥2.6,Numpy ≥1.5,with developer packages(python-dev,python-numpy)</li><li>ffmpeg or libav development packages: libavcodec-dev, libavformat-dev, libswscale-dev</li><li>[可选] libtbb2 libtbb-dev</li><li>[可选] libdc1394 2.x</li><li>[可选] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev, libdc1394-22-dev</li><li>[可选] CUDA Toolkit ≥6.5 </li></ul><a id="more"></a><hr><p>通过以下命令来安装上述依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure></p><h2 id="下载OpenCV源码"><a href="#下载OpenCV源码" class="headerlink" title="下载OpenCV源码"></a>下载OpenCV源码</h2><p>1.<a href="http://opencv.org/releases.html" target="_blank" rel="noopener">下载页</a>下载最新稳定版<br>2.从Git Repository获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv.git</span><br><span class="line">git clone https://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure></p><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>1.创建临时文件夹，用于存放Makefiles等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/opencv</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure></p><p>2.配置并编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake [&lt;some optional parameters&gt;] &lt;path to the OpenCV source directory&gt;</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -D CMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">    -D INSTALL_PYTHON_EXAMPLES=ON \</span><br><span class="line">    -D INSTALL_C_EXAMPLES=OFF \</span><br><span class="line">    -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.2.0/modules \</span><br><span class="line">    -D PYTHON_EXCUTABLE=/usr/bin/python \</span><br><span class="line">    -D WITH_CUDA=ON \    # 使用CUDA</span><br><span class="line">    -D WITH_CUBLAS=ON \</span><br><span class="line">    -D DCUDA_NVCC_FLAGS=&quot;-D_FORCE_INLINES&quot; \</span><br><span class="line">    -D CUDA_ARCH_BIN=&quot;9.2&quot; \    # 使用的CUDA所对应的版本</span><br><span class="line">    -D CUDA_ARCH_PTX=&quot;&quot; \</span><br><span class="line">    -D CUDA_FAST_MATH=ON \    # 计算速度更快但是相对不精确</span><br><span class="line">    -D WITH_TBB=ON \</span><br><span class="line">    -D WITH_V4L=ON \</span><br><span class="line">    -D WITH_QT=ON \    # 如果qt未安装可以删去此行;若因为未正确安装qt导致的Qt5Gui报错，可将build内文件全部删除后重新cmake，具体可以参考[这里](http://stackoverflow.com/questions/17420739/opencv-2-4-5-and-qt5-error-s)</span><br><span class="line">    -D WITH_GTK=ON \</span><br><span class="line">    -D WITH_OPENGL=ON \</span><br><span class="line">    -D BUILD_EXAMPLES=ON ~/opencv</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;依赖包&quot;&gt;&lt;a href=&quot;#依赖包&quot; class=&quot;headerlink&quot; title=&quot;依赖包&quot;&gt;&lt;/a&gt;依赖包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GCC ≥4.4.x&lt;/li&gt;
&lt;li&gt;CMake ≥2.8.7&lt;/li&gt;
&lt;li&gt;Cit&lt;/li&gt;
&lt;li&gt;GTK ≥2.x,including headers (libgtk2.0-dev)&lt;/li&gt;
&lt;li&gt;pkg-config&lt;/li&gt;
&lt;li&gt;Python ≥2.6,Numpy ≥1.5,with developer packages(python-dev,python-numpy)&lt;/li&gt;
&lt;li&gt;ffmpeg or libav development packages: libavcodec-dev, libavformat-dev, libswscale-dev&lt;/li&gt;
&lt;li&gt;[可选] libtbb2 libtbb-dev&lt;/li&gt;
&lt;li&gt;[可选] libdc1394 2.x&lt;/li&gt;
&lt;li&gt;[可选] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev, libdc1394-22-dev&lt;/li&gt;
&lt;li&gt;[可选] CUDA Toolkit ≥6.5 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="-Ubuntu -OpenCV" scheme="http://blog.archiew.top/tags/Ubuntu-OpenCV/"/>
    
  </entry>
  
</feed>
